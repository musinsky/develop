<html>
<head><script type="text/javascript" src="/_static/js/bundle-playback.js?v=TPXmWR5s" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=txqj7nKC" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.fortran.com/F77_std/f77_std.html","20060326203401","https://web.archive.org/","web","/_static/",
	      "1143405241");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=S1zqJCYt" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

<title>Fortran 77 Standard</title>
</head>
<body>
<pre>

                                                   ANSI X3J3/90.4



                             1.  INTRODUCTION

          1.1  Purpose

          This standard specifies the form  and  establishes  the
          interpretation  of  programs  expressed  in the FORTRAN
          language.  The purpose of this standard is  to  promote
          portability of FORTRAN programs for use on a variety of
          data processing systems.

          1.2  Processor

          The combination of a data  processing  system  and  the
          mechanism  by which programs are transformed for use on
          that data processing system is called  a  processor  in
          this standard.

          1.3  Scope

          1.3.1  Inclusions.  This standard specifies:

             (1) The form of a program  written  in  the  FORTRAN
                 language

             (2) Rules for interpreting the  meaning  of  such  a
                 program and its data

             (3) The form of writing input data to  be  processed
                 by  such  a program operating on data processing
                 systems

             (4) The form of the output data resulting  from  the
                 use of such a program on data processing systems

          1.3.2  Exclusions.  This standard does not specify:

             (1) The mechanism by which programs are  transformed
                 for use on a data processing system

             (2) The method of transcription of programs or their
                 input   or   output  data  to  or  from  a  data
                 processing medium

             (3) The operations required for setup and control of
                 the use of programs on data processing systems

             (4) The results when the rules of this standard fail
                 to establish an interpretation

             (5) The size or complexity of a program and its data
                 that  will  exceed  the capacity of any specific



          FORTRAN 77 Full Language                       Page 1-1







          INTRODUCTION                             ANSI X3J3/90.4



                 data processing system or the  capability  of  a
                 particular processor

             (6) The range or precision of numeric quantities and
                 the method of rounding of numeric results

             (7) The physical properties of input/output records,
                 files, and units

             (8) The physical properties  and  implementation  of
                 storage

          1.4  Conformance

          The  requirements, prohibitions, and options  specified
          in  this  standard generally refer to permissible forms
          and  relationships  for  standard-conforming   programs
          rather than for processors.  The obvious exceptions are
          the optional output  forms  produced  by  a  processor,
          which  are  not  under  the  control of a program.  The
          requirements,   prohibitions,   and   options   for   a
          standard-conforming  processor usually must be inferred
          from those given for programs.

          An executable program (2.4.2) conforms to this standard
          if it uses only those forms and relationships described
          herein  and  if   the   executable   program   has   an
          interpretation  according  to this standard.  A program
          unit (2.4) conforms to  this  standard  if  it  can  be
          included  in  an  executable  program  in a manner that
          allows  the   executable   program   to   be   standard
          conforming.

          A processor conforms to this standard  if  it  executes
          standard-conforming  programs in a manner that fulfills
          the interpretations  prescribed  herein.   A  standard-
          conforming  processor  may  allow  additional forms and
          relationships  provided  that  such  additions  do  not
          conflict  with  the  standard  forms and relationships.
          However,  a  standard-conforming  processor  may  allow
          additional intrinsic functions (15.10) even though this
          could cause a conflict with the  name  of  an  external
          function  in  a standard-conforming program.  If such a
          conflict occurs, the processor is permitted to use  the
          intrinsic  function  unless  the  name  appears  in  an
          EXTERNAL  statement  within  the   program   unit.    A
          standard-conforming  program  must  not  use  intrinsic
          functions that have been added by the processor.   Note
          that  a  standard-conforming  program  must not use any
          forms or relationships  that  are  prohibited  by  this
          standard, but a standard-conforming processor may allow



          FORTRAN 77 Full Language                       Page 1-2







          INTRODUCTION                             ANSI X3J3/90.4



          such forms and relationships if they do not change  the
          proper interpretation of a standard-conforming program.

          Because a standard-conforming program may place demands
          on  the processor that are not within the scope of this
          standard or may include standard  items  that  are  not
          portable,  such as external procedures defined by means
          other than FORTRAN, conformance to this  standard  does
          not  ensure  that  a  standard-conforming  program will
          execute consistently on all or any  standard-conforming
          processors.

          1.4.1  Subset_Conformance.  This standard describes two
          levels  of the FORTRAN language, referred to as FORTRAN
          and subset FORTRAN.   FORTRAN  is  the  full  language.
          Subset FORTRAN is a subset of the full language.

          An executable program conforms to the subset  level  of
          this   standard   if  it  uses  only  those  forms  and
          relationships described herein for that  level  and  if
          the  executable program has an interpretation according
          to this standard at that level and would have the  same
          interpretation  in  the  full language.  A program unit
          conforms to the subset level of this standard if it can
          be  included  in an executable program in a manner that
          allows the executable program to be standard conforming
          at that level.

          A subset level processor conforms to the  subset  level
          of  this standard if it executes subset level standard-
          conforming programs  in  a  manner  that  fulfills  the
          interpretations  prescribed  herein for subset FORTRAN.
          A subset level processor may include an extension  that
          has a form and would have an interpretation at the full
          level only if  the  extension  has  the  interpretation
          provided  by  the full level.  A subset level processor
          may also include extensions that do not have forms  and
          interpretations in the full language.

          1.5  Notation_Used_in_This_Standard

          In this standard, "must" is. to  be  interpreted  as  a
          requirement;   conversely,   "must   not"   is   to  be
          interpreted as a prohibition.

          In  describing  the  form  of  FORTRAN  statements   or
          constructs,  the following metalanguage conventions and
          symbols are used:

             (1) Special characters from  the  FORTRAN  character
                 set,  uppercase letters, and uppercase words are



          FORTRAN 77 Full Language                       Page 1-3







          INTRODUCTION                             ANSI X3J3/90.4



                 to be written as shown, except  where  otherwise
                 noted.

             (2) Lowercase letters and lowercase  words  indicate
                 general  entities  for  which  specific entities
                 must be substituted in actual statements.   Once
                 a  given  lowercase  letter or word is used in a
                 syntactic specification to represent an  entity,
                 all  subsequent  occurrences  of  that letter or
                 word represent the same entity until that letter
                 or  word  is  used  in  a  subsequent  syntactic
                 specification to represent a different entity.

             (3) Brackets, [ ], are  used  to  indicate  optional
                 items.

             (4) An ellipsis, ...  , indicates that the preceding
                 optional  items  may appear one or more times in
                 succession.

             (5) Blanks are  used  to  improve  readability,  but
                 unless otherwise noted have no significance.

             (6) Words or  groups  of  words  that  have  special
                 significance  are underlined where their meaning
                 is  described.   Titles  and  the   metalanguage
                 symbols described in 1.5(2) are also underlined.

          An  example  illustrates  the  metalanguage.   Given  a
          description of the form of a statement as:

                               CALL sub___ [( [a_ [,a_]...] )]

          the following forms are allowed:

                     CALL sub___
                     CALL sub___ ()
                     CALL sub___ (a_)
                     CALL sub___ (a_, a_)
                     CALL sub___ (a_, a_, a_)
                     etc

          When an actual statement is written, specific  entities
          are substituted for sub and each a_; for example:

                               CALL ABCD (X,1.0)








          FORTRAN 77 Full Language                       Page 1-4







          INTRODUCTION                             ANSI X3J3/90.4



          1.6  Subset_Text

          The  section  titles  in  the  subset  description  are
          identical  to  the  section titles in the full language
          description.

          There are some instances in which a  general  situation
          occurs  in the full language but only a restricted case
          applies to  the  subset.   For  example,  in  3.6,  the
          "nonexecutable  statements"  that  may  appear  between
          executable statements may only be FORMAT statements  in
          the  subset.   In  most  of  these  instances, the more
          general text of the full language description has  been
          retained  in  the subset description, even though it is
          to be interpreted as covering only the restricted case.

          To help find differences between the  full  and  subset
          languages, vertical bars have been added in the margins
          where the text of the full and subset languages differ.
          For  example,  this  sentence  does  not  appear in the
          subset language text.

































          FORTRAN 77 Full Language                       Page 1-5











                                 CONTENTS


          1.  INTRODUCTION..................................  1-1
              1.1  Purpose..................................  1-1
              1.2  Processor................................  1-1
              1.3  Scope....................................  1-1
                   1.3.1  Inclusions........................  1-1
                   1.3.2  Exclusions........................  1-1
              1.4  Conformance..............................  1-2
                   1.4.1  Subset Conformance................  1-3
              1.5  Notation Used in This Standard...........  1-3
              1.6  Subset Text..............................  1-5









































                                   - i -







                                                   ANSI X3J3/90.4



                      2.  FORTRAN_TERMS_AND_CONCEPTS

          This section introduces basic terminology and concepts,
          some  of which are clarified further in later sections.
          Many terms and concepts of more specialized meaning are
          also  introduced  in  later  sections.   The underlined
          words are  described  here  and  used  throughout  this
          standard.

          2.1  Sequence

          A  sequence  is  a  set   ordered   by   a   one-to-one
          correspondence  with  the  numbers 1, 2, through n_. The
          number of elements in the sequence is n_. A sequence may
          be empty, in which case it contains no elements.

          The elements of a nonempty sequence are referred to  as
          the  first  element,  second  element,  etc.   The  n_th
          element, where n_ is  the  number  of  elements  in  the
          sequence,   is  called  the  last  element.   An  empty
          sequence has no first or last element.

          2.2  Syntactic_Items

          Letters, digits, and special characters of the  FORTRAN
          character  set  (3.1)  are  used  to form the syntactic
          items of the FORTRAN  language.   The  basic  syntactic
          items  of  the FORTRAN language are constants, symbolic
          names,  statement  labels,  keywords,  operators,   and
          special characters.

          The form of a constant is described in Section 4.

          A symbolic name takes the form of a sequence of one  to
          six  letters  or  digits,  the first of which must be a
          letter.    Classification   of   symbolic   names   and
          restrictions on their use are described in Section 18.

          A statement label takes the form of a sequence  of  one
          to  five  digits,  one of which must be nonzero, and is
          used to identify a statement (3.4).

          A keyword takes the form of  a  specified  sequence  of
          letters.   The  keywords  that  are  significant in the
          FORTRAN language are described in  Sections  7  through
          16.   In  many  instances,  a keyword or a portion of a
          keyword also meets  the  requirements  for  a  symbolic
          name.   Whether  a  particular  sequence  of characters
          identifies a keyword or a symbolic name is  implied  by
          context.   There  is  no sequence of characters that is
          reserved in all contexts in FORTRAN.



          FORTRAN 77 Full Language                       Page 2-1







          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4



          The set of special characters is described in 3.1.4.  A
          special  character  may  be  an  operator  or part of a
          constant or  have  some  other  special  meaning.   The
          interpretation is implied by context.

          2.3  Statements,_Comments,_and_Lines

          A FORTRAN statement is a sequence of  syntactic  items,
          as  described  in  Sections  7  through 16.  Except for
          assignment  and  statement  function  statements,  each
          statement begins with a keyword.  In this standard, the
          keyword or keywords that begin the statement  are  used
          to  identify  that    statement.   For  example, a DATA
          statement begins with the keyword DATA.

          A statement is written in one or more lines, the  first
          of  which is called an initial line (3.2.2); succeeding
          lines, if any, are called continuation lines (3.2.3).

          There is also a line called  a  comment  line  (3.2.1),
          which  is  not part of any statement and is intended to
          provide documentation.

          2.3.1  Classes_of_Statements.    Each   statement    is
          classified  as executable or nonexecutable (Section 7).
          Executable statements specify  actions.   Nonexecutable
          statements  describe  the characteristics, arrangement,
          and   initial   values   of   data;   contain   editing
          information;   specify  statement  functions;  classify
          program  units;  and  specify   entry   points   within
          subprograms.

          2.4  Program_Units_and_Procedures

          A program unit consists of a sequence of statements and
          optional  comment  lines.   A  program unit is either a
          main program or a subprogram.

          A main program is a program unit that does not  have  a
          FUNCTION,  SUBROUTINE,  or  BLOCK DATA statement as its
          first statement; it may have a PROGRAM statement as its
          first statement.

          A subprogram is a program unit  that  has  a  FUNCTION,
          SUBROUTINE,  or  BLOCK  DATA  statement  as  its  first
          statement.  A subprogram whose  first  statement  is  a
          FUNCTION  statement is called a function subprogram.  A
          subprogram  whose  first  statement  is  a   SUBROUTINE
          statement  is called a subroutine subprogram.  Function
          subprograms  and  subroutine  subprograms  are   called
          procedure   subprograms.   A  subprogram  whose   first



          FORTRAN 77 Full Language                       Page 2-2







          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4



          statement is a BLOCK DATA statement is called  a  block
          data subprogram.

          2.4.1  Procedures.    Subroutines   (15.6),    external
          functions  (15.5),  statement functions (15.4), and the
          intrinsic  functions  (15.3)  are  called   procedures.
          Subroutines  and external functions are called external
          procedures.   Function   subprograms   and   subroutine
          subprograms  may specify one or more external functions
          and   subroutines,   respectively   (15.7).    External
          procedures  may  also  be specified by means other than
          FORTRAN subprograms.

          2.4.2  Executable_Program.  An executable program is  a
          collection  of  program  units that consists of exactly
          one main program and any  number,  including  none,  of
          subprograms and external procedures.

          2.5  Variable

          A variable is an entity that has  both  a  name  and  a
          type.   A  variable name is a symbolic name of a datum.
          Such a datum may be  identified,  defined  (2.11),  and
          referenced   (2.12).   Note  that  the  usage  in  this
          standard of the word "variable" is more restricted than
          its  normal  usage,  in  that it does not include array
          elements.

          The type of a variable is optionally specified  by  the
          appearance  of  the  variable  name in a type-statement
          (8.4).  If it is  not  so  specified,  the  type  of  a
          variable is implied by the first letter of the variable
          name to be integer or real (4.1.2), unless the  initial
          letter  type  implication  is  changed by the use of an
          IMPLICIT statement (8.5).

          At any given time during the execution of an executable
          program,  a  variable  is  either  defined or undefined
          (2.11).

          2.6  Array

          An array is a nonempty sequence of data that has a name
          and a type.  The name of an array is a symbolic name.

          2.6.1  Array_Elements.  Each  of  the  elements  of  an
          array  is  called  an  array  element.   An  array name
          qualified by a subscript is an array element  name  and
          identifies  a  particular  element  of the array (5.3).
          Such a datum may be  identified,  defined  (2.11),  and
          referenced  (2.12).  The number of array elements in an



          FORTRAN 77 Full Language                       Page 2-3







          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4



          array  is specified by an array declarator (5.1).

          An array element has a type.  The  type  of  all  array
          elements within an array is the same, and is optionally
          specified by the appearance of  the  array  name  in  a
          type-statement  (8.4).   If it is not so specified, the
          type of an array element is implied by the first letter
          of the array name to be integer or real (4.1.2), unless
          the initial letter type implication is changed  by  the
          use of an IMPLICIT statement (8.5).

          At any given time during the execution of an executable
          program,   an   array  element  is  either  defined  or
          undefined (2.11).

          2.7  Substring

          A character datum is a nonempty sequence of characters.
          A  substring  is  a  contiguous  portion of a character
          datum.  The form of a substring name used to  identify,
          define  (2.11),  or  reference  (2.12)  a  substring is
          described in 5.7.1.

          At any given time during the execution of an executable
          program,  a  substring  is  either defined or undefined
          (2.11).

          2.8  Dummy_Argument

          A dummy argument in a procedure is  either  a  symbolic
          name  or  an  asterisk.  A symbolic name dummy argument
          identifies a variable, array, or procedure that becomes
          associated  (2.14)  with  an  actual  argument  of each
          reference  (2.12)  to  the  procedure  (15.2,   15.4.2,
          15.5.2,   and  15.6.2).   An  asterisk  dummy  argument
          indicates that the corresponding actual argument is  an
          alternate   return  specifier  (15.6.2.3,  15.8.3,  and
          15.9.3.5).

          Each dummy  argument  name  that  is  classified  as  a
          variable, array, or dummy procedure may appear wherever
          an actual name of the same class (Section 18) and  type
          may appear, except where explicitly prohibited.

          2.9  Scope_of_Symbolic_Names_and_Statement_Labels

          The scope of a symbolic name (18.1)  is  an  executable
          program,   a   program   unit,   a  statement  function
          statement, or an implied-DO list in a DATA statement.





          FORTRAN 77 Full Language                       Page 2-4







          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4



          The name of the main program and  the  names  of  block
          data  subprograms, external functions, subroutines, and
          common blocks have a scope of an executable program.

          The names of variables,  arrays,  constants,  statement
          functions,  intrinsic  functions,  and dummy procedures
          have a scope of a program unit.

          The names of variables that appear as  dummy  arguments
          in  a statement function statement have a scope of that
          statement.

          The names of variables that appear as  the  DO-variable
          of  an  implied-DO  in a DATA statement have a scope of
          the implied-DO list.

          Statement labels have a scope of a program unit.

          2.10  List

          A list  is  a  nonempty  sequence  (2.1)  of  syntactic
          entities separated by commas.  The entities in the list
          are called list items.

          2.11  Definition_Status

          At  any  gi  ven  time  during  the  execution  of   an
          executable  program,  the  definition  status  of  each
          variable, array element, or substring is either defined
          or undefined (Section 17).

          A defined entity has a value.  The value of  a  defined
          !entity  does  not  change  until  the  entity  becomes
          undefined or is redefined with a different value.

          If  a  variable,  array  element,   or   substring   is
          undefined, it does not have a predictable value.

          A previously defined  variable  or  array  element  may
          become  undefined.   Subsequent definition of a defined
          variable or array element is permitted, except where it
          is explicitly prohibited.

          A  character  variable,  character  array  element,  or
          character  substring  is  defined if every substring of
          length one of the entity is defined.  Note  that  if  a
          string  is  defined,  every  substring of the string is
          defined,  and  if  any  substring  of  the  string   is
          undefined,  the  string  is  undefined.   Defining  any
          substring does not cause any other string or  substring
          to become undefined.



          FORTRAN 77 Full Language                       Page 2-5







          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4



          An entity is initially defined  if  it  is  assigned  a
          value  in  a  DATA  statement  (Section  9).  Initially
          defined entities  are  in  the  defined  state  at  the
          beginning  of  execution of an executable program.  All
          variables and array elements not initially defined,  or
          associated (2.14) with an initially defined entity, are
          undefined  at  the  beginning  of   execution   of   an
          executable program.

          An entity must be defined at the time a reference to it
          is executed.

          2.12  Reference

          A variable, array element, or  substring  reference  is
          the   appearance  of  a  variable,  array  element,  or
          substring name,  respectively,  in  a  statement  in  a
          context  requiring  the value of that entity to be used
          during the execution of the executable program.  When a
          reference  to  an entity is executed, its current value
          is available.  In this standard, the act of defining an
          entity is not considered a reference to that entity.

          A procedure reference is the appearance of a  procedure
          name  in  a  statement  in  a context that requires the
          actions specified  by  the  procedure  to  be  executed
          during the execution of the executable program.  When a
          procedure reference is executed, the procedure must  be
          available.

          2.13  Storage

          A storage sequence is a sequence of storage  units.   A
          storage  unit  is  either  a  numeric storage unit or a
          character storage unit.

          An integer, real, or  logical  datum  has  one  numeric
          storage  unit in a storage sequence. A double precision
          or complex datum has two numeric  storage  units  in  a
          storage  sequence.  A character datum has one character
          storage unit in a storage sequence for  each  character
          in  the  datum.   This  standard  does  not  specify  a
          relationship between  a  numeric  storage  unit  and  a
          character storage unit.

          If a datum requires more than one  storage  unit  in  a
          storage sequence, those storage units are consecutive.

          The concept of a storage sequence is used  to  describe
          relationships   that   exist   among  variables,  array
          elements, arrays, substrings, and common blocks.   This



          FORTRAN 77 Full Language                       Page 2-6







          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4



          standard  does  not  specify a relationship between the
          storage sequence concept and the physical properties or
          implementation of storage.

          2.14  Association

          Association of entities exists if the same datum may be
          identified  by  different  symbolic  names  in the same
          program unit, or by the same name or a  different  name
          in  different  program  units  of  the  same executable
          program (17.1).

          Entities may become associated by the following:

             (1) Common association (8.3.4)

             (2) Equivalence association (8.2.2)

             (3) Argument association (15.9.3)

             (4) Entry association (15.7.3)

































          FORTRAN 77 Full Language                       Page 2-7











                                 CONTENTS


          2.  FORTRAN TERMS AND CONCEPTS....................  2-1
              2.1   Sequence................................  2-1
              2.2   Syntactic Items.........................  2-1
              2.3   Statements, Comments, and Lines.........  2-2
                    2.3.1  Classes of Statements............  2-2
              2.4   Program Units and Procedures............  2-2
                    2.4.1  Procedures.......................  2-3
                    2.4.2  Executable Program...............  2-3
              2.5   Variable................................  2-3
              2.6   Array...................................  2-3
                    2.6.1  Array Elements...................  2-3
              2.7   Substring...............................  2-4
              2.8   Dummy Argument..........................  2-4
              2.9   Scope of Symbolic Names and Statement
                    Labels..................................  2-4
              2.10  List....................................  2-5
              2.11  Definition Status.......................  2-5
              2.12  Reference...............................  2-6
              2.13  Storage.................................  2-6
              2.14  Association.............................  2-7































                                   - i -







                                                   ANSI X3J3/90.4



               3.  CHARACTERS,_LINES,_AND_EXECUTION_SEQUENCE

          3.1  FORTRAN_Character_Set

          The  FORTRAN  character  set  consists  of   twenty-six
          letters, ten digits, and thirteen special characters.

          3.1.1  Letters.  A letter  is  one  of  the  twenty-six
          characters:

            A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

          3.1.2  Digits.  A digit is one of the ten characters:

                            0 1 2 3 4 5 6 7 8 9

          A string of digits is interpreted in the  decimal  base
          number   system   when   a  numeric  interpretation  is
          appropriate.

          3.1.3  Alphanumeric_Characters.     An     alphanumeric
          character is a letter or a digit.

          3.1.4  Special_Characters.  A special character is  one
          of the thirteen characters:

8                    __________________________________

                     Character   Name of Character
8                    __________________________________

                                    Blank
8                     _________________9      Equals
                         +          Plus
                         -          Minus
                         *          Asterisk
                         /          Slash
                         (          Left Parenthesis
                         )          Right Parenthesis
                         ,          Comma
                         $          Currency Symbol
                         '          Apostrophe
                         :          Colon
8                    __________________________________
7                   |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|














                              |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|














                                                     |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
















          3.1.5  Collating_Sequence_and_Graphics.  The  order  in
          which  the  letters  are  listed in 3.1.1 specifies the
          collating sequence for the letters; A is less  than  Z.
          The  order  in  which  the  digits  are listed in 3.1.2
          specifies the collating sequence for the digits;  0  is
          less  than  9.   The  digits  and  letters  must not be
          intermixed in the collating sequence; all of the digits
          must  precede A or all of the digits must follow Z. The

9
          FORTRAN 77 Full Language                       Page 3-1







          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4



          character blank is less than the letter A and less than
          the digit 0.  The order in which the special characters
          are  listed  in  3.1.4  does  not  imply  a   collating
          sequence.

          Except for the currency symbol, the graphics  used  for
          the  forty-nine  characters  must be as given in 3.1.1,
          3.1.2, and 3.1.4.  However, the style of any graphic is
          not specified.

          3.1.6  Blank_Character.  With the exception of the uses
          specified  (3.2.2,  3.2.3, 3.3, 4.8, 4.8.1, 13.5.1, and
          13.5.2), a blank character within a program unit has no
          meaning  and  may  be used to improve the appearance of
          the program unit, subject to  the  restriction  on  the
          number of consecutive continuation lines (3.3).

          3.2  Lines

          A  line  in  a  program  unit  is  a  sequence  of   72
          characters.   All  characters  must be from the FORTRAN
          character set,  except  as  described  in  3.2.1,  4.8,
          12.2.2, and 13.2.1.

          The character positions in a line  are  called  columns
          and  are  numbered consecutively 1, 2, through 72.  The
          number indicates the sequential position of a character
          in  the  line,  beginning at the left and proceeding to
          the right.  Lines are ordered by the sequence in  which
          they  are  presented to the processor.  Thus, a program
          unit consists of a totally ordered set of characters.

          3.2.1  Comment_Line.  A comment line is any  line  that
          contains  a  C  or an asterisk in column 1, or contains
          only blank characters  in  columns  1  through  72.   A
          comment line that contains a C or an asterisk in column
          1 may contain any character capable  of  representation
          in the processor in columns 2 through 72.

          A comment line does not affect the  executable  program
          in any way and may be used to provide documentation.

          Comment lines may appear anywhere in the program  unit.
          Comment lines may precede the initial line of the first
          statement of  any  program  unit.   Comment  lines  may
          appear   between   an   initial   line  and  its  first
          continuation line or between two continuation lines.

          3.2.2  Initial_Line.  An initial line is any line  that
          is  not a comment line and contains the character blank
          or the digit 0 in column 6.  Columns 1  through  5  may



          FORTRAN 77 Full Language                       Page 3-2







          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4



          contain a statement label (3.4), or each of the columns
          1 through 5 must contain the character blank.

          3.2.3  Continuation_Line.  A continuation line  is  any
          line   that  contains  any  character  of  the  FORTRAN
          character set other than the  character  blank  or  the
          digit  0 in column 6 and contains only blank characters
          in columns 1 through 5.  A statement must not have more
          than nineteen continuation lines.

          3.3  Statements

          The statements of the FORTRAN language are described in
          Sections  7  through  16  and  are used to form program
          units.  Each statement is written in columns 7  through
          72   of  an  initial  line  and  as  many  as  nineteen
          continuation lines.  An END statement is  written  only
          in  columns  7 through 72 of an initial line.  No other
          statement in a program unit may have  an  initial  line
          that  appears  to  be  an  END  statement.  Note that a
          statement must contain no more  than  1320  characters.
          Except  as  part  of  a logical IF statement (11.5), no
          statement may begin on a line that contains any part of
          the previous statement.

          Blank characters  preceding,  within,  or  following  a
          statement  do  not  change  the  interpretation  of the
          statement, except when they  appear  within  the  datum
          strings  of  character constants or the H or apostrophe
          edit descriptors in FORMAT statements.  However,  blank
          characters do count as characters in the limit of total
          characters allowed in any one statement.

          3.4  Statement_Labels

          Statement  labels  provide  a  means  of  referring  to
          individual  statements.   Any statement may be labeled,
          but  only  labeled  executable  statements  and  FORMAT
          statements  may  be referred to by the use of statement
          labels.  The form of a statement label is a sequence of
          one  to five digits, one of which must be nonzero.  The
          statement label may be placed  anywhere  in  columns  1
          through  5  of  the initial line of the statement.  The
          same statement label must not be given to more than one
          statement  in a program unit.  Blanks and leading zeros
          are not significant in distinguishing between statement
          labels.







          FORTRAN 77 Full Language                       Page 3-3







          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4



          3.5  Order_of_Statements_and_Lines

          A PROGRAM  statement  may  appear  only  as  the  first
          statement  of a main program.  The first statement of a
          subprogram must be either a  FUNCTION,  SUBROUTINE,  or
          BLOCK DATA statement.

          Within a program unit that permits the statements:

             (1) FORMAT statements may appear anywhere;

             (2) all specification statements  must  precede  all
                 DATA  statements, statement function statements,
                 and executable statements;

             (3) all statement function statements  must  precede
                 all executable statements;

             (4) DATA statements may appear  anywhere  after  the
                 specification statements; and

             (5) ENTRY  statements  may  appear  anywhere  except
                 between   a   block   IF   statement   and   its
                 corresponding END IF statement, or between a  DO
                 statement  and the terminal statement of its DO-
                 loop.

          Within the specification statements of a program  unit,
          IMPLICIT    statements    must    precede   all   other
          specification statements except  PARAMETER  statements.
          Any  specification statement that specifies the type of
          a  symbolic  name  of  a  constant  must  precede   the
          PARAMETER   statement   that  defines  that  particular
          symbolic name of a constant;  the  PARAMETER  statement
          must   precede  all  other  statements  containing  the
          symbolic names of constants that  are  defined  in  the
          PARAMETER statement.

          The last  line  of  a  program  unit  must  be  an  END
          statement.














          FORTRAN 77 Full Language                       Page 3-4







          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4



                                 Figure 1

              Required Order of Statements and Comment Lines

8          _______________________________________________________

                          PROGRAM, FUNCTION, SUBROUTINE, or
                                BLOCK DATA Statement
8                    _____________________________________________

                                                    IMPLICIT
                                                   Statements
                                    PARAMETER8   _________________
9           Comment      FORMAT      Statements        Other
            Lines        and                      Specification
                        ENTRY                      Statements
                      Statements8  _______________________________
9                                                    Statement
                                                    Function
                                       DATA        Statements
                                    Statements8  _________________
9                                                   Executable
                   |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|999999999999999999999999999999999             |7|7|7|7|7|7|7|7|7|7|7|7|7|99999999999999999999999999             |7|7|7|7|7|7|7|7|7|7|7|7|7|99999999999999999999999999   Statements
8          _______________________________________________________

                              END Statement
8          _______________________________________________________
7         |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


















9                                                                |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|




















9          Figure  1  is  a  diagram  of  the  required  order  of
          statements  and  comment  lines  for  a  program  unit.
          Vertical lines delineate varieties of  statements  that
          may  be  interspersed.   For example, FORMAT statements
          may be interspersed with statement function  statements
          and  executable statements.  Horizontal lines delineate
          varieties of statements that must not be  interspersed.
          For  example, statement function statements must not be
          interspersed with executable statements.  Note that  an
          END  statement is also an executable statement and must
          appear only as the last statement of a program unit.

          3.6  Normal_Execution_Sequence_and_Transfer_of_Control

          Normal  execution  sequence   is   the   execution   of
          executable statements in the order in which they appear
          in a program unit.  Execution of an executable  program
          begins  with  the  execution  of  the  first executable
          statement  of  the  main  program.   When  an  external
          procedure  specified  in  a  subprogram  is referenced,
          execution begins with the  first  executable  statement
          that   follows   the  FUNCTION,  SUBROUTINE,  or  ENTRY
          statement that specifies the  referenced  procedure  as
          the name of a procedure.




          FORTRAN 77 Full Language                       Page 3-5







          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4



          A transfer of control is an alteration  of  the  normal
          execution   sequence.   Statements  that  may  cause  a
          transfer of control are:

             (1) GO TO

             (2) Arithmetic IF

             (3) RETURN

             (4) STOP

             (5) An input/output statement  containing  an  error
                 specifier or end-of-file specifier

             (6) CALL with an alternate return specifier

             (7) A logical IF statement  containing  any  of  the
                 above forms

             (8) Block IF and ELSE IF

             (9) The last statement, if any, of  an  IF-block  or
                 ELSE IF-block

            (10) DO

            (11) The terminal statement of a DO-loop

            (12) END

          The  effect  of  these  statements  on  the   execution
          sequence is described in Sections 11, 12, and 15.

          The normal execution sequence is not  affected  by  the
          appearance of nonexecutable statements or comment lines
          between executable statements.  Execution of a function
          reference  or  a  CALL  statement  is  not considered a
          transfer of control in the program unit  that  contains
          the  reference,  except  when  control is returned to a
          statement identified by an alternate  return  specifier
          in  a  CALL  statement.   Execution  of a RETURN or END
          statement in a referenced procedure, or execution of  a
          transfer  of  control within a referenced procedure, is
          not considered a transfer of  control  in  the  program
          unit that contains the reference.

          In the execution of an executable program, a  procedure
          subprogram must not be referenced a second time without
          the prior execution of a RETURN  or  END  statement  in
          that procedure.



          FORTRAN 77 Full Language                       Page 3-6







          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4

























































          FORTRAN 77 Full Language                       Page 3-7











                                 CONTENTS


          3.  CHARACTERS, LINES, AND EXECUTION SEQUENCE.....  3-
              1
              3.1  FORTRAN Character Set....................  3-1
                   3.1.1  Letters...........................  3-1
                   3.1.2  Digits............................  3-1
                   3.1.3  Alphanumeric Characters...........  3-1
                   3.1.4  Special Characters................  3-1
                   3.1.5  Collating Sequence and
                          Graphics..........................  3-1
                   3.1.6  Blank Character...................  3-2
              3.2  Lines....................................  3-2
                   3.2.1  Comment Line......................  3-2
                   3.2.2  Initial Line......................  3-2
                   3.2.3  Continuation Line.................  3-3
              3.3  Statements...............................  3-3
              3.4  Statement Labels.........................  3-3
              3.5  Order of Statements and Lines............  3-4
              3.6  Normal Execution Sequence and Transfer
                   of Control...............................  3-5
































                                   - i -







                                                   ANSI X3J3/90.4



                       4.  DATA_TYPES_AND_CONSTANTS

          4.1  Data_Types

          The six types of data are:

             (1) Integer

             (2) Real

             (3) Double precision

             (4) Complex

             (5) Logical

             (6) Character

          Each  type  is  different  and  may  have  a  different
          internal  representation.   The  type  may  affect  the
          interpretation of the operations involving the datum.

          4.1.1  Data_Type_of_a_Name.   The  name   employed   to
          identify a datum or a function also identifies its data
          type.   A  symbolic  name  representing   a   constant,
          variable,   array,   or   function  (except  a  generic
          function) must have only  one  type  for  each  program
          unit.   Once  a  particular  name  is identified with a
          particular type in a program unit, that type is implied
          for  any  usage  of  the  name in the program unit that
          requires a type.

          4.1.2  Type_Rules_for_Data_and_Procedure_Identifiers.
          A  symbolic  name that identifies a constant, variable,
          array, external function,  or  statement  function  may
          have  its  type  specified in a type-statement (8.4) as
          integer, real, double precision, complex,  logical,  or
          character.   In  the absence of an explicit declaration
          in a type-statement, the type is implied by  the  first
          letter  of  the name.  A first letter of I, J, K, L, M,
          or N implies type integer and any other letter  implies
          type  real,  unless an IMPLICIT statement (8.5) is used
          to change the default implied type.

          The data type of an array element name is the  same  as
          the type of its array name.

          The data type of a function name specifies the type  of
          the  datum  supplied  by  the  function reference in an
          expression.




          FORTRAN 77 Full Language                       Page 4-1







          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4



          A symbolic name that identifies  a  specific  intrinsic
          function  in  a program unit has a type as specified in
          15.10.  An explicit  type-statement  is  not  required;
          however, it is permitted.  A generic function name does
          not have a predetermined type; the result of a  generic
          function  reference  assumes a type that depends on the
          type of the argument, as  specified  in  15.10.   If  a
          generic function name appears in a type-statement, such
          an appearance is not sufficient by itself to remove the
          generic properties from that function.

          In a program unit that contains  an  external  function
          reference,  the  type  of the function is determined in
          the same manner as for variables and arrays.

          The  type  of  an  external   function   is   specified
          implicitly  by  its  name,  explicitly  in  a  FUNCTION
          statement, or explicitly  in  a  type-statement.   Note
          that an IMPLICIT statement within a function subprogram
          may affect the type of the external function  specified
          in the subprogram.

          A  symbolic  name  that  identifies  a  main   program,
          subroutine,  common block, or block data subprogram has
          no data type.

          4.1.3  Data_Type_Properties.   The   mathematical   and
          representation  properties  for  each of the data types
          are specified in the  following  sections.   For  real,
          double  precision,  and integer data, the value zero is
          considered neither positive nor negative.  The value of
          a  signed  zero is the same as the value of an unsigned
          zero.

          4.2  Constants

          A constant is an arithmetic constant, logical constant,
          or  character  constant.   The value of a constant does
          not  change.   Within  an   executable   program,   all
          constants that have the same form have the same value.

          4.2.1  Data_Type_of_a_Constant.  The form of the string
          representing  a  constant  specifies both its value and
          data  type.   A  PARAMETER  statement  (8.6)  allows  a
          constant  to  be  given  a symbolic name.  The symbolic
          name of a constant must not be used  to  form  part  of
          another constant.

          4.2.2  Blanks_in_Constants.  Blank characters occurring
          in  a constant, except in a character constant, have no
          effect on the value of the constant.



          FORTRAN 77 Full Language                       Page 4-2







          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4



          4.2.3  Arithmetic_Constants.   Integer,  real,   double
          precision,   and   complex   constants  are  arithmetic
          constants.

          4.2.3.1  Signs_of_Constants.  An unsigned constant is a
          constant  without a leading sign.  A signed constant is
          a constant with a  leading  plus  or  minus  sign.   An
          optionally  signed  constant  is a constant that may be
          either signed or unsigned.  Integer, real,  and  double
          precision constants may be optionally signed constants,
          except where specified otherwise.

          4.3  Integer_Type

          An integer datum is always an exact  representation  of
          an  integer value.  It may assume a positive, negative,
          or zero value.  It may assume only an  integral  value.
          An  integer  datum  has  one  numeric storage unit in a
          storage sequence.

          4.3.1  Integer_Constant.   The  form  of   an   integer
          constant  is  an  optional  sign followed by a nonempty
          string of digits.  The digit string is interpreted as a
          decimal number.

          4.4  Real_Type

          A real datum is a processor approximation to the  value
          of  a real number.  It may assume a positive, negative,
          or zero value.  A real datum has  one  numeric  storage
          unit in a storage sequence.

          4.4.1  Basic_Real_Constant.  The form of a  basic  real
          constant  is  an  optional  sign,  an  integer  part, a
          decimal point, and a fractional part,  in  that  order.
          Both  the  integer  part  and  the  fractional part are
          strings of digits; either of these parts may be omitted
          but  not  both.   A  basic real constant may be written
          with  more  digits  than  a  processor  will   use   to
          approximate  the  value  of the constant.  A basic real
          constant is interpreted as a decimal number.

          4.4.2  Real_Exponent.  The form of a real  exponent  is
          the  letter  E followed by an optionally signed integer
          constant.  A real exponent denotes a power of ten.

          4.4.3  Real_Constant.  The forms  of  a  real  constant
          are:

             (1) Basic real constant




          FORTRAN 77 Full Language                       Page 4-3







          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4



             (2) Basic real constant followed by a real exponent

             (3) Integer constant followed by a real exponent

          The value of a  real  constant  that  contains  a  real
          exponent  is  the product of the constant that precedes
          the E and the power of ten  indicated  by  the  integer
          following the E.  The integer constant part of form (3)
          may be written with more digits than a  processor  will
          use to approximate the value of the constant.

          4.5  Double_Precision_Type

          A double precision datum is a  processor  approximation
          to the value of a real number.  The precision, although
          not specified, must be greater than that of type  real.
          A   double  precision  datum  may  assume  a  positive,
          negative, or zero value.  A double precision datum  has
          two  consecutive  numeric  storage  units  in a storage
          sequence.

          4.5.1  Double_Precision_Exponent.  The form of a double
          precision  exponent  is  the  letter  D  followed by an
          optionally signed integer constant.  A double precision
          exponent  denotes  a  power of ten.  Note that the form
          and interpretation of a double precision  exponent  are
          identical  to those of a real exponent, except that the
          letter D is used instead of the letter E.

          4.5.2  Double_Precision_Constant.   The  forms   of   a
          double precision constant are:

             (1) Basic  real  constant  followed  by   a   double
                 precision exponent

             (2) Integer constant followed by a double  precision
                 exponent

          The value of a double precision constant is the product
          of  the  constant  that precedes the D and the power of
          ten indicated by the  integer  following  the  D.   The
          integer  constant  part of form (2) may be written with
          more digits than a processor will  use  to  approximate
          the value of the constant.

          4.6  Complex_Type

          A complex datum is a  processor  approximation  to  the
          value  of  a  complex  number.  The representation of a
          complex datum is in the form of an ordered pair of real
          data.   The  first of the pair represents the real part



          FORTRAN 77 Full Language                       Page 4-4







          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4



          of the complex datum  and  the  second  represents  the
          imaginary  part.   Each  part  has  the  same degree of
          approximation as for a real datum.  A complex datum has
          two  consecutive  numeric  storage  units  in a storage
          sequence; the first storage unit is the real  part  and
          the second storage unit is the imaginary part.

          4.6.1  Complex_Constant.   The  form   of   a   complex
          constant  is  a left parenthesis followed by an ordered
          pair of real or integer constants separated by a comma,
          and   followed  by  a  right  parenthesis.   The  first
          constant of the pair is the real part  of  the  complex
          constant and the second is the imaginary part.

          4.7  Logical_Type

          A logical datum may assume  only  the  values  true  or
          false.  A logical datum has one numeric storage unit in
          a storage sequence.

          4.7.1  Logical_Constant.  The forms  and  values  of  a
          logical constant are:

8                             _________________

                               Form     Value
8                             _________________

                              .TRUE.    true

                              .FALSE.   false

8                             _________________
7                            |7|7|7|7|7|7|7|






                                     |7|7|7|7|7|7|7|






                                             |7|7|7|7|7|7|7|








          4.8  Character_Type

          A character datum  is  a  string  of  characters.   The
          string   may  consist  of  any  characters  capable  of
          representation in the processor.  The  blank  character
          is  valid  and  significant  in a character datum.  The
          length of a character datum is the number of characters
          in  the  string.   A  character datum has one character
          storage unit in a storage sequence for  each  character
          in the string.

          Each character in the string has a  character  position
          that  is  numbered  consecutively  1,  2,  3, etc.  The
          number indicates the sequential position of a character
          in  the string, beginning at the left and proceeding to
          the right.


9


          FORTRAN 77 Full Language                       Page 4-5







          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4



          4.8.1  Character_Constant.  The  form  of  a  character
          constant is an apostrophe followed by a nonempty string
          of characters followed by an  apostrophe.   The  string
          may consist of any characters capable of representation
          in the processor.  Note that the delimiting apostrophes
          are  not part of the datum represented by the constant.
          An apostrophe within the datum string is represented by
          two consecutive apostrophes with no intervening blanks.
          In a character constant, blanks  embedded  between  the
          delimiting apostrophes are significant.

          The length of a character constant  is  the  number  of
          characters  between  the delimiting apostrophes, except
          that each pair of consecutive apostrophes counts  as  a
          single  character.   The delimiting apostrophes are not
          counted.  The length of a character  constant  must  be
          greater than zero.





































          FORTRAN 77 Full Language                       Page 4-6











                                 CONTENTS


          4.  DATA TYPES AND CONSTANTS......................  4-1
              4.1  Data Types...............................  4-1
                   4.1.1  Data Type of a Name...............  4-1
                   4.1.2  Type Rules for Data and Procedure
                          Identifiers.......................  4-1
                   4.1.3  Data Type Properties..............  4-2
              4.2  Constants................................  4-2
                   4.2.1  Data Type of a Constant...........  4-2
                   4.2.2  Blanks in Constants...............  4-2
                   4.2.3  Arithmetic Constants..............  4-3
              4.3  Integer Type.............................  4-3
                   4.3.1  Integer Constant..................  4-3
              4.4  Real Type................................  4-3
                   4.4.1  Basic Real Constant...............  4-3
                   4.4.2  Real Exponent.....................  4-3
                   4.4.3  Real Constant.....................  4-3
              4.5  Double Precision Type....................  4-4
                   4.5.1  Double Precision Exponent.........  4-4
                   4.5.2  Double Precision Constant.........  4-4
              4.6  Complex Type.............................  4-4
                   4.6.1  Complex Constant..................  4-5
              4.7  Logical Type.............................  4-5
                   4.7.1  Logical Constant..................  4-5
              4.8  Character Type...........................  4-5
                   4.8.1  Character Constant................  4-6


























                                   - i -







                                                   ANSI X3J3/90.4



                         5.  ARRAYS_AND_SUBSTRINGS

          An array is a nonempty  sequence  of  data.   An  array
          element  is  one  member  of  the sequence of data.  An
          array name is the symbolic name of an array.  An  array
          element name is an array name qualified by  a subscript
          (5.3).

          An array name not qualified by a  subscript  identifies
          the entire sequence of elements of the array in certain
          forms where such use is permitted (5.6); however, in an
          EQUIVALENCE statement, an array name not qualified by a
          subscript identifies the first  element  of  the  array
          (8.2.4).

          An array element name identifies  one  element  of  the
          sequence.   The subscript value (Table 1) specifies the
          element of the array  being  identified.   A  different
          array   element  may  be  identified  by  changing  the
          subscript value of the array element name.

          An array name is local to a program unit (18.1.2).

          A substring is a  contiguous  portion  of  a  character
          datum.

          5.1  Array_Declarator

          An array declarator  specifies  a  symbolic  name  that
          identifies an array within a program unit and specifies
          certain  properties  of  the  array.   Only  one  array
          declarator  for an array name is permitted in a program
          unit.

          5.1.1  Form_of_an_Array_Declarator.   The  form  of  an
          array declarator is:

                               a_ (d_ [,d_]...)

          where: a_   is the symbolic name of the array

                 d_   is a dimension declarator

          The number of dimensions of the array is the number  of
          dimension  declarators  in  the  array declarator.  The
          minimum number of dimensions is one and the maximum  is
          seven.

          5.1.1.1  Form_of_a_Dimension_Declarator.  The form of a
          dimension declarator is:




          FORTRAN 77 Full Language                       Page 5-1







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



                               [d_918:] d_92
9          where: d_918  is the lower dimension bound

                 d_928  is the upper dimension bound

          The lower and upper  dimension  bounds  are  arithmetic
          expressions,  called  dimension  bound  expressions, in
          which all constants, symbolic names of  constants,  and
          variables  are  of  type  integer.  The upper dimension
          bound of the last  dimension  may  be  an  asterisk  in
          assumed-size  array  declarators  (5.1.2).  A dimension
          bound expression must not contain a function  or  array
          element  reference.   Integer  variables  may appear in
          dimension bound expressions only  in  adjustable  array
          declarators (5.1.2).

          If the symbolic name of a  constant  or  variable  that
          appears  in  a  dimension  bound  expression  is not of
          default  implied  integer  type  (4.1.2),  it  must  be
          specified  as  integer  by  an  IMPLICIT statement or a
          type-statement prior to its appearance in  a  dimension
          bound expression.

          5.1.1.2  Value_of_Dimension_Bounds.    The   value   of
          either  dimension  bound  may be positive, negative, or
          zero; however, the value of the upper  dimension  bound
          must be greater than or equal to the value of the lower
          dimension bound.  If only the upper dimension bound  is
          specified,  the  value  of the lower dimension bound is
          one.  An upper dimension bound of an asterisk is always
          greater than or equal to the lower dimension bound.

          5.1.2  Kinds_and_Occurrences_of_Array_Declarators.
          Each  array  declarator  is  either  a  constant  array
          declarator,  an  adjustable  array  declarator,  or  an
          assumed-size   array   declarator.   A  constant  array
          declarator is an array declarator in which each of  the
          dimension  bound  expressions  is  an  integer constant
          expression (6.1.3.1).  An adjustable  array  declarator
          is  an  array  declarator  that  contains  one  or more
          variables.   An  assumed-size  array  declarator  is  a
          constant   array  declarator  or  an  adjustable  array
          declarator, except that the upper  dimension  bound  of
          the last dimension is an asterisk.

          Each  array  declarator  is  either  an  actual   array
          declarator or a dummy array declarator.






          FORTRAN 77 Full Language                       Page 5-2







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



          5.1.2.1  Actual_Array_Declarator.   An   actual   array
          declarator  is  an  array declarator in which the array
          name is  not  a  dummy  argument.   Each  actual  array
          declarator  must  be  a  constant array declarator.  An
          actual array declarator is  permitted  in  a  DIMENSION
          statement, type-statement, or COMMON statement (Section
          8).

          5.1.2.2  Dummy_Array_Declarator.    A    dummy    array
          declarator  is  an  array declarator in which the array
          name is a dummy argument.  A dummy array declarator may
          be  either  a  constant array declarator, an adjustable
          array declarator, or an assumed-size array  declarator.
          A  dummy  array  declarator is permitted in a DIMENSION
          statement or a  type-statement  but  not  in  a  COMMON
          statement.  A dummy array declarator may appear only in
          a function or subroutine subprogram.

          5.2  Properties_of_an_Array

          The following properties of an array are  specified  by
          the  array  declarator: the number of dimensions of the
          array, the size  and  bounds  of  each  dimension,  and
          therefore the number of array elements.

          The properties of  an  array  in  a  program  unit  are
          specified by the array declarator for the array in that
          program unit.

          5.2.1  Data_Type_of_an_Array_and_an_Array_Element.   An
          array  name  has a data type (4.1.1).  An array element
          name has the same data type as the array name.

          5.2.2  Dimensions_of_an_Array.     The    number     of
          dimensions  of  an  array  is  equal  to  the number of
          dimension declarators in the array declarator.

          The size of a dimension is the value:

                               d_928 - d_918 + 1

          where: d_918  is the value of the lower dimension bound

                 d_928  is the value of the upper dimension bound

          Note that if the value of the lower dimension bound  is
          one, the size of the dimension is d_928.

          The size  of  a  dimension  whose  upper  bound  is  an
          asterisk is not specified.




          FORTRAN 77 Full Language                       Page 5-3







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



          The  number  and  size  of  dimensions  in  one   array
          declarator may be different from the number and size of
          dimensions  in  another  array   declarator   that   is
          associated   by   common,   equivalence,   or  argument
          association.

          5.2.3  Size_of_an_Array.  The size of an array is equal
          to the number of elements in the array.  The size of an
          array is equal to the  product  of  the  sizes  of  the
          dimensions  specified  by the array declarator for that
          array name.  The size of an  assumed-size  dummy  array
          (5.5) is determined as follows:

             (1) If the  actual  argument  corresponding  to  the
                 dummy  array  is  a noncharacter array name, the
                 size of the dummy  array  is  the  size  of  the
                 actual argument array.

             (2) If the  actual  argument  corresponding  to  the
                 dummy array name is a noncharacter array element
                 name with a subscript value of r_ in an array  of
                 size x_, the size of the dummy array is x_ + 1 - r_
                 .

             (3) If the actual  argument  is  a  character  array
                 name, character array element name, or character
                 array  element  substring  name  and  begins  at
                 character  storage  unit  t_  of an array with c_
                 character storage units, then the  size  of  the
                 dummy  array  is INT((c_ + 1 - t_) / ln__), where ln__
                 is the length of an element of the dummy array.

          If an assumed-size dummy array has n_  dimensions,  the
          product of the sizes of the first n_ - 1 dimensions must
          be less than or equal to the  size  of  the  array,  as
          determined by one of the immediately preceding rules.

          5.2.4  Array_Element_Ordering.   The  elements  of   an
          array  are  ordered  in  a  sequence  (2.1).   An array
          element  name  contains  a  subscript   (5.4.1)   whose
          subscript value (5.4.3) determines which element of the
          array is identified by the  array  element  name.   The
          first  element  of  the  array has a subscript value of
          one; the second element has a subscript value  of  two;
          the  last  element  has  a subscript value equal to the
          size of the array.

          Whenever an array name unqualified by  a  subscript  is
          used to designate the whole array (5.6), the appearance
          of the array name implies that the number of values  to
          be  processed is equal to the number of elements in the



          FORTRAN 77 Full Language                       Page 5-4







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



          array and that the elements of  the  array  are  to  be
          taken in sequential order.

          5.2.5  Array_Storage_Sequence.  An array has a  storage
          sequence  consisting  of  the  storage sequences of the
          array elements in the order  determined  by  the  array
          element  ordering.   The  number of storage units in an
          array is x_*z_, where x_ is the number of the elements  in
          the array and z_ is the number of storage units for each
          array element.

          5.3  Array_Element_Name

          The form of an array element name is:

                               a_ (s_ [,s_]...)

          where: a_   is the array name

                 (s_ [,s_]...) is a subscript (5.4.1)

                 s_   is a subscript expression (5.4.2)

          The number of subscript expressions must  be  equal  to
          the  number  of  dimensions in the array declarator for
          the array name.

          5.4  Subscript

          5.4.1  Form_of_a_Subscript.  The form  of  a  subscript
          is:

                               (s_ [,s_]...)

          where s_ is a subscript expression.

          Note that the term "subscript" includes the parentheses
          that delimit the list of subscript expressions.

          5.4.2  Subscript_Expression.  A subscript expression is
          an  integer  expression.   A  subscript  expression may
          contain   array   element   references   and   function
          references.   Note that a restriction in the evaluation
          of expressions (6.6) prohibits  certain  side  effects.
          In  particular, evaluation of a function must not alter
          the value of any other subscript expression within  the
          same subscript.

          Within a program unit,  the  value  of  each  subscript
          expression  must  be  greater  than  or  equal  to  the
          corresponding  lower  dimension  bound  in  the   array



          FORTRAN 77 Full Language                       Page 5-5







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



          declarator  for the array.  The value of each subscript
          expression must  not  exceed  the  corresponding  upper
          dimension  bound  declared for the array in the program
          unit.  If the upper dimension bound is an asterisk, the
          value of the corresponding subscript expression must be
          such that the subscript value does not exceed the  size
          of the dummy array.

          5.4.3  Subscript_Value.   The  subscript  value  of   a
          subscript is specified in Table 1.  The subscript value
          determines which array element  is  identified  by  the
          array   element  name.   Within  a  program  unit,  the
          subscript value depends on the values of the  subscript
          expressions  in  the subscript and on the dimensions of
          the array specified in the  array  declarator  for  the
          array in the program unit.  If the subscript value is r_
          , the r_th element of the array is identified.





































          FORTRAN 77 Full Language                       Page 5-6







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



                                  Table 1_______

                              Subscript Value

8          _________________________________________________________

           n        Dimension         Subscript       Subscript
                   Declarator                           Value

8          _________________________________________________________

           1   (j918:k918)               (s918)          1+(s918-j918)

8          _________________________________________________________

           2   (j918:k918,j928:k928)         (s918,s928)       1+(s918-j918)
                                                    +(s928-j928)*d91
8
8          _________________________________________________________

           3   (j918:k918,j928:k928,j938:k938)   (s918,s928,s938)    1+(s918-j918)
                                                    +(s928-j928)*d91
8                                                    +(s938-j938)*d928*d91
8
8          _________________________________________________________


8          _________________________________________________________

           n   (j918:k918,...,j9n8:k9n8)     (s918,...,s9n8)   1+(s918-j918)
                                                    +(s928-j928)*d91
8                                                    +(s938-j938)*d928*d91
8                                                    +...
                                                    +(s9n8-j9n8)*d9n-1
8                                                     *d9n-28*...*d91
8
8          _________________________________________________________
7         |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



























            |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



























                                  |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



























                                                |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



























                                                                  |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|





























          Notes for Table 1:

             (1) n is the number of dimensions,  1 &lt; n &lt; 7.

             (2) j9i8 is the value of the lower bound  of  the  ith
                 dimension.

             (3) k9i8 is the value of the upper bound  of  the  ith
                 dimension.

             (4) If only the upper bound is specified, then j9i8% =
                  1.

             (5) s9i8 is the integer value  of  the  ith  subscript
                 expression.

9


          FORTRAN 77 Full Language                       Page 5-7







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



             (6) d9i8 = k9i8-j9i8+1 is the size of the  ith  dimension.
                 If  the value of the lower bound is 1, then d9i8 =
                  k9i8.

          Note that a subscript of  the  form  (j918,...j9n8)  has  a
          subscript value of one and identifies the first element
          of the array.  A  subscript  of  the  form  (k918,...,k9n8)
          identifies the last element of the array; its subscript
          value is equal to the number of elements in the array.

          The subscript value and the subscript expression  value
          are   not   necessarily  the  same,  even  for  a  one-
          dimensional array.  In the example:

                     DIMENSION A(-1:8),B(10,10)
                     A(2) = B(1,2)

          A(2) identifies the fourth element of A, the  subscript
          is  (2)  with  a  subscript  value  of  four,  and  the
          subscript expression is 2 with a value of two.   B(1,2)
          identifies  the eleventh element of B, the subscript is
          (1,2) with  a  subscript  value  of  eleven,   and  the
          subscript  expressions  are  1 and 2 with values of one
          and two.

          5.5  Dummy_and_Actual_Arrays

          A  dummy  array  is  an  array  for  which  the   array
          declarator  is  a  dummy array declarator.  An assumed-
          size dummy array is a dummy array for which  the  array
          declarator  is  an  assumed-size  array  declarator.  A
          dummy  array  is  permitted  only  in  a  function   or
          subroutine subprogram (Section 15).

          An actual  array  is  an  array  for  which  the  array
          declarator  is  an actual array declarator.  Each array
          in the main program is an actual array and must have  a
          constant  array  declarator.  A dummy array may be used
          as an actual argument.

          5.5.1  Adjustable_Arrays_and_Adjustable_Dimensions.  An
          adjustable  array  is  an  array  for  which  the array
          declarator is an adjustable array  declarator.   In  an
          adjustable    array    declarator,    those   dimension
          declarators that contain a  variable  name  are  called
          adjustable dimensions.

          An adjustable array declarator must be  a  dummy  array
          declarator.   At  least  one dummy argument list of the
          subprogram must contain  the  name  of  the  adjustable
          array.   A  variable  name  that appears in a dimension



          FORTRAN 77 Full Language                       Page 5-8







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



          bound expression of an array must also appear as a name
          either  in  every dummy argument list that contains the
          array name or in a common block in that subprogram.

          At the time of execution of a reference to  a  function
          or  subroutine  containing  an  adjustable array in its
          dummy  argument  list,  each   actual   argument   that
          corresponds   to   a  dummy  argument  appearing  in  a
          dimension bound  expression  for  the  array  and  each
          variable  in   common  appearing  in  a dimension bound
          expression for  the  array  must  be  defined  with  an
          integer  value.  The values of those dummy arguments or
          variables in common, together with  any  constants  and
          symbolic  names of constants appearing in the dimension
          bound   expression,   determine   the   size   of   the
          corresponding adjustable dimension for the execution of
          the subprogram.  The sizes of the adjustable dimensions
          and   of   any  constant  dimensions  appearing  in  an
          adjustable array declarator  determine  the  number  of
          elements   in the array and the array element ordering.
          The execution of different references to  a  subprogram
          or different executions of the same reference determine
          possibly  different  properties  (size  of  dimensions,
          dimension bounds, number of elements, and array element
          ordering) for each adjustable array in the  subprogram.
          These  properties  depend  on  the values of any actual
          arguments and variables in common that  are  referenced
          in   the   adjustable   dimension  expressions  in  the
          subprogram.

          During the execution of  an  external  procedure  in  a
          subprogram  containing  an  adjustable array, the array
          properties of dimension size, lower and upper dimension
          bounds,  and  array  size  (number  of  elements in the
          array) do not change.  However, the variables  involved
          in  an  adjustable dimension may be redefined or become
          undefined during execution of  the  external  procedure
          with no effect on the above-mentioned properties.

          5.6  Use_of_Array_Names

          In a program unit, each appearance  of  an  array  name
          must  be  in  an  array  element  name  except  in  the
          following cases:

             (1) In a list of dummy arguments

             (2) In a COMMON statement

             (3) In a type-statement




          FORTRAN 77 Full Language                       Page 5-9







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



             (4) In an array declarator.  Note that although  the
                 form  of an array declarator may be identical to
                 that  of  an  array  element  name,   an   array
                 declarator is not an array element name.

             (5) In an EQUIVALENCE statement

             (6) In a DATA statement

             (7) In the list of actual arguments in  a  reference
                 to an external procedure

             (8) In the list of an input/output statement if  the
                 array is not an assumed-size dummy array

             (9) As a unit identifier for an internal file in  an
                 input/output  statement  if  the array is not an
                 assumed-size dummy array

            (10) As the  format  identifier  in  an  input/output
                 statement  if  the  array is not an assumed-size
                 dummy array

            (11) In a SAVE statement

          5.7  Character_Substring

          A character substring is  a  contiguous  portion  of  a
          character  datum  and is of type character. A character
          substring is identified by a substring name and may  be
          assigned values and referenced.

          5.7.1  Substring_Name.  The forms of a  substring  name
          are:

                               v_ ( [e_918] : [e_928] )

                               a_ (s_ [,s_]...)( [e_918] : [e_928] )

          where: v_   is a character variable name

                 a_ (s_ [,s_]...) is a character array element name

                 e_918 and e_928 are each an integer expression and are
                     called substring expressions

          The value e_918 specifies the leftmost character  position
          of  the  substring,  and  the  value  e_928 specifies the
          rightmost  character  position.   For  example,  A(2:4)
          specifies  characters  in positions two through four of
          the character variable  A,  and  B(4,3)(1:6)  specifies



          FORTRAN 77 Full Language                      Page 5-10







          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4



          characters   in   positions  one  through  six  of  the
          character array element B(4,3).

          The values of e_918 and e_928 must be such that:

                               1 &lt; e_918 &lt; e_928 &lt; len___

          where len is the length of the  character  variable  or
          array  element  (8.4.2).   If e_918 is omitted, a value of
          one is implied for e_918.  If e_928 is omitted,  a  value  of
          len  is implied for e_928.  Both e_918 and e_928 may be omitted;
          for example, the form v_(:) is equivalent to v_, and  the
          form  a_ (s_ [,s_]...)(:) is equivalent to a_(s_  [,s_]...).
          The length of a character substring is e_928 - e_918 + 1.

          5.7.2  Substring_Expression.   A  substring  expression
          may  be any integer expression.  A substring expression
          may  contain  array  element  references  and  function
          references.   Note that a restriction in the evaluation
          of expressions (6.6) prohibits  certain  side  effects.
          In  particular, evaluation of a function must not alter
          the value of  any  other  expression  within  the  same
          substring name.































          FORTRAN 77 Full Language                      Page 5-11











                                 CONTENTS


          5.  ARRAYS AND SUBSTRINGS........................   5-1
              5.1  Array Declarator........................   5-1
                   5.1.1  Form of an Array
                          Declarator.......................   5-1
                   5.1.2  Kinds and Occurrences of Array
                          Declarators......................   5-2
              5.2  Properties of an Array..................   5-3
                   5.2.1  Data Type of an Array and an
                          Array Element....................   5-3
                   5.2.2  Dimensions of an Array...........   5-3
                   5.2.3  Size of an Array.................   5-4
                   5.2.4  Array Element Ordering...........   5-4
                   5.2.5  Array Storage Sequence...........   5-5
              5.3  Array Element Name......................   5-5
              5.4  Subscript...............................   5-5
                   5.4.1  Form of a Subscript..............   5-5
                   5.4.2  Subscript Expression.............   5-5
                   5.4.3  Subscript Value..................   5-6
              5.5  Dummy and Actual Arrays.................   5-8
                   5.5.1  Adjustable Arrays and Adjustable
                          Dimensions.......................   5-8
              5.6  Use of Array Names......................   5-9
              5.7  Character Substring.....................  5-10
                   5.7.1  Substring Name...................  5-10
                   5.7.2  Substring Expression.............  5-11


























                                   - i -







                                                   ANSI X3J3/90.4



                              6.  EXPRESSIONS

          This section describes the  formation,  interpretation,
          and   evaluation   rules   for  arithmetic,  character,
          relational, and logical expressions.  An expression  is
          formed from operands, operators, and parentheses.

          6.1  Arithmetic_Expressions

          An arithmetic expression is used to express  a  numeric
          computation.  Evaluation  of  an  arithmetic expression
          produces a numeric !value.

          The simplest form of an  arithmetic  expression  is  an
          unsigned  arithmetic  constant,  symbolic  name  of  an
          arithmetic  constant,  arithmetic  variable  reference,
          arithmetic  array  element  reference,   or  arithmetic
          function  reference.    More   complicated   arithmetic
          expressions   may  be  formed  by  using  one  or  more
          arithmetic operands together with arithmetic  operators
          and  parentheses.   Arithmetic  operands  must identify
          values of type  integer,  real,  double  precision,  or
          complex.

          6.1.1  Arithmetic_Operators.    The   five   arithmetic
          operators are:

8                   ____________________________________

                    Operator   Representing
8                   ____________________________________

                       **      Exponentiation
                       /       Division
                       *       Multiplication
                       -       Subtraction or Negation
                       +       Addition or Identity
8                   ____________________________________
7                  |7|7|7|7|7|7|7|7|







                            |7|7|7|7|7|7|7|7|







                                                      |7|7|7|7|7|7|7|7|









          Each of the operators **, /, and * operates on  a  pair
          of  operands  and  is written between the two operands.
          Each of the operators + and - either:

             (1) operates on a pair of operands  and  is  written
                 between the two operands, or

             (2) operates on a single  operand  and  is   written
                 preceding that operand.




9


          FORTRAN 77 Full Language                       Page 6-1







          EXPRESSIONS                              ANSI X3J3/90.4



          6.1.2  Form   and    Interpretation    of    Arithmetic
          Expressions.   The  interpretation  of  the  expression
          formed with each of the arithmetic  operators  in  each
          form of use is as follows:

8            ___________________________________________________

             Use of Operator   Interpretation
8            ___________________________________________________

                x918 ** x928       Exponentiate x918 to the power x92
8
                 x918 / x928       Divide x918 by x92
8
                 x918 * x928       Multiply x918 and x92
8
                 x918 - x928       Subtract x928 from x91
8
                    - x928       Negate x92
8
                 x918 + x928       Add x918 and x92
8
                    + x928       Same as x92
7            ___________________________________________________
7           |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















                            |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















                                                              |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|

















          where: x918  denotes the  operand  to  the  left  of  the
                     operator

                 x928  denotes the operand  to  the  right  of  the
                     operator

          The interpretation of a division may depend on the data
          types of the operands (6.1.5).

          A set of formation  rules  is  used  to  establish  the
          interpretation   of   an   arithmetic  expression  that
          contains two or more operators.  There is a  precedence
          among  the  arithmetic  operators, which determines the
          order in which the operands are to be  combined  unless
          the  order  is  changed by the use of parentheses.  The
          precedence of the arithmetic operators is as follows:

8                         _________________________

                          Operator   Precedence
8                         _________________________

                             **      Highest
                          * and /    Intermediate
                          + and -    Lowest
8                         _________________________
7                        |7|7|7|7|7|7|





                                  |7|7|7|7|7|7|





                                                 |7|7|7|7|7|7|







          For example, in the expression




          FORTRAN 77 Full Language                       Page 6-2







          EXPRESSIONS                              ANSI X3J3/90.4



                               - A ** 2

          the exponentiation operator (**)  has  precedence  over
          the  negation  operator (-); therefore, the operands of
          the exponentiation operator are  combined  to  form  an
          expression  that is used as the operand of the negation
          operator.  The interpretation of the  above  expression
          is the same as the interpretation of the expression

                               - (A ** 2)

          The arithmetic operands are:

             (1) Primary

             (2) Factor

             (3) Term

             (4) Arithmetic expression

          The formation rules to be applied in  establishing  the
          interpretation of arithmetic expressions are in 6.1.2.1
          through 6.1.2.4.

          6.1.2.1  Primaries.  The primaries are:

             (1) Unsigned arithmetic constant (4.2.3)

             (2) Symbolic name of an arithmetic constant (8.6)

             (3) Arithmetic variable reference (2.5)

             (4) Arithmetic array element reference (5.3)

             (5) Arithmetic function reference (15.2)

             (6) Arithmetic expression  enclosed  in  parentheses
                 (6.1.2.4)

          6.1.2.2  Factor.  The forms of a factor are:

             (1) Primary

             (2) Primary ** factor

          Thus, a factor is formed from a sequence of one or more
          primaries  separated  by  the  exponentiation operator.
          Form  (2)  indicates  that  in  interpreting  a  factor
          containing  two  or  more exponentiation operators, the
          primaries  are  combined  from  right  to  left.    For



          FORTRAN 77 Full Language                       Page 6-3







          EXPRESSIONS                              ANSI X3J3/90.4



          example, the factor

                               2**3**2

          has the same interpretation as the factor

                               2**(3**2)

          6.1.2.3  Term.  The forms of a term are:

             (1) Factor

             (2) Term / factor

             (3) Term * factor

          Thus, a term is formed from a sequence of one  or  more
          factors separated by either the multiplication operator
          or the division operator.  Forms (2) and  (3)  indicate
          that  in  interpreting  a  term  containing two or more
          multiplication or division operators, the  factors  are
          combined from left to right.

          6.1.2.4  Arithmetic_Expression.   The   forms   of   an
          arithmetic expression are:

             (1) Term

             (2) + term

             (3) - term

             (4) Arithmetic expression + term

             (5) Arithmetic expression - term

          Thus,  an  arithmetic  expression  is  formed  from   a
          sequence  of  one or more terms separated by either the
          addition operator or  the  subtraction  operator.   The
          first  term in an arithmetic expression may be preceded
          by the identity or the negation  operator.   Forms  (4)
          and  (5)  indicate  that  in interpreting an arithmetic
          expression  containing  two   or   more   addition   or
          subtraction operators, the terms are combined from left
          to right.

          Note  that  these  formation  rules   do   not   permit
          expressions   containing   two  consecutive  arithmetic
          operators, such as A**-B or A+-B.  However, expressions
          such as A**(-B) and A+(-B) are permitted.




          FORTRAN 77 Full Language                       Page 6-4







          EXPRESSIONS                              ANSI X3J3/90.4



          6.1.3  Arithmetic_Constant_Expression.   An  arithmetic
          constant  expression  is  an  arithmetic  expression in
          which each  primary  is  an  arithmetic  constant,  the
          symbolic   name   of  an  arithmetic  constant,  or  an
          arithmetic constant expression enclosed in parentheses.
          The exponentiation operator is not permitted unless the
          exponent is of type integer.  Note that variable, array
          element, and function references are not allowed.

          6.1.3.1  Integer_Constant_Expression.     An    integer
          constant   expression   is   an   arithmetic   constant
          expression in which each constant or symbolic name of a
          constant is of type integer.  Note that variable, array
          element, and function references are not allowed.

          The  following  are  examples   of   integer   constant
          expressions:

                     3
                     -3
                     -3+4

          6.1.4  Type   and    Interpretation    of    Arithmetic
          Expressions.  The data type of a constant is determined
          by the form of the constant (4.2.1).  The data type  of
          an  arithmetic  variable reference, symbolic name of an
          arithmetic   constant,   arithmetic    array    element
          reference,   or   arithmetic   function   reference  is
          determined  by  the  name  of  the  datum  or  function
          (4.1.2).   The  data  type  of an arithmetic expression
          containing  one  or  more   arithmetic   operators   is
          determined from the data types of the operands.

          Integer expressions, real expressions, double precision
          expressions,  and  complex  expressions  are arithmetic
          expressions whose values are  of  type  integer,  real,
          double precision, and complex, respectively.

          When the operator + or - operates on a single  operand,
          the  data  type of the resulting expression is the same
          as the data type of the operand.

          When an arithmetic  operator  operates  on  a  pair  of
          operands,  the data type of the resulting expression is
          given in Tables 2 and 3.  In these tables, each  letter
          I,  R,  D, or C represents an operand or result of type
          integer,   real,   double   precision,   or    complex,
          respectively.

          The type of the result is indicated by the I, R, D,  or
          C  that  precedes the equals, and the interpretation is



          FORTRAN 77 Full Language                       Page 6-5







          EXPRESSIONS                              ANSI X3J3/90.4



          indicated by the expression to the right of the equals.
          REAL, DBLE, and CMPLX are the type-conversion functions
          described in 15.10.

                                  Table 2_______

               Type and Interpretation of Result for x918 + x92
7          ________________________________________________________

             x928             I928                       R92
8           x91
7          ________________________________________________________

           I918           I = I918 + I928         R = REAL(I918) + R92
8
           R918        R = R918 + REAL(I928)      R = R918 + R92
8
           D918        D = D918 + DBLE(I928)      D = D918 + DBLE(R928)

           C918     C=C918+CMPLX(REAL(I928),0.)   C = C918 + CMPLX(R928,0.)
8          ________________________________________________________
7         |7|7|7|7|7|7|7|7|7|7|7|










               |7|7|7|7|7|7|7|7|7|7|7|










                                         |7|7|7|7|7|7|7|7|7|7|7|










                                                                 |7|7|7|7|7|7|7|7|7|7|7|












8          _______________________________________________________

             x928           D928                       C92
8           x91
7          _______________________________________________________

           I918      D = DBLE(I928) + D928     C=CMPLX(REAL(I928),0.)+C92
8
           R918      D = DBLE(R918) + D928     C = CMPLX(R918,0.) + C92
8
           D918      D = D918 + D928                 Prohibited

           C918         Prohibited         C = C918 + C92
7          _______________________________________________________
7         |7|7|7|7|7|7|7|7|7|7|7|










                |7|7|7|7|7|7|7|7|7|7|7|










                                      |7|7|7|7|7|7|7|7|7|7|7|










                                                                |7|7|7|7|7|7|7|7|7|7|7|












          Tables  giving   the   type   and   interpretation   of
          expressions  involving  -,  *, and / may be obtained by
          replacing all occurrences of + in Table 2 by -,  *,  or
          /, respectively.
















          FORTRAN 77 Full Language                       Page 6-6







          EXPRESSIONS                              ANSI X3J3/90.4



                                  Table 3_______

               Type and Interpretation of Result for x918**x92
7          _______________________________________________________

               x928           I928                     R92
8             x91
7          _______________________________________________________

             I918         I = I918**I928        R = REAL(I918)**R92
8
             R918         R = R918**I928        R = R918**R92
8
             D918         D = D918**I928        D = D918**DBLE(R928)

             C918         C = C918**I928        C = C918**CMPLX(R928,0.)
8          _______________________________________________________
7         |7|7|7|7|7|7|7|7|7|7|7|










                    |7|7|7|7|7|7|7|7|7|7|7|










                                     |7|7|7|7|7|7|7|7|7|7|7|










                                                                |7|7|7|7|7|7|7|7|7|7|7|












8          _______________________________________________________

             x928           D928                       C92
8           x91
7          _______________________________________________________

           I928      D = DBLE(I928)**D928     C=CMPLX(REAL(I928),0.)**C92
8
           R918      D = DBLE(R918)**D928     C = CMPLX(R918,0.)**C92
8
           D918      D = D918**D928                  Prohibited

           C918         Prohibited        C = C918**C92
7          _______________________________________________________
7         |7|7|7|7|7|7|7|7|7|7|7|










                |7|7|7|7|7|7|7|7|7|7|7|










                                     |7|7|7|7|7|7|7|7|7|7|7|










                                                                |7|7|7|7|7|7|7|7|7|7|7|












          Four entries in Table 3 specify an interpretation to be
          a  complex  value  raised to a complex power.  In these
          cases, the value of the expression  is  the  "principal
          value"  determined  by  x918**x928 = EXP(x928*LOG(x918)), where
          EXP and LOG are functions described in 15.10.

          Except for a value raised to an integer power, Tables 2
          and  3  specify  that  if two operands are of different
          type, the operand that differs in type from the  result
          of the operation is converted to the type of the result
          and then the operator operates on a pair of operands of
          the  same  type.   When  a primary of type real, double
          precision, or complex is raised to  an  integer  power,
          the  integer  operand  need  not  be converted.  If the
          value of I928 is negative, the interpretation  of  I918**I92
8          is  the  same as the interpretation of 1/(I918**ABS(I928)),
          which is subject to  the  rules  for  integer  division
          (6.1.5).    For  example,  2**(-3)  has  the  value  of
          1/(2**3), which is zero.





          FORTRAN 77 Full Language                       Page 6-7







          EXPRESSIONS                              ANSI X3J3/90.4



          The type  and  interpretation  of  an  expression  that
          consists  of  an  operator operating on either a single
          operand or a pair of operands are  independent  of  the
          context   in   which   the   expression   appears.   In
          particular, the type  and  interpretation  of  such  an
          expression  are  independent  of  the type of any other
          operand of any larger expression in which  it  appears.
          For  example,  if  X  is  of  type  real,  J is of type
          integer, and  INT  is  the  real-to-integer  conversion
          function,   the   expression  INT(X+J)  is  an  integer
          expression and X+J is a real expression.

          6.1.5  Integer_Division.  One operand of  type  integer
          may  be  divided  by  another  operand of type integer.
          Although the mathematical quotient of two  integers  is
          not  necessarily  an integer, Table 2 specifies that an
          expression involving the  division  operator  with  two
          operands   of   type   integer  is  interpreted  as  an
          expression of type  integer.   The  result  of  such  a
          division  is called an integer quotient and is obtained
          as follows:   If  the  magnitude  of  the  mathematical
          quotient  is  less  than  one,  the integer quotient is
          zero.  Otherwise, the integer quotient is  the  integer
          whose  magnitude  is  the largest integer that does not
          exceed the magnitude of the mathematical  quotient  and
          whose  sign is the same as the sign of the mathematical
          quotient.  For example, the value of the expression  (-
          8)/3 is (-2).

          6.2  Character_Expressions

          A character expression is used to express  a  character
          string.   Evaluation of a character expression produces
          a result of type character.

          The simplest  form  of  a  character  expression  is  a
          character   constant,  symbolic  name  of  a  character
          constant, character variable reference, character array
          element  reference,  character  substring reference, or
          character   function   reference.   More    complicated
          character  expressions  may  be  formed by using one or
          more  character  operands   together   with   character
          operators and parentheses.

          6.2.1  Character_Operator.  The character operator is:









          FORTRAN 77 Full Language                       Page 6-8







          EXPRESSIONS                              ANSI X3J3/90.4



8                        __________________________

                         Operator   Representing
8                        __________________________

                            //      Concatenation
8                        __________________________
7                       |7|7|7|7|



                                 |7|7|7|7|



                                                 |7|7|7|7|





          The interpretation of the expression  formed  with  the
          character operator is:

8                __________________________________________

                 Use of Operator   Interpretation
8                __________________________________________

                    x918 // x928       Concatenate x918 with x92
7                __________________________________________
7               |7|7|7|7|



                                |7|7|7|7|



                                                         |7|7|7|7|





          where: x918  denotes the  operand  to  the  left  of  the
                     operator

                 x928  denotes the operand  to  the  right  of  the
                     operator

          The result of a concatenation operation is a  character
          string  whose  value is the value of x918 concatenated on
          the right with the value of x928 and whose length is  the
          sum  of  the  lengths  of  x918 and x928.  For example, the
          value of 'AB' // 'CDE' is the string ABCDE.

          6.2.2  Form    and    Interpretation    of    Character
          Expressions.   A  character expression and the operands
          of a character expression must identify values of  type
          character.   Except in a character assignment statement
          (10.4),  a  character  expression  must   not   involve
          concatenation  of an operand whose length specification
          is  an  asterisk  in  parentheses  (8.4.2)  unless  the
          operand is the symbolic name of a constant.

          6.2.2.1  Character_Primaries.  The character  primaries
          are:

             (1) Character constant (4.8.1)

             (2) Symbolic name of a character constant (8.6)

             (3) Character variable reference (2.5)

             (4) Character array element reference (5.3)

             (5) Character substring reference (5.7)





          FORTRAN 77 Full Language                       Page 6-9







          EXPRESSIONS                              ANSI X3J3/90.4



             (6) Character function reference (15.2)

             (7) Character  expression  enclosed  in  parentheses
                 (6.2.2.2)

          6.2.2.2  Character_Expression.    The   forms   of    a
          character expression are:

             (1) Character primary

             (2) Character expression // character primary

          Thus, a character expression is a sequence  of  one  or
          more character primaries separated by the concatenation
          operator.  Form  (2)  indicates  that  in  a  character
          expression   containing   two   or  more  concatenation
          operators, the primaries  are  combined  from  left  to
          right   to   establish   the   interpretation   of  the
          expression.  For example, the formation  rules  specify
          that the interpretation of the character expression

                               'AB' // 'CD' // 'EF'

          is the same as  the  interpretation  of  the  character
          expression

                               ('AB' // 'CD') // 'EF'

          The value of the character expression in  this  example
          is  the  same  as  that of the constant 'ABCDEF'.  Note
          that parentheses have no  effect  on  the  value  of  a
          character expression.

          6.2.3  Character_Constant_Expression.    A    character
          constant  expression is a character expression in which
          each primary is a character constant, the symbolic name
          of  a  character  constant,  or  a  character  constant
          expression  enclosed   in   parentheses.    Note   that
          variable,   array   element,  substring,  and  function
          references are not allowed.

          6.3  Relational_Expressions

          A relational expression is used to compare  the  values
          of   two   arithmetic   expressions  or  two  character
          expressions.  A relational expression may not  be  used
          to  compare  the value of an arithmetic expression with
          the value of a character expression.

          Relational expressions may appear only  within  logical
          expressions.   Evaluation  of  a  relational expression



          FORTRAN 77 Full Language                      Page 6-10







          EXPRESSIONS                              ANSI X3J3/90.4



          produces a result of type logical, with a value of true
          or false.

          6.3.1  Relational_Operators.  The relational  operators
          are:

8                   _____________________________________

                    Operator   Representing
8                   _____________________________________

                      .LT.     Less than
                      .LE.     Less than or equal to
                      .EQ.     Equal to
                      .NE.     Not equal to
                      .GT.     Greater than
                      .GE.     Greater than or equal to
8                   _____________________________________
7                  |7|7|7|7|7|7|7|7|7|








                            |7|7|7|7|7|7|7|7|7|








                                                       |7|7|7|7|7|7|7|7|7|










          6.3.2  Arithmetic_Relational_Expression.  The  form  of
          an arithmetic relational expression is:

                               e_918 relop_____ e_92
9          where: e_918 and e_928 are  each  an  integer,  real,  double
                     precision, or complex expression

                 relop_____ is a relational operator

          A complex operand is permitted only when the relational
          operator is .EQ. or .NE.

          6.3.3  Interpretation    of    Arithmetic    Relational
          Expressions.   An  arithmetic  relational expression is
          interpreted as having the logical  value  true  if  the
          values  of  the operands satisfy the relation specified
          by the operator.  An arithmetic  relational  expression
          is interpreted as having the logical value false if the
          values of the operands  do  not  satisfy  the  relation
          specified by the operator.

          If the two  arithmetic  expressions  are  of  different
          types, the value of the relational expression

                               e_918 relop_____ e_92
9          is the value of the expression

                               ((e_918) - (e_928)) relop_____ 0

          where 0 (zero) is of the same type as the expression ((e
          _918) (e_928)), and relop_____ is the same relational operator in
          both expressions.  Note that the comparison of a double

9
          FORTRAN 77 Full Language                      Page 6-11







          EXPRESSIONS                              ANSI X3J3/90.4



          precision value and a complex value is not permitted.

          6.3.4  Character_Relational_Expression.  The form of  a
          character relational expression is:

                               e_918 relop_____ e_92
9          where: e_918 and e_928 are character expressions

                 relop_____ is a relational operator

          6.3.5  Interpretation    of    Character     Relational
          Expressions.   A  character  relational  expression  is
          interpreted as the logical value true if the values  of
          the  operands  satisfy  the  relation  specified by the
          operator.   A  character   relational   expression   is
          interpreted as the logical value false if the values of
          the operands do not satisfy the relation  specified  by
          the operator.

          The character expression e_918 is considered  to  be  less
          than  e_928 if the value of e_918 precedes the value of e_928 in
          the collating sequence; e_918 is greater than e_928  if  the
          value  of  e_918 follows the value of e_928 in the collating
          sequence (3.1.5).  Note  that  the  collating  sequence
          depends partially on the processor; however, the result
          of the use of the operators  .EQ.  and  .NE.  does  not
          depend  on the collating sequence.  If the operands are
          of unequal length, the shorter operand is considered as
          if  it  were  extended  on the right with blanks to the
          length of the longer operand.

          6.4  Logical_Expressions

          A logical expression  is  used  to  express  a  logical
          computation.    Evaluation   of  a  logical  expression
          produces a result of type logical, with a value of true
          or false.

          The simplest form of a logical expression is a  logical
          constant,  symbolic name of a logical constant, logical
          variable reference, logical  array  element  reference,
          logical  function  reference, or relational expression.
          More complicated logical expressions may be  formed  by
          using  one  or  more  logical  operands  together  with
          logical operators and parentheses.

          6.4.1  Logical_Operators.  The logical operators are:






          FORTRAN 77 Full Language                      Page 6-12







          EXPRESSIONS                              ANSI X3J3/90.4



8                __________________________________________

                 Operator   Representing
8                __________________________________________

                  .NOT.     Logical Negation
                  .AND.     Logical Conjunction
                   .OR.     Logical Inclusive Disjunction
                  .EQV.     Logical Equivalence
                  .NEQV.    Logical Nonequivalence
8                __________________________________________
7               |7|7|7|7|7|7|7|7|







                         |7|7|7|7|7|7|7|7|







                                                         |7|7|7|7|7|7|7|7|









          6.4.2  Form_and_Interpretation_of_Logical_Expressions.
          A  set  of  formation  rules  is  used to establish the
          interpretation of a logical  expression  that  contains
          two  or  more logical operators.  There is a precedence
          among the logical operators, which determines the order
          in  which  the  operands  are to be combined unless the
          order is  changed  by  the  use  of  parentheses.   The
          precedence of the logical operators is as follows:

8                      ______________________________

                          Operator       Precedence
8                      ______________________________

                            .NOT.        Highest
                            .AND.
                            .OR.
                       .EQV. or .NEQV.   Lowest
8                      ______________________________
7                     |7|7|7|7|7|7|7|






                                      |7|7|7|7|7|7|7|






                                                   |7|7|7|7|7|7|7|








          For example, in the expression

                               A .OR. B .AND. C

          the .AND.  operator  has  higher  precedence  than  the
          &amp;'.OR.   operator; therefore, the interpretation of the
          above expression is the same as the  interpretation  of
          the expression

                               A .OR. (B .AND. C)

          The logical operands are:

             (1) Logical primary

             (2) Logical factor

             (3) Logical term

             (4) Logical disjunct





          FORTRAN 77 Full Language                      Page 6-13







          EXPRESSIONS                              ANSI X3J3/90.4



             (5) Logical expression

          The formation rules to be applied in  establishing  the
          interpretation  of  a logical expression are in 6.4.2.1
          through 6.4.2.5.

          6.4.2.1  Logical_Primaries.  The logical primaries are:

             (1) Logical constant (4.7.1)

             (2) Symbolic name of a logical constant (8.6)

             (3) Logical variable reference (2.5)

             (4) Logical array element reference (5.3)

             (5) Logical function reference (15.2)

             (6) Relational expression (6.3)

             (7) Logical  expression  enclosed   in   parentheses
                 (6.4.2.5)

          6.4.2.2  Logical_Factor.  The forms of a logical factor
          are:

             (1) Logical primary

             (2) .NOT. logical primary

          6.4.2.3  Logical_Term.  The forms  of  a  logical  term
          are:

             (1) Logical factor

             (2) Logical term .AND. logical factor

          Thus, a logical term is a sequence of  logical  factors
          separated  by  the  .AND. operator.  Form (2) indicates
          that in interpreting a logical term containing  two  or
          more .AND.  operators, the logical factors are combined
          from left to right.

          6.4.2.4  Logical_Disjunct.   The  forms  of  a  logical
          disjunct are:

             (1) Logical term

             (2) Logical disjunct .OR. logical term





          FORTRAN 77 Full Language                      Page 6-14







          EXPRESSIONS                              ANSI X3J3/90.4



          Thus, a logical disjunct is a sequence of logical terms
          separated  by  the  .OR.  operator.  Form (2) indicates
          that in interpreting a logical disjunct containing  two
          or  more .OR. operators, the logical terms are combined
          from left to right.

          6.4.2.5  Logical_Expression.  The forms  of  a  logical
          expression are:

             (1) Logical disjunct

             (2) Logical expression .EQV. logical disjunct

             (3) Logical expression .NEQV. logical disjunct

          Thus, a logical expression is  a  sequence  of  logical
          disjuncts separated by either the .EQV. operator or the
          .NEQV. operator.  Forms (2) and (3)  indicate  that  in
          interpreting  a  logical  expression  containing two or
          more .EQV. or .NEQV. operators, the  logical  disjuncts
          are combined from left to right.

          6.4.3  Value of Logical Factors, Terms, Disjuncts,  and
          Expressions.   The  value of a logical factor involving
          .NOT. is shown below:

8                            __________________

                              x928     .NOT. x92
7                            __________________

                             true     false
                             false    true
8                            __________________
7                           |7|7|7|7|7|




                                  |7|7|7|7|7|




                                             |7|7|7|7|7|






          The value of a logical term involving  .AND.  is  shown
          below:

8                       _____________________________

                         x918      x928     x918 .AND. x92
7                       _____________________________

                        true    true       true
                        true    false      false
                        false   true       false
                        false   false      false
8                       _____________________________
7                      |7|7|7|7|7|7|7|






                             |7|7|7|7|7|7|7|






                                     |7|7|7|7|7|7|7|






                                                   |7|7|7|7|7|7|7|








          The value of a logical disjunct involving .OR. is shown
          below:






          FORTRAN 77 Full Language                      Page 6-15







          EXPRESSIONS                              ANSI X3J3/90.4



8                       ____________________________

                         x918      x928     x918 .OR. x92
7                       ____________________________

                        true    true      true
                        true    false     true
                        false   true      true
                        false   false     false
8                       ____________________________
7                      |7|7|7|7|7|7|7|






                             |7|7|7|7|7|7|7|






                                     |7|7|7|7|7|7|7|






                                                  |7|7|7|7|7|7|7|








          The value of a logical expression  involving  .EQV.  is
          shown below:

8                       _____________________________

                         x918      x928     x918 .EQV. x92
7                       _____________________________

                        true    true       true
                        true    false      false
                        false   true       false
                        false   false      true
8                       _____________________________
7                      |7|7|7|7|7|7|7|






                             |7|7|7|7|7|7|7|






                                     |7|7|7|7|7|7|7|






                                                   |7|7|7|7|7|7|7|








          The value of a logical expression involving  .NEQV.  is
          shown below:

8                      ______________________________

                        x918      x928     x918 .NEQV. x92
7                      ______________________________

                       true    true       false
                       true    false      true
                       false   true       true
                       false   false      false
8                      ______________________________
7                     |7|7|7|7|7|7|7|






                            |7|7|7|7|7|7|7|






                                    |7|7|7|7|7|7|7|






                                                   |7|7|7|7|7|7|7|








          6.4.4  Logical_Constant_Expression.  A logical constant
          expression  is  a  logical  expression  in  which  each
          primary is a logical constant, the symbolic name  of  a
          logical constant, a relational expression in which each
          primary is a constant expression, or a logical constant
          expression   enclosed   in   parentheses.    Note  that
          variable, array element, and  function  references  are
          not allowed.

          6.5  Precedence_of_Operators

          In 6.1.2 and 6.4.2 precedences  have  been  established
          among   the   arithmetic   operators  and  the  logical
          operators, respectively.  There is only  one  character
          operator.  No precedence has been established among the
          relational operators. The precedences among the various
          operators are:

9
          FORTRAN 77 Full Language                      Page 6-16







          EXPRESSIONS                              ANSI X3J3/90.4



8                         _________________________

                          Operator     Precedence
8                         _________________________

                          Arithmetic   Highest
                          Character
                          Relational
                          Logical      Lowest
8                         _________________________
7                        |7|7|7|7|7|7|7|






                                    |7|7|7|7|7|7|7|






                                                 |7|7|7|7|7|7|7|








          An  expression  may  contain  more  than  one  kind  of
          operator.  For example, the logical expression

                               L .OR. A + B .GE. C

          where A, B, and C are of type real, and L  is  of  type
          logical,  contains an arithmetic operator, a relational
          operator, and  a  logical  operator.   This  expression
          would be interpreted the same as the expression

                               L .OR. ((A + B) .GE. C)

          6.5.1  Summary_of_Interpretation_Rules.  The  order  in
          which   primaries   are  combined  using  operators  is
          determined by the following:

             (1) Use of parentheses

             (2) Precedence of the operators

             (3) Right-to-left interpretation of  exponentiations
                 in a factor

             (4) Left-to-right interpretation of  multiplications
                 and divisions in a term

             (5) Left-to-right interpretation  of  additions  and
                 subtractions in an arithmetic expression

             (6) Left-to-right interpretation  of  concatenations
                 in a character expression

             (7) Left-to-right interpretation of conjunctions  in
                 a logical term

             (8) Left-to-right interpretation of disjunctions  in
                 a logical disjunct

             (9) Left-to-right    interpretation    of    logical
                 equivalences in a logical expression

9


          FORTRAN 77 Full Language                      Page 6-17







          EXPRESSIONS                              ANSI X3J3/90.4



          6.6  Evaluation_of_Expressions

          This  section   applies   to   arithmetic,   character,
          relational, and logical expressions.

          Any variable, array  element,  function,  or  character
          substring  referenced  as  an  operand in an expression
          must be defined at the time the reference is  executed.
          An  integer  operand  must  be  defined with an integer
          value rather than a statement label value.   Note  that
          if  a  character string or substring is referenced, all
          of the referenced characters must  be  defined  at  the
          time the reference is executed.

          Any  arithmetic   operation   whose   result   is   not
          mathematically  defined  is prohibited in the execution
          of an executable program.   Examples  are  dividing  by
          zero  and  raising  a  zero-  valued primary to a zero-
          valued or negative-valued power.  Raising  a  negative-
          valued  primary  to a real or double precision power is
          also prohibited.

          The execution of a function reference  in  a  statement
          may  not alter the value of any other entity within the
          statement in which the function reference appears.  The
          execution  of  a  function reference in a statement may
          not alter the value of any entity in common (8.3)  that
          affects  the  value  of any other function reference in
          that  statement.   However,  execution  of  a  function
          reference in the expression e_ of a logical IF statement
          (11.5) is permitted to affect entities in the statement
          st__ that is executed when the value of the expression e_
          is true.  If a function reference causes definition  of
          an  actual  argument  of the function, that argument or
          any associated entities must not  appear  elsewhere  in
          the same statement. For example, the statements

                               A(I) = F(I)

                               Y = G(X) + X

          are prohibited if the reference to F defines I  or  the
          reference to G defines X.

          The data type of an  expression  in  which  a  function
          reference appears does not affect the evaluation of the
          actual arguments of the function.  The data type of  an
          expression in which a function reference appears is not
          affected by the evaluation of the actual  arguments  of
          the  function,  except  that  the  result  of a generic
          function reference assumes a data type that depends  on



          FORTRAN 77 Full Language                      Page 6-18







          EXPRESSIONS                              ANSI X3J3/90.4



          the data type of its arguments as specified in 15.10.

          Any execution of an array  element  reference  requires
          the  evaluation  of its subscript.  The data type of an
          expression  in  which  a  subscript  appears  does  not
          affect,  nor  is  it affected by, the evaluation of the
          subscript.

          Any execution of a  substring  reference  requires  the
          evaluation of its substring expressions.  The data type
          of an expression in which a substring name appears does
          not  affect,  nor  is it affected by, the evaluation of
          the substring expressions.

          6.6.1  Evaluation_of_Operands.  It is not necessary for
          a  processor  to  evaluate  all  of  the operands of an
          expression if  the  value  of  the  expression  can  be
          determined  otherwise.   This  principle  is most often
          applicable to logical express(ions, but it  applies  to
          all   expressions.   For  example,  in  evaluating  the
          logical expression

                               X .GT. Y .OR. L(Z)

          where X, Y,  and  Z  are  real,  and  L  is  a  logical
          function,  the  function  reference  L(Z)  need  not be
          evaluated if X is  greater  than  Y.   If  a  statement
          contains   a   function  reference  in  a  part  of  an
          expression that need not  be  evaluated,  all  entities
          that would have become defined in the execution of that
          reference  become  undefined  at  the   completion   of
          evaluation  of  the  expression containing the function
          reference.  In the example  above,  evaluation  of  the
          expression  causes  Z  to become undefined if L defines
          its argument.

          6.6.2  Order_of_Evaluation_of_Functions.      If      a
          statement  contains more than one function reference, a
          processor may evaluate  the  functions  in  any  order,
          except  for  a  logical  IF  statement  and  a function
          argument  list  containing  function  references.   For
          example, the statement

                               Y = F(G(X))

          where F and G are functions, requires G to be evaluated
          before F is evaluated.

          In a statement that contains  more  than  one  function
          reference,   the   value   provided  by  each  function
          reference must be independent of the  order  chosen  by



          FORTRAN 77 Full Language                      Page 6-19







          EXPRESSIONS                              ANSI X3J3/90.4



          the   processor   for   evaluation   of   the  function
          references.

          6.6.3  Integrity_of_Parentheses.   The  sections   that
          follow state certain conditions under which a processor
          may evaluate  an  expression  different  from  the  one
          obtained  by applying the interpretation rules given in
          6.1 through 6.5.  However, any expression contained  in
          parentheses must be treated as an entity.  For example,
          in evaluating the expression A*(B*C), the product of  B
          and  C  must be evaluated and then multiplied by A; the
          processor  must   not   evaluate   the   mathematically
          equivalent expression (A*B)*C.

          6.6.4  Evaluation_of_Arithmetic_Expressions.  The rules
          given   in  6.1.2  specify  the  interpretation  of  an
          arithmetic expression.   Once  the  interpretation  has
          been  established  in  accordance with those rules, the
          processor may evaluate  any  mathematically  equivalent
          expression,  provided that the integrity of parentheses
          is not violated.

          Two   arithmetic   expressions    are    mathematically
          equivalent   if,  for  all  possible  values  of  their
          primaries,  their  mathematical   values   are   equal.
          However,     mathematically    equivalent    arithmetic
          expressions   may   produce   different   computational
          results.

          The mathematical  definition  of  integer  division  is
          given  in  6.1.5.   The difference between the value of
          the  expression  5/2  and  5./2.  is   a   mathematical
          difference, not a computational difference.

          The following are examples of expressions,  along  with
          allowable  alternative  forms  that  may be used by the
          processor in the evaluation of those  expressions.   A,
          B, and C represent arbitrary real, double precision, or
          complex operands; I and J represent  arbitrary  integer
          operands;   and   X,   Y,  and  Z  represent  arbitrary
          arithmetic operands.   (Note  that  Table  2  prohibits
          combinations  of  double  precision  and  complex  data
          types.)











          FORTRAN 77 Full Language                      Page 6-20







          EXPRESSIONS                              ANSI X3J3/90.4



8                 _________________________________________

                  Expression   Allowable Alternative Form
8                 _________________________________________

                  X+Y          Y+X
                  X*Y          Y*X
                  -X+Y         Y-X
                  X+Y+Z        X+(Y+Z)
                  X-Y+Z        X-(Y-Z)
                  X*B/Z        X*(B/Z)
                  X*Y-X*Z      X*(Y-Z)
                  A/B/C        A/(B*C)
                  A/5.0        0.2*A
8                 _________________________________________
7                |7|7|7|7|7|7|7|7|7|7|7|7|











                            |7|7|7|7|7|7|7|7|7|7|7|7|











                                                         |7|7|7|7|7|7|7|7|7|7|7|7|













          The following are examples of  expressions  along  with
          forbidden  forms that must not be used by the processor
          in the evaluation of those expressions.

8                 ________________________________________

                  Expression    Nonallowable Alternative
                                          Form
8                 ________________________________________

                  I/2           0.5*I
                  X*I/J         X*(I/J)
                  I/J/A         I/(J*A)
                  (X*Y)-(X*Z)   X*(Y-Z)
                  X*(Y-Z)       X*Y-X*Z
8                 ________________________________________
7                |7|7|7|7|7|7|7|7|7|








                             |7|7|7|7|7|7|7|7|7|








                                                        |7|7|7|7|7|7|7|7|7|










          In addition to the parentheses  required  to  establish
          the desired interpretation, parentheses may be included
          to restrict the alternative forms that may be  used  by
          the   processor   in   the  actual  evaluation  of  the
          expression.   This  is  useful  for   controlling   the
          magnitude and accuracy of intermediate values developed
          during the evaluation of an expression.   For  example,
          in the expression

                               A+(B-C)

          the term (B-C) must be evaluated and then added  to  A.
          Note  that  the inclusion of parentheses may change the
          mathematical value of an expression.  For example,  the
          two expressions:

                               A*I/J

                               A*(I/J)

          may have different mathematical values if I and  J  are



          FORTRAN 77 Full Language                      Page 6-21







          EXPRESSIONS                              ANSI X3J3/90.4



          factors of integer data type.

          Each operand of an arithmetic operator has a data  type
          that  may depend on the order of evaluation used by the
          processor.  For  example,  in  the  evaluation  of  the
          expression

                               D+R+I

          where D, R, and I represent terms of double  precision,
          real,  and  integer  data  type, respectively, the data
          type of the operand that is added to I  may  be  either
          double  precision  or  real, depending on which pair of
          operands (D and R, R and I, or D and I) is added first.

          6.6.5  Evaluation_of_Character_Expressions.  The  rules
          given   in   6.2.2  specify  the  interpretation  of  a
          character expression as  a  string  of  characters.   A
          processor  needs  to  evaluate  only  as  much  of  the
          character expression as is required by the  context  in
          which   the   expression  appears.   For  example,  the
          statements

                     CHARACTER*2 C1,C2,C3,CF
                     C1 = C2 // CF(C3)

          do not require the function CF to be evaluated, because
          only  the  value of C2 is needed to determine the value
          of C1.

          6.6.6  Evaluation_of_Relational_Expressions.  The rules
          given  in 6.3.3 and 6.3.5 specify the interpretation of
          relational expressions.  Once the interpretation of  an
          expression  has  been  established  in  accordance with
          those rules,  the  processor  may  evaluate  any  other
          expression   that   is  relationally  equivalent.   For
          example, the  processor  may  choose  to  evaluate  the
          relational expression

                               I .GT. J

          where I and J are integer variables, as

                               J - I .LT. 0

          Two relational expressions are relationally  equivalent
          if  their  logical  values  are  equal for all possible
          values of their primaries.






          FORTRAN 77 Full Language                      Page 6-22







          EXPRESSIONS                              ANSI X3J3/90.4



          6.6.7  Evaluation_of_Logical_Expressions.   The   rules
          given  in 6.4.2 specify the interpretation of a logical
          expression.  Once the interpretation of  an  expression
          has  been  established  in accordance with those rules,
          the processor may evaluate any other expression that is
          logically  equivalent,  provided  that the integrity of
          parentheses  is  not  violated.    For   example,   the
          processor may choose to evaluate the logical expression

                               L1 .AND. L2 .AND. L3

          where L1, L2, and L3 are logical variables, as

                               L1 .AND. (L2 .AND. L3)

          Two logical expressions  are  logically  equivalent  if
          their values are equal for all possible values of their
          primaries.

          6.7  Constant_Expressions

          A  constant  expression  is  an   arithmetic   constant
          expression  (6.1.3),  a  character  constant expression
          (6.2.3), or a logical constant expression (6.4.4).






























          FORTRAN 77 Full Language                      Page 6-23











                                 CONTENTS


          6.  EXPRESSIONS..................................   6-1
              6.1  Arithmetic Expressions..................   6-1
                   6.1.1  Arithmetic Operators.............   6-1
                   6.1.2  Form and Interpretation of
                          Arithmetic Expressions...........   6-2
                   6.1.3  Arithmetic Constant
                          Expression.......................   6-5
                   6.1.4  Type and Interpretation of
                          Arithmetic Expressions...........   6-5
                   6.1.5  Integer Division.................   6-8
              6.2  Character Expressions...................   6-8
                   6.2.1  Character Operator...............   6-8
                   6.2.2  Form and Interpretation of
                          Character Expressions............   6-9
                   6.2.3  Character Constant
                          Expression.......................  6-10
              6.3  Relational Expressions..................  6-10
                   6.3.1  Relational Operators.............  6-11
                   6.3.2  Arithmetic Relational
                          Expression.......................  6-11
                   6.3.3  Interpretation of Arithmetic
                          Relational Expressions...........  6-11
                   6.3.4  Character Relational
                          Expression.......................  6-12
                   6.3.5  Interpretation of Character
                          Relational Expressions...........  6-12
              6.4  Logical Expressions.....................  6-12
                   6.4.1  Logical Operators................  6-12
                   6.4.2  Form and Interpretation of
                          Logical Expressions..............  6-13
                   6.4.3  Value of Logical Factors, Terms,
                          Disjuncts, and Expressions.......  6-
                          15
                   6.4.4  Logical Constant
                          Expression.......................  6-16
              6.5  Precedence of Operators.................  6-16
                   6.5.1  Summary of Interpretation
                          Rules............................  6-17
              6.6  Evaluation of Expressions...............  6-18
                   6.6.1  Evaluation of Operands...........  6-19
                   6.6.2  Order of Evaluation of
                          Functions........................  6-19
                   6.6.3  Integrity of Parentheses.........  6-20
                   6.6.4  Evaluation of Arithmetic
                          Expressions......................  6-20
                   6.6.5  Evaluation of Character
                          Expressions......................  6-22




                                   - i -











                   6.6.6  Evaluation of Relational
                          Expressions......................  6-22
                   6.6.7  Evaluation of Logical
                          Expressions......................  6-23
              6.7  Constant Expressions....................  6-23

















































                                  - ii -







                                                   ANSI X3J3/90.4



          7.  EXECUTABLE AND NONEXECUTABLE STATEMENT CLASSIFICATION

          Each  statement  is   classified   as   executable   or
          nonexecutable.   Executable  statements specify actions
          and  form  an  execution  sequence  in  an   executable
          program.       Nonexecutable     statements     specify
          characteristics, arrangement,  and  initial  values  of
          data;  contain  editing  information; specify statement
          functions; classify program units;  and  specify  entry
          points  within  subprograms.   Nonexecutable statements
          are not part of the execution  sequence.  Nonexecutable
          statements  may  be  labeled, but such statement labels
          must not be used to control the execution sequence.

          7.1  Executable_Statements

          The following statements are classified as executable:

             (1) Arithmetic, logical, statement  label  (ASSIGN),
                 and character  assignment statements

             (2) Unconditional  GO  TO,  assigned  GO   TO,   and
                 computed GO TO statements

             (3) Arithmetic IF and logical IF statements

             (4) Block IF, ELSE IF, ELSE, and END IF statements

             (5) CONTINUE statement

             (6) STOP and PAUSE statements

             (7) DO statement

             (8) READ, WRITE, and PRINT statements

             (9) REWIND, BACKSPACE,  ENDFILE,  OPEN,  CLOSE,  and
                 INQUIRE statements

            (10) CALL and RETURN statements

            (11) END statement

          7.2  Nonexecutable_Statements

          The   following   statements    are    classified    as
          nonexecutable:

             (1) PROGRAM, FUNCTION, SUBROUTINE, ENTRY, and  BLOCK
                 DATA statements




          FORTRAN 77 Full Language                       Page 7-1







          STATEMENT CLASSIFICATION                 ANSI X3J3/90.4



             (2) DIMENSION,   COMMON,   EQUIVALENCE,    IMPLICIT,
                 PARAMETER,   EXTERNAL,   INTRINSIC,   and   SAVE
                 statements

             (3) INTEGER,  REAL,   DOUBLE   PRECISION,   COMPLEX,
                 LOGICAL, and CHARACTER type-statements

             (4) DATA statement

             (5) FORMAT statement

             (6) Statement function statement










































          FORTRAN 77 Full Language                       Page 7-2











                                 CONTENTS


          7.  EXECUTABLE AND NONEXECUTABLE STATEMENT CLASSIFICATION  7-
              1
              7.1  Executable Statements....................  7-1
              7.2  Nonexecutable Statements.................  7-1















































                                   - i -







                                                   ANSI X3J3/90.4



                       8.  SPECIFICATION_STATEMENTS

          There are nine kinds of specification statements:

             (1) DIMENSION

             (2) EQUIVALENCE

             (3) COMMON

             (4) INTEGER,  REAL,   DOUBLE   PRECISION,   COMPLEX,
                 LOGICAL, and CHARACTER type-statements

             (5) IMPLICIT

             (6) PARAMETER

             (7) EXTERNAL

             (8) INTRINSIC

             (9) SAVE

          All specification statements are nonexecutable.

          8.1  DIMENSION_Statement

          A DIMENSION statement is used to specify  the  symbolic
          names and dimension specifications of arrays.

          The form of a DIMENSION statement is:

                               DIMENSION a_(d_) [,a_(d_)]...

          where each a_(d_) is an array declarator (5.1).

          Each symbolic name a_ appearing in a DIMENSION statement
          declares  a_ to be an array in that program unit.  Note
          that  array  declarators  may  also  appear  in  COMMON
          statements and type-statements.  Only one appearance of
          a symbolic name as an array name in an array declarator
          in a program unit is permitted.

          8.2  EQUIVALENCE_Statement

          An EQUIVALENCE statement is used to specify the sharing
          of  storage  units by two or more entities in a program
          unit.  This causes association  of  the  entities  that
          share the storage units.





          FORTRAN 77 Full Language                       Page 8-1







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



          If the equivalenced  entities  are  of  different  data
          types,  the  EQUIVALENCE  statement does not cause type
          conversion or imply  mathematical  equivalence.   If  a
          variable  and  an  array are equivalenced, the variable
          does not have array properties and the array  does  not
          have the properties of a variable.

          8.2.1  Form_of_an_EQUIVALENCE_Statement.  The  form  of
          an EQUIVALENCE statement is:

                               EQUIVALENCE (nlist_____) [,(nlist_____)]...

          where each nlist_____ is a list (2.10)  of  variable  names,
          array   element   names,  array  names,  and  character
          substring names.  Each list must contain at  least  two
          names.    Names  of  dummy  arguments  of  an  external
          procedure in a subprogram must not appear in the  list.
          If  a  variable  name is also a function name (15.5.1),
          that name must not appear in the list.

          Each subscript expression or substring expression in  a
          list nlist_____ must be an integer constant expression.

          8.2.2  Equivalence_Association.      An     EQUIVALENCE
          statement  specifies  that the storage sequences of the
          entities whose names appear in a list nlist____ _  have  the
          same  first  storage unit.  This causes the association
          of the entities in the list nlist_ _ _ _ _  and  may  cause
          association of other entities (17.1).

          8.2.3  Equivalence_of_Character_Entities.  An entity of
          type  character  may  be  equivalenced  only with other
          entities  of  type  character.  The  lengths   of   the
          equivalenced entities are not required to be the same.

          An EQUIVALENCE statement  specifies  that  the  storage
          sequences  of the character entities whose names appear
          in a list nlist_____ have the same first  character  storage
          unit.   This  causes the association of the entities in
          the list nlist_____  and  may  cause  association  of  other
          entities   (17.1).   Any  adjacent  characters  in  the
          associated entities may also have  the  same  character
          storage  unit  and thus may also be associated.  In the
          example:

                     CHARACTER A*4, B*4, C(2)*3
                     EQUIVALENCE (A,C(1)), (B,C(2))

          the association of A,  B,  and  C  can  be  graphically
          illustrated as:




          FORTRAN 77 Full Language                       Page 8-2







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



                   | 01|  02|  03|  04
7                                      |  05|  06|  07|

                   | --------A--------|
                                    --------B--------|
                     ----C(1)----   ----C(2)----
7                   |
7                                 |8|
8                                                |

          8.2.4  Array_Names_and_Array_Element_Names.    If    an
          array element name appears in an EQUIVALENCE statement,
          the number of subscript expressions must be the same as
          the   number  of  dimensions  specified  in  the  array
          declarator for the array name.

          The use of an array name unqualified by a subscript  in
          an  EQUIVALENCE  statement has the same effect as using
          an array element name that identifies the first element
          of the array.

          8.2.5  Restrictions_on_EQUIVALENCE_Statements.       An
          EQUIVALENCE  statement  must  not specify that the same
          storage unit is to occur more than once  in  a  storage
          sequence.  For example,

                     DIMENSION A(2)
                     EQUIVALENCE (A(1),B), (A(2),B)

          is  prohibited,  because  it  would  specify  the  same
          storage   unit  for  A(1)  and  A(2).   An  EQUIVALENCE
          statement must not  specify  that  consecutive  storage
          units  are  to  be  nonconsecutive.   For  example, the
          following is prohibited:

                     REAL A(2)
                     DOUBLE PRECISION D(2)
                     EQUIVALENCE (A(1),D(1)), (A(2),D(2))

          8.3  COMMON_Statement

          The COMMON statement provides a  means  of  associating
          entities  in  different  program  units.   This  allows
          different program units to  define  and  reference  the
          same data without using arguments, and to share storage
          units.

          8.3.1  Form_of_a_COMMON_Statement.   The  form   of   a
          COMMON statement is:

                               COMMON [/[cb__]/] nlist_____ [[,]/[cb__]/ nlist_____]...

          where: cb__  is a common block name (18.2.1)





          FORTRAN 77 Full Language                       Page 8-3







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



                 nlist_____ is a list (2.10) of variable names,  array
                     names,  and  array  declarators.   Only  one
                     appearance of a symbolic name as a  variable
                     name,  array  name,  or  array declarator is
                     permitted in all such lists within a program
                     unit.    Names  of  dummy  arguments  of  an
                     external procedure in a subprogram must  not
                     appear  in  the list.  If a variable name is
                     also a function  name  (15.5.1),  that  name
                     must not appear in the list.

          Each omitted cb__ specifies the blank common  block.   If
          the  first  cb_ _  is omitted, the first two slashes are
          optional.

          In each COMMON  statement,  the  entities  whose  names
          appear  in  an  nlist_ _ _ __ following a block name cb__ are
          declared to be in common block cb__.  If the first cb__  is
          omitted, all entities whose names appear in the first nlist_
          _ _ _ _  are  specified  to   be   in   blank   common.
          Alternatively,  the  appearance  of two slashes with no
          block name between them  declares  the  entities  whose
          names  appear  in  the list nlist_____ that follows to be in
          blank common.

          Any common block name cb__ or an omitted cb_ _  for  blank
          common  may  occur more than once in one or more COMMON
          statements in a program unit.  The list nlist_____ following
          each  successive  appearance  of  the same common block
          name is treated as a continuation of the list for  that
          common block name.

          If a character variable or  character  array  is  in  a
          common  block, all of the entities in that common block
          must be of type character.

          8.3.2  Common_Block_Storage_Sequence.  For each  common
          block,  a  common  block  storage sequence is formed as
          follows:

             (1) A storage sequence is formed consisting  of  the
                 storage sequences of all entities in the lists nlist_
                 ____Z for the common block.  The  order  of  the
                 storage sequence is the same as the order of the
                 appearance of the lists nlist____ _  in  the  program
                 unit.

             (2) The storage sequence formed in (1)  is  extended
                 to  include  all  storage  units  of any storage
                 sequence  associated  with  it  by   equivalence
                 association.   The sequence may be extended only



          FORTRAN 77 Full Language                       Page 8-4







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



                 by adding storage units beyond the last  storage
                 unit.   Entities  associated with an entity in a
                 common block are considered to be in that common
                 block.

          8.3.3  Size_of_a_Common_Block.  The size  of  a  common
          block is the size of its common block storage sequence,
          including any extensions of the sequence resulting from
          equivalence association.

          Within an executable program, all named  common  blocks
          that  have  the same name must be the same size.  Blank
          common blocks within  an  executable  program  are  not
          required to be the same size.

          8.3.4  Common_Association.    Within   an    executable
          program,  the  common  block  storage  sequences of all
          common blocks with the same name have  the  same  first
          storage unit.  Within an executable program, the common
          block storage sequences of all blank common blocks have
          the  same  first  storage  unit.   This  results in the
          association (17.1) of  entities  in  different  program
          units.

          8.3.5  Differences  between  Named  Common  and   Blank
          Common.   A  blank common block has the same properties
          as a named common block, except for the following:

             (1) Execution of a RETURN or END statement sometimes
                 causes entities in named common blocks to become
                 undefined but never  causes  entities  in  blank
                 common to become undefined (15.8.4).

             (2) Named common blocks of the same name must be  of
                 the  same  size  in  all  program  units  of  an
                 executable program in  which  they  appear,  but
                 blank common blocks may be of different sizes.

             (3) Entities in named common blocks may be initially
                 defined  by means of a DATA statement in a block
                 data subprogram, but entities  in  blank  common
                 must not be initially defined (Section 9).

          8.3.6  Restrictions_on_Common_and_Equivalence.       An
          EQUIVALENCE   statement  must  not  cause  the  storage
          sequences of two different common blocks  in  the  same
          program unit to be associated.  Equivalence association
          must not cause a common block storage  sequence  to  be
          extended  by  adding  storage units preceding the first
          storage unit of the first entity specified in a  COMMON
          statement  for  the  common  block.   For  example, the



          FORTRAN 77 Full Language                       Page 8-5







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



          following is not permitted:

                     COMMON /X/A
                     REAL B(2)
                     EQUIVALENCE (A,B(2))

          8.4  Type-Statements

          A  type-statement  is  used  to  override  or   confirm
          implicit typing and may specify dimension information.

          The appearance of the  symbolic  name  of  a  constant,
          variable,   array,   external  function,  or  statement
          function in a type-statement specifies  the  data  type
          for  that name for all appearances in the program unit.
          Within a program unit, a name must not  have  its  type
          explicitly specified more than once.

          A type-statement that confirms the type of an intrinsic
          function whose name appears in the Specific Name column
          of Table 5 is not required,  but is  permitted.   If  a
          generic function name appears in a type-statement, such
          an appearance is not sufficient by itself to remove the
          generic properties from that function.

          The name of a main program, subroutine, or  block  data
          subprogram must not appear in a type-statement.

          8.4.1  INTEGER, REAL, DOUBLE  PRECISION,  COMPLEX,  and
          LOGICAL  Type-Statements.   An  INTEGER,  REAL,  DOUBLE
          PRECISION, COMPLEX, or LOGICAL type-statement is of the
          form:

                               typ___ v_[,v_]...

          where: typ___ is one of INTEGER, REAL,  DOUBLE  PRECISION,
                     COMPLEX, or LOGICAL

                 v_    is  a  variable  name,  array  name,  array
                     declarator,  symbolic  name  of  a constant,
                     function  name,  or  dummy  procedure   name
                     (18.2.11)

          8.4.2  CHARACTER_Type-Statement.    The   form   of   a
          CHARACTER type-statement is:

                               CHARACTER [*len___ [,]] nam___ [,nam___]...

          where: nam___ is of one of the forms:





          FORTRAN 77 Full Language                       Page 8-6







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



                     v_ [*len___]

                     a_ [(d_)] [*len___]

                 v_   is a  variable  name,  symbolic  name  of  a
                     constant,  function name, or dummy procedure
                     name

                 a_   is an array name

                 a_(d_) is an array declarator

                 len___ is the length (number of  characters)  of  a
                     character variable, character array element,
                     character constant that has a symbolic name,
                     or character function, and is called the length specification___
                     _________________.  len_ _ _  is  one  of  the
                     following:

                     (1) An unsigned, nonzero, integer constant

                     (2) An integer constant expression (6.1.3.1)
                         enclosed   in  parentheses  and  with  a
                         positive value

                     (3) An asterisk in parentheses, (*)

          A length len___ immediately following the  word  CHARACTER
          is  the  length  specification  for  each entity in the
          statement not having its own length  specification.   A
          length specification immediately following an entity is
          the length specification for only  that  entity.   Note
          that  for  an  array  the  length specified is for each
          array element.  If a length is  not  specified  for  an
          entity, its length is one.

          An entity declared in a CHARACTER statement must have a
          length   specification  that  is  an  integer  constant
          expression, unless that entity is an external function,
          a  dummy  argument  of  an  external  procedure,  or  a
          character constant that has a symbolic name.

          If a dummy argument has a len__ _  of  (*)  declared,  the
          dummy  argument  assumes  the  length of the associated
          actual argument for each reference of the subroutine or
          function.   If  the  associated  actual  argument is an
          array name, the length assumed by the dummy argument is
          the length of an array element in the associated actual
          argument array.





          FORTRAN 77 Full Language                       Page 8-7







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



          If an external function has a len___ of (*) declared in  a
          function  subprogram,  the function name must appear as
          the name of a function in a FUNCTION or ENTRY statement
          in  the  same  subprogram.   When a reference to such a
          function is executed, the function assumes  the  length
          specified in the referencing program unit.

          The length specified for a character  function  in  the
          program  unit  that  references the function must be an
          integer constant expression and  must  agree  with  the
          length  specified  in the subprogram that specifies the
          function.  Note  that  there  always  is  agreement  of
          length  if  a len___ of (*) is specified in the subprogram
          that specifies the function.

          If a character constant that has a symbolic name has a len
          ___ of (*) declared, the constant assumes the length of
          its corresponding constant expression  in  a  PARAMETER
          statement.

          The length specified for a character statement function
          or  statement function dummy argument of type character
          must be an integer constant expression.

          8.5  IMPLICIT_Statement

          An IMPLICIT statement is used to change or confirm  the
          default implied integer and real typing.

          The form of an IMPLICIT statement is:

                        IMPLICIT typ___ (a_ [,a_]...) [,typ___ (a_ [,a_]...)]...

          where: typ___ is one of INTEGER, REAL,  DOUBLE  PRECISION,
                     COMPLEX, LOGICAL, or CHARACTER [*len___]

                 a_   is either a single  letter  or  a  range  of
                     single  letters  in  alphabetical  order.  A
                     range is  denoted  by  the  first  and  last
                     letter  of  the  range separated by a minus.
                     Writing a range of letters a_918 - a_928  has  the
                     same  effect as writing a list of the single
                     letters a_918 through a_928.

                 len___ is the length of the character entities  and
                     is one of the following:

                     (1) An unsigned, nonzero, integer constant

                     (2) An  integer  constant  expression   (6..
                         1.3.1)  enclosed in parentheses and with



          FORTRAN 77 Full Language                       Page 8-8







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



                         a positive value

                     If len___ is not specified, the length is one.

          An  IMPLICIT  statement  specifies  a  type   for   all
          variables,   arrays,   symbolic   names  of  constants,
          external  functions,  and  statement^   functions  that
          begin   with   any   letter   that   appears   in   the
          specification, either as a single letter or included in
          a  range of letters.  IMPLICIT statements do not change
          the type  of  any  intrinsic  functions.   An  IMPLICIT
          statement   applies  only  to  the  program  unit  that
          contains it.

          Type  specification by an  IMPLICIT  statement  may  be
          overridden  or  confirmed  for any particular variable,
          array, symbolic name of a constant, external  function,
          or  statement  function  name by the appearance of that
          name   in   a   type-statement.    An   explicit   type
          specification  in  a  FUNCTION  statement  overrides an
          IMPLICIT  statement  for  the  name  of  that  function
          subprogram.   Note  that  the length is also overridden
          when a  particular  name  appears  in  a  CHARACTER  or
          CHARACTER FUNCTION statement.

          Within the specification statements of a program  unit,
          IMPLICIT    statements    must    precede   all   other
          specification statements except  PARAMETER  statements.
          A  program  unit  may  contain  more  than one IMPLICIT
          statement.

          The same letter must not appear as a single letter,  or
          be  included  in  a range of letters, more than once in
          all of the IMPLICIT statements in a program unit.

          8.6  PARAMETER_Statement

          The PARAMETER statement is used to give  a  constant  a
          symbolic name.

          The form of a PARAMETER statement is:

                               PARAMETER (p_=e_ [,p_=e_]...)

          where: p_   is a symbolic name

                 e_   is a constant expression (6.7)

          If the symbolic name p_ is of type integer, real, double
          precision,  or  complex, the corresponding expression e_
          must be an arithmetic constant expression (6.1.3).   If



          FORTRAN 77 Full Language                       Page 8-9







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



          the  symbolic  name  p_ is of type character or logical,
          the corresponding expression e_  must  be  a  character
          constant  expression  (6.2.3)  or  a  logical  constant
          expression (6.4.4), respectively.

          Each p_ is the symbolic name of a constant that  becomes
          defined with the value determined from the expression e_
          that appears on the right of the equals, in  accordance
          with  the  rules for assignment statements (10.1, 10.2,
          and 10.4).

          Any symbolic name of a  constant  that  appears  in  an
          expression  e_ must have been defined previously in the
          same or a different PARAMETER  statement  in  the  same
          program unit.

          A symbolic name of a constant must not  become  defined
          more than once in a program unit.

          If a symbolic name of a  constant  is  not  of  default
          implied  type,  its  type  must be specified by a type-
          statement or IMPLICIT  statement  prior  to  its  first
          appearance  in  a  PARAMETER  statement.  If the length
          specified for the symbolic name of a constant  of  type
          character  is not the default length of one, its length
          must be  specified  in  a  type-statement  or  IMPLICIT
          statement prior to the first appearance of the symbolic
          name of the constant.  Its length must not  be  changed
          by subsequent statements including IMPLICIT statements.

          Once such a symbolic name is  defined,  that  name  may
          appear in that program unit in any subsequent statement
          as a primary in an expression or in  a  DATA  statement
          (9.1).   A symbolic name of a constant must not be part
          of a  format  specification.   A  symbolic  name  of  a
          constant  must  not  be  used  to  form part of another
          constant, for example, any part of a complex constant.

          A symbolic name in a PARAMETER statement  may  identify
          only the corresponding constant in that program unit.

          8.7  EXTERNAL_Statement

          An EXTERNAL statement is used to  identify  a  symbolic
          name  as  representing  an  external procedure or dummy
          procedure, and to permit such a name to be used  as  an
          actual argument.

          The form of an EXTERNAL statement is:





          FORTRAN 77 Full Language                      Page 8-10







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



                               EXTERNAL proc____ [,proc____]...

          where each proc____ is the name of an  external  procedure,
          dummy  procedure, or block data subprogram.  Appearance
          of a name in an EXTERNAL statement declares  that  name
          to  be  an  external  procedure name or dummy procedure
          name, or block data subprogram name.   If  an  external
          procedure  na`)me  or a dummy procedure name is used as
          an actual argument in a program unit, it must appear in
          an  EXTERNAL statement in that program unit.  Note that
          a  statement  function  name  must  not  appear  in  an
          EXTERNAL statement.

          If an intrinsic function name appears  in  an  EXTERNAL
          statement in a program unit, that name becomes the name
          of some external procedure and an intrinsic function of
          the  same  name  is  not available for reference in the
          program unit.

          Only one appearance of a symbolic name in  all  of  the
          EXTERNAL statements of a program unit is permitted.

          8.8  INTRINSIC_Statement

          An INTRINSIC statement is used to identify  a  symbolic
          name  as representing an intrinsic function (15.3).  It
          also  permits  a  name  that  represents   a   specific
          intrinsic function to be used as an actual argument.

          The form of an INTRINSIC statement is:

                               INTRINSIC fun___ [,fun___]...

          where each fun___ is an intrinsic function name.

          Appearance of a name in an INTRINSIC statement declares
          that  name  to  be  an  intrinsic  function name.  If a
          specific name of an intrinsic function is  used  as  an
          actual argument in a program unit, it must appear in an
          INTRINSIC statement in that program unit.  The names of
          intrinsic  functions  for  type  conversion (INT, IFIX,
          IDINT, FLOAT, SNGL, REAL, DBLE,  CMPLX,  ICHAR,  CHAR),
          lexical  relationship  (LGE,  LGT,  LLE,  LLT), and for
          choosing the largest  or  smallest  value  (MAX,  MAX0,
          AMAX1,  DMAX1,  AMAX0,  MAX1,  MIN, MIN0, AMIN1, DMIN1,
          AMIN0, MIN1) must not be used as actual arguments.

          The  appearance  of  a  generic  function  name  in  an
          INTRINSIC  statement  does  not cause that name to lose
          its generic property.




          FORTRAN 77 Full Language                      Page 8-11







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



          Only one appearance of a symbolic name in  all  of  the
          INTRINSIC  statements  of  a program unit is permitted.
          Note that a symbolic name must not appear  in  both  an
          EXTERNAL and an INTRINSIC statement in a program unit.

          8.9  SAVE_Statement

          A SAVE statement  is  used  to  retain  the  definition
          status  of an entity after the execution of a RETURN or
          END statement in a subprogram.  Within  a  function  or
          subroutine  subprogram,  an  entity specified by a SAVE
          statement does not become undefined as a result of  the
          execution   of   a  RETURN  or  END  statement  in  the
          subprogram.  However, such an entity in a common  block
          may  become  undefined  or redefined in another program
          unit.

          The form of a SAVE statement is:

                               SAVE [a_ [,a_]...]

          where each a_ is a named common block name preceded  and
          followed by a slash, a variable name, or an array name.
          Redundant appearances of an item are not permitted.

          Dummy argument names, procedure  names,  and  names  of
          entities  in  a  common block must not appear in a SAVE
          statement.

          A SAVE statement without a list is treated as though it
          contained  the  names  of  all  allowable  items in the
          program unit.

          The appearance of a  common  block  name  preceded  and
          followed  by a slash in a SAVE statement has the effect
          of specifying all of the entities in that common block.

          If a particular common block name  is  specified  by  a
          SAVE   statement  in  a  subprogram  of  an  executable
          program, it must be specified by a  SAVE  statement  in
          every subprogram in which that common block appears.

          A SAVE statement is optional in a main program and  has
          no effect.

          If  a  named  common  block  is  specified  in  a  SAVE
          statement  in  a  subprogram, the current values of the
          entities in the common block storage  sequence  (8.3.3)
          at  the  time a RETURN or END statement is executed are
          made available to the next program unit that  specifies
          that  common block name in the execution sequence of an



          FORTRAN 77 Full Language                      Page 8-12







          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4



          executable program.

          If a named  common  block  is  specified  in  the  main
          program  unit,  the  current values of the common block
          storage sequence are made available to each  subprogram
          that   specifies   that  named  common  block;  a  SAVE
          statement in the subprogram has no effect.

          The definition status  of  each  entity  in  the  named
          common   block   storage   sequence   depends   on  the
          association that has been established  for  the  common
          block storage sequence (17.2 and 17.3).

          If a local entity that is specified by a SAVE statement
          and  is  not in a common block is in a defined state at
          the time a RETURN or END statement  is  executed  in  a
          subprogram,  that entity is defined with the same value
          at the next reference of that subprogram.

          The execution of a RETURN statement or an END statement
          within  a  subprogram  causes  all  entities within the
          subprogram  to  become   undefined   except   for   the
          following:

             (1) Entities specified by SAVE statements

             (2) Entities in blank common

             (3) Initially defined  entities  that  have  neither
                 been redefined nor become undefined

             (4) Entities in a named common block that appears in
                 the subprogram and appears in at least one other
                 program  unit  that   is   referencing,   either
                 directly or indirectly, that subprogram



















          FORTRAN 77 Full Language                      Page 8-13











                                 CONTENTS


          8.  SPECIFICATION STATEMENTS.....................   8-1
              8.1  DIMENSION Statement.....................   8-1
              8.2  EQUIVALENCE Statement...................   8-1
                   8.2.1  Form of an EQUIVALENCE
                          Statement........................   8-2
                   8.2.2  Equivalence Association..........   8-2
                   8.2.3  Equivalence of Character
                          Entities.........................   8-2
                   8.2.4  Array Names and Array Element
                          Names............................   8-3
                   8.2.5  Restrictions on EQUIVALENCE
                          Statements.......................   8-3
              8.3  COMMON Statement........................   8-3
                   8.3.1  Form of a COMMON
                          Statement........................   8-3
                   8.3.2  Common Block Storage
                          Sequence.........................   8-4
                   8.3.3  Size of a Common Block...........   8-5
                   8.3.4  Common Association...............   8-5
                   8.3.5  Differences between Named Common
                          and Blank Common.................   8-5
                   8.3.6  Restrictions on Common and
                          Equivalence......................   8-5
              8.4  Type-Statements.........................   8-6
                   8.4.1  INTEGER, REAL, DOUBLE PRECISION,
                          COMPLEX, and LOGICAL Type-
                          Statements.......................   8-6
                   8.4.2  CHARACTER Type-Statement.........   8-6
              8.5  IMPLICIT Statement......................   8-8
              8.6  PARAMETER Statement.....................   8-9
              8.7  EXTERNAL Statement......................  8-10
              8.8  INTRINSIC Statement.....................  8-11
              8.9  SAVE Statement..........................  8-12


















                                   - i -







                                                   ANSI X3J3/90.4



                            9.  DATA_STATEMENT

          A DATA statement is used to provide initial values  for
          variables,  arrays,  array elements, and substrings.  A
          DATA statement is nonexecutable and  may  appear  in  a
          program   unit   anywhere   after   the   specification
          statements, if any.

          All  initially  defined  entities are defined  when  an
          executable program begins execution.  All entities  not
          initially defined,  or  associated  with  an  initially
          defined  entity,   are  undefined  at  the beginning of
          execution of an executable program.

          9.1  Form_of_a_DATA_Statement

          The form of a DATA statement is:

                               DATA nlist_____ /clist_____/ [[,] nlist_____ /clist_____/]...

          where: nlist_____ is a list (2.10) of variable names,  array
                     names, array element names, substring names,
                     and implied-DO lists

                 clist_____ is a list of the form:

                     a_ [,a_]...

                 where a_ is one of the forms:

                         c_
                         r_*c_

                     c_   is a constant or the symbolic name of  a
                         constant

                     r_   is a nonzero, unsigned, integer constant
                         or the symbolic name of such a constant.
                         The r_ *c_  form  is  equivalent  to  r_
                         successive appearances of the constant c_
                         .

          9.2  DATA_Statement_Restrictions

          Names of dummy arguments, functions,  and  entities  in
          blank  common  (including  entities  associated with an
          entity in blank common) must not appear in the list nlist___
          _ _ .   Names  of  entities in a named common block may
          appear in the list nlist____ _  only  within  a  block  data
          subprogram.




          FORTRAN 77 Full Language                       Page 9-1







          DATA STATEMENT                           ANSI X3J3/90.4



          There must be the same number  of  items  specified  by
          each  list  nlist_ _ _ __ and its corresponding list clist_____.
          There is a one-to-one correspondence between the  items
          specified by nlist_____ and the constants specified by clist_____
          such that the first item of nlist_____  corresponds  to  the
          first  constant of clist_____, etc.  By this correspondence,
          the initial value is  established  and  the  entity  is
          initially   defined.    If  an  array  name  without  a
          subscript is in the list, there must  be  one  constant
          for  each element of that array.  The ordering of array
          elements is determined by the array  element  subscript
          value (5.2.4).

          The type of the nlist____ _  entity  and  the  type  of  the
          corresponding  clist_____ constant must agree when either is
          of type character or logical.  When the nlist_____ entity is
          of  type  integer, real, double  precision, or complex,
          the 1corresponding clist_____ constant must also be of  type
          integer,   real,   double  precision,  or  complex;  if
          necessary, the clist_____ constant is converted to the  type
          of  the  nlist_ _ _ _ _  entity  according to the rules for
          arithmetic conversion (Table 4).  Note that if an nlist_____
          entity  is  of  type  double  precision  and  the clist_____
          constant is of type real, the processor may supply more
          precision   derived  from  the  constant  than  can  be
          contained in a real datum.

          Any  variable,  array  element,  or  substring  may  be
          initially defined except for:

             (1) an entity that is a dummy argument,

             (2) an entity in blank  common,  which  includes  an
                 entity   associated  with  an  entity  in  blank
                 common, or

             (3) a variable in a function subprogram  whose  name
                 is  also  the name of the function subprogram or
                 an entry in the function subprogram.

          A variable, array element, or  substring  must  not  be
          initially  defined  more  than  once  in  an executable
          program.  If two entities are associated, only one  may
          be  initially  defined  in a DATA statement in the same
          executable program.

          Each subscript expression in the list nlist_____ must be  an
          integer  constant  expression  except  for  implied-DO-
          variables as noted in 9.3.  Each  substring  expression
          in  the  list  nlist_ _ _ _ _  must  be an integer constant
          expression.



          FORTRAN 77 Full Language                       Page 9-2







          DATA STATEMENT                           ANSI X3J3/90.4



          9.3  Implied-DO_in_a_DATA_Statement

          The form of an implied-DO list in a DATA statement is:

                               ( dlist_____, i_ = m_918,  m_928 [,m_938 ] )

          where: dlist_____ is a  list  of  array  element  names  and
                     implied-DO lists

                 i_   is the name of an integer  variable,  called
                     the implied_______-DO__-variable________

                 m_91,8 m_92,8 m_938 are  each  an   integer   constant
                     expression,  except  that the expression may
                     contain  implied-  DO-variables   of   other
                     implied-DO  lists  that have this implied-DO
                     list within their ranges

          The range of an implied-DO list is the list dlist_____.   An
          iteration  count  and  the  values  of  the implied-DO-
          variable are established from m_918, m_928, and m_938 exactly as
          for  a DO-loop (11.10), except that the iteration count
          must be positive.  When an implied-DO list appears in a
          DATA  statement,  the list items in dlist_____ are specified
          once for each iteration of the implied-DO list with the
          appropriate  substitution  of values for any occurrence
          of the implied-DO-variable i_.   The  appearance  of  an
          implied-DO-variable  name  in a DATA statement does not
          affect the definition status of a variable of the  same
          name in the same program unit.

          Each subscript expression in the list dlist_____ must be  an
          integer constant expression, except that the expression
          may contain implied-DO-variables  of  implied-DO  lists
          that have the subscript expression within their ranges.

          The following is an example of a  DATA  statement  that
          contains implied-DO lists:

                               DATA (( X(J,I), I=1,J), J=1,5) / 15*0. /

          9.4  Character_Constant_in_a_DATA_Statement

          An entity in the list nlist___ _ _  that  corresponds  to  a
          character constant must be of type character.

          If the length of the character entity in the list nlist_____
          is  greater  than  the  length   of  its  corresponding
          character   constant,    the    additional    rightmost
          characters  in  the  entity  are initially defined with
          blank characters.



          FORTRAN 77 Full Language                       Page 9-3







          DATA STATEMENT                           ANSI X3J3/90.4



          If the length of the character entity in the list nlist_____
          is  less than the length of its corresponding character
          constant, the additional rightmost  characters  in  the
          constant are ignored.

          Note that initial  definition  of  a  character  entity
          causes  definition  of  all  of  the  characters in the
          entity, and  that  each  character  constant  initially
          defines   exactly   one  variable,  array  element,  or
          substring.












































          FORTRAN 77 Full Language                       Page 9-4











                                 CONTENTS


          9.  DATA STATEMENT................................  9-1
              9.1  Form of a DATA Statement.................  9-1
              9.2  DATA Statement Restrictions..............  9-1
              9.3  Implied-DO in a DATA Statement...........  9-3
              9.4  Character Constant in a DATA
                   Statement................................  9-3













































                                   - i -







                                                   ANSI X3J3/90.4



                        10.  ASSIGNMENT_STATEMENTS

          Completion of  execution  of  an  assignment  statement
          causes definition of an entity.

          There are four kinds of assignment statements:

             (1) Arithmetic

             (2) Logical

             (3) Statement label (ASSIGN)

             (4) Character

          10.1  Arithmetic_Assignment_Statement

          The form of an arithmetic assignment statement is:

                               v_ = e_

          where: v_   is the name of a variable or  array  element
                     of  type integer, real, double precision, or
                     complex

                 e_   is an arithmetic expression

          Execution of an arithmetic assignment statement  causes
          the  evaluation  of  the  expression  e_ by the rules in
          Section 6, conversion of e_ to  the  type  of  v_ ,  and
          definition  and  assignment  of  v_  with the resulting
          value, as established by the rules in Table 4.

                                  Table 4

              Arithmetic Conversion and Assignment of e_ to v_
8                       _____________________________

                        Type of v_          Value
                                           Assigned
8                       _____________________________

                        Integer            INT(e_)
8                       _____________________________

                        Real               REAL(e_)
8                       _____________________________

                        Double precision   DBLE(e_)
8                       _____________________________

                        Complex            CMPLX(e_)
8                       _____________________________
7                      |8|7|7|7|7|7|7|7|7|7|7|7|7|











9                                        |8|7|7|7|7|7|7|7|7|7|7|7|7|











9                                                   |8|7|7|7|7|7|7|7|7|7|7|7|7|













9


          FORTRAN 77 Full Language                      Page 10-1







          ASSIGNMENT STATEMENTS                    ANSI X3J3/90.4



          The functions in the "Value Assigned" column of Table 4
          are generic functions described in Table 5 (15.10).

          10.2  Logical_Assignment_Statement

          The form of a logical assignment statement is:

                               v_ = e_

          where: v_   is the name of a logical variable or logical
                     array element

                 e_   is a logical expression

          Execution of a logical assignment statement causes  the
          evaluation   of  the  logical  expression  e_  and  the
          assignment and definition of v_ with the value  of  e_ .
          Note that e_ must have a value of either true or false.

          10.3  Statement_Label_Assignment_(ASSIGN)_Statement

          The form of a statement label assignment statement is:

                               ASSIGN s_ TO i_

          where: s_   is a statement label

                 i_   is an integer variable name

          Execution of an ASSIGN statement causes  the  statement
          label  s_ to be assigned to the integer variable i_.  The
          statement label must be the label of a  statement  that
          appears   in  the  same  program  unit  as  the  ASSIGN
          statement.  The statement label must be the label of an
          executable statement or a FORMAT statement.

          Execution of a statement label assignment statement  is
          the  only  way  that  a  variable may be defined with a
          statement label value.

          A variable must be defined with a statement label value
          when  referenced  in an assigned GO TO statement (11.3)
          or as a format identifier  (12.4)  in  an  input/output
          statement.  While defined with a statement label value,
          the variable must not be referenced in any other way.

          An integer variable  defined  with  a  statement  label
          value  may  be  redefined  with the same or a different
          statement label value or an integer value.





          FORTRAN 77 Full Language                      Page 10-2







          ASSIGNMENT STATEMENTS                    ANSI X3J3/90.4



          10.4  Character_Assignment_Statement

          The form of a character assignment statement is:

                               v_ = e_

          where: v_   is  the  name  of  a  character   variable,
                     character   array   element,   or  character
                     substring

                 e_   is a character expression

          Execution of a character  assignment  statement  causes
          the  evaluation  of the expression e_ and the assignment
          and definition of v_ with the value of e_.  None  of  the
          character   positions   being  defined  in  v_  may  be
          referenced in e_.  v_ and e_ may have  different  lengths.
          If the length of v_ is greater than the length of e_, the
          effect is as though e_ were extended to the  right  with
          blank  characters  until it is the same length as v_ and
          then assigned.  If the length of v_  is  less  than  the
          length  of  e_, the effect is as though e_ were truncated
          from the right until it is the same length  as  v_  and
          then assigned.

          Only as much of the value of e_ must be  defined  as  is
          needed to define v_.  In the example:

                     CHARACTER A*2,B*4
                     A=B

          the assignment A=B requires that the  substring  B(1:2)
          be  defined.   It  does  not require that the substring
          B(3:4) be defined.

          If v_ is  a  substring,  e_  is  assigned  only  to  the
          substring.   The  definition  status  of substrings not
          specified by v_ is unchanged.
















          FORTRAN 77 Full Language                      Page 10-3











                                 CONTENTS


          10.  ASSIGNMENT STATEMENTS.......................  10-1
               10.1  Arithmetic Assignment Statement.......  10-1
               10.2  Logical Assignment Statement..........  10-2
               10.3  Statement Label Assignment (ASSIGN)
                     Statement.............................  10-2
               10.4  Character Assignment Statement........  10-3













































                                   - i -







                                                   ANSI X3J3/90.4



                          11.  CONTROL_STATEMENTS

          Control statements may be used to control the execution
          sequence.

          There are sixteen control statements:

             (1) Unconditional GO TO

             (2) Computed GO TO

             (3) Assigned GO TO

             (4) Arithmetic IF

             (5) Logical IF

             (6) Block IF

             (7) ELSE IF

             (8) ELSE

             (9) END IF

            (10) DO

            (11) CONTINUE

            (12) STOP

            (13) PAUSE

            (14) END

            (15) CALL

            (16) RETURN

          The CALL and RETURN statements are described in Section
          15.

          11.1  Unconditional_GO_TO_Statement

          The form of an unconditional GO TO statement is:

                               GO TO s_

          where s_  is  the  statement  label  of  an  executable
          statement  that appears in the same program unit as the
          unconditional GO TO statement.



          FORTRAN 77 Full Language                      Page 11-1







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          Execution of an unconditional GO TO statement causes  a
          transfer of control so that the statement identified by
          the statement label is executed next.

          11.2  Computed_GO_TO_Statement

          The form of a computed GO TO statement is:

                               GO TO (s_ [,s_]...) [,] i_

          where: i_   is an integer expression

                 s_   is the  statement  label  of  an  executable
                     statement  that  appears in the same program
                     unit as the computed GO TO  statement.   The
                     same  statement  label  may appear more than
                     once in the same computed GO TO statement.

          Execution  of  a  computed  GO  TO   statement   causes
          evaluation of the expression i_.  The evaluation of i_ is
          followed by a transfer of control so that the statement
          identified  by  the  i_th statement label in the list of
          statement labels is executed next, provided that 1 &lt; i_
          &lt;  n_, where n_ is the number of statement labels in the
          list of statement labels.  If i_&lt;1 or i_&gt;n_, the execution
          sequence  continues as though a CONTINUE statement were
          executed.

          11.3  Assigned_GO_TO_Statement

          The form of an assigned GO TO statement is:

                               GO TO i_ [[,] (s_ [,s_]...)]

          where: i_   is an integer variable name

                 s_   is the  statement  label  of  an  executable
                     statement  that  appears in the same program
                     unit as the assigned GO TO  statement.   The
                     same  statement  label  may appear more than
                     once in the same assigned GO TO statement.

          At  the  time  of  execution  of  an  assigned  GO   TO
          statement,  the  variable  i_  must be defined with the
          value of a statement label of an  executable  statement
          that  appears  in the same program unit.  Note that the
          variable may be defined with a  statement  label  value
          only  by an ASSIGN statement (10.3) in the same program
          unit as the assigned GO TO statement.  The execution of
          the  assigned  GO  TO  statement  causes  a transfer of
          control  so  that  the  statement  identified  by  that



          FORTRAN 77 Full Language                      Page 11-2







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          statement label is executed next.

          If the  parenthesized list is  present,  the  statement
          label assigned to i_ must be one of the statement labels
          in the list.

          11.4  Arithmetic_IF_Statement

          The form of an arithmetic IF statement is:

                               IF (e_) s_918 , s_928 , s_93
9          where: e_   is an integer,  real,  or  double  precision
                     expression

                 s_918,  s_928,  and s_938 are each the statement label of
                     an  executable statement that appears in the
                     same  program  unit  as  the  arithmetic  IF
                     statement.   The  same  statement  label may
                     appear more than once in the same arithmetic
                     IF statement.

          Execution  of  an  arithmetic   IF   statement   causes
          evaluation  of  the expression e_ followed by a transfer
          of control.  The statement identified by s_918, s_928, or s_93
8          is  executed  next as the value of e_ is less than zero,
          equal to zero, or greater than zero, respectively.

          11.5  Logical_IF_Statement

          The form of a logical IF statement is:

                               IF (e_) st__

          where: e_   is a logical expression

                 st__  is any executable  statement  except  a  DO,
                     block  IF,  ELSE  IF,  ELSE, END IF, END, or
                     another logical IF statement

          Execution of a logical IF statement  causes  evaluation
          of  the  expression  e_ .   If  the value of e_ is true,
          statement st__ is executed.  If the value of e_ is  false,
          statement st__ is not executed and the execution sequence
          continues as though a CONTINUE statement were executed.

          Note that the execution of a function reference in  the
          expression  e_ of a logical IF statement is permitted to
          affect entities in the statement st__.





          FORTRAN 77 Full Language                      Page 11-3







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          11.6  Block_IF_Statement

          The  block  IF  statement  is  used  with  the  END  IF
          statement   and,  optionally,  the  ELSE  IF  and  ELSE
          statements to control the execution sequence.

          The form of a block IF statement is:

                               IF (e_) THEN

          where e_ is a logical expression.

          11.6.1  IF-Level.  The IF-level of a statement s_ is

                               n_918 - n_92
9          where n_918 is the number of block IF statements from  the
          beginning  of  the  program unit up to and including s_,
          and n_928 is the  number  of  END  IF  statements  in  the
          program unit up to but not including s_.

          The  IF-level  of  every  statement  must  be  zero  or
          positive.   The  IF-level  of  each  block IF, ELSE IF,
          ELSE, and END IF statement must be positive.   The  IF-
          level of the END statement of each program unit must be
          zero.

          11.6.2  IF-Block.  An IF-block consists of all  of  the
          executable  statements  that appear following the block
          IF statement up to, but not including,  the  next  ELSE
          IF,  ELSE,  or  END  IF statement that has the same IF-
          level as the block IF statement.  An  IF-block  may  be
          empty.

          11.6.3  Execution_of_a_Block_IF_Statement.    Execution
          of  a  block  IF  statement  causes  evaluation  of the
          expression e_.  If the  value  of  e_  is  true,  normal
          execution  sequence  continues with the first statement
          of the IF-block.  If the value of e_  is  true  and  the
          IF-block  is  empty, control is transferred to the next
          END IF statement that has  the  same  IF-level  as  the
          block  IF  statement.   If  the  value  of  e_ is false,
          control is transferred to the next ELSE  IF,  ELSE,  or
          END  IF  statement  that  has  the same IF-level as the
          block IF statement.

          Transfer of control into an IF-block from  outside  the
          IF-block is prohibited.

          If the execution of the last statement in the  IF-block
          does  not  result  in a transfer of control, control is



          FORTRAN 77 Full Language                      Page 11-4







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          transferred to the next END IF statement that  has  the
          same  IF-level  as the block IF statement that precedes
          the IF-block.

          11.7  ELSE_IF_Statement

          The form of an ELSE IF statement is:

                               ELSE IF (e_) THEN

          where e_ is a logical expression.

          11.7.1  ELSE_IF-Block.  An ELSE  IF-block  consists  of
          all  of the executable statements that appear following
          the ELSE IF statement up to,  but  not  including,  the
          next  ELSE  IF,  ELSE, or END IF statement that has the
          same IF-level as the ELSE IF statement.   An  ELSE  IF-
          block may be empty.

          11.7.2  Execution_of_an_ELSE_IF_Statement.    Execution
          of  an  ELSE  IF  statement  causes  evaluation  of the
          expression e_.  If the  value  of  e_  is  true,  normal
          execution  sequence  continues with the first statement
          of the ELSE IF-block.  If the value of e_  is  true  and
          the  ELSE  IF-block is empty, control is transferred to
          the next END IF statement that has the same IF-level as
          the  ELSE  IF  statement.   If the value of e_ is false,
          control is transferred to the next ELSE  IF,  ELSE,  or
          END IF statement that has the same IF-level as the ELSE
          IF statement.

          Transfer of control into an ELSE IF-block from  outside
          the  ELSE IF-block is prohibited.  The statement label,
          if any, of the ELSE IF statement must not be referenced
          by any statement.

          If execution of the last statement in the ELSE IF-block
          does  not  result  in a transfer of control, control is
          transferred to the next END IF statement that  has  the
          same  IF-level  as  the ELSE IF statement that precedes
          the ELSE IF-block.

          11.8  ELSE_Statement

          The form of an ELSE statement is:

                               ELSE

          11.8.1  ELSE-Block.  An ELSE-block consists of  all  of
          the  executable  statements  that  appear following the
          ELSE statement up to, but not including, the  next  END



          FORTRAN 77 Full Language                      Page 11-5







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          IF  statement  that  has  the same IF-level as the ELSE
          statement.  An ELSE-block may be empty.

          An END IF statement of the same IF-level  as  the  ELSE
          statement  must appear before the appearance of an ELSE
          IF or ELSE statement of the same IF-level.

          11.8.2  Execution_of_an_ELSE_Statement.   Execution  of
          an ELSE statement has no effect.

          Transfer of control into an ELSE-block from outside the
          ELSE-block is prohibited.  The statement label, if any,
          of an ELSE statement must  not  be  referenced  by  any
          statement.

          11.9  END_IF_Statement

          The form of an END IF statement is:

                               END IF

          Execution of an END IF statement has no effect.

          For  each  block  IF  statement   there   must   be   a
          corresponding  END  IF  statement  in  the same program
          unit. A corresponding END IF statement is the next  END
          IF statement that has the same IF-level as the block IF
          statement.

          11.10  DO_Statement

          A DO statement is used to specify a loop, called a  DO-
          loop.

          The form of a DO statement is:

                               DO s_ [,] i_ = e_918, e_928, [,e_938]

          where: s_   is the  statement  label  of  an  executable
                     statement.   The  statement identified by s_,
                     called the terminal________ statement________ _  of  the  DO-
                     loop,  must  follow  the DO statement in the
                     sequence  of  statements  within  the   same
                     program unit as the DO statement.

                 i_   is the name of an integer, real,  or  double
                     precision variable, called the DO-variable___________

                 e_918,  e_928, and e_938 are each an  integer,  real,  or
                     double precision expression




          FORTRAN 77 Full Language                      Page 11-6







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          The terminal statement of a  DO-loop  must  not  be  an
          unconditional  GO  TO,  assigned  GO TO, arithmetic IF,
          block IF, ELSE IF, ELSE, END IF, RETURN, STOP, END,  or
          DO  statement.   If the terminal statement of a DO-loop
          is  a  logical  IF  statement,  it  may   contain   any
          executable  statement  except  a DO, block IF, ELSE IF,
          ELSE, END IF, END, or another logical IF statement.

          11.10.1  Range_of_a_DO-Loop.  The range  of  a  DO-loop
          consists  of  all  of  the  executable  statements that
          appear following the DO statement  that  specifies  the
          DO-loop,  up to and including the terminal statement of
          the DO-loop.

          If a DO statement appears within the  range  of  a  DO-
          loop,  the  range  of  the DO-loop specified by that DO
          statement must be contained entirely within  the  range
          of  the  outer DO-loop.  More than one DO-loop may have
          the same terminal statement.

          If a DO statement appears within an IF-block, ELSE  IF-
          block, or ELSE-block, the range of that DO-loop must be
          contained entirely within that IF-block, ELSE IF-block,
          or ELSE-block, respectively.

          If a block IF statement appears within the range  of  a
          DO-loop,  the  corresponding END IF statement must also
          appear within the range of that DO-loop.

          11.10.2  Active_and_Inactive_DO-Loops.   A  DO-loop  is
          either  active  or inactive.  Initially inactive, a DO-
          loop becomes active  only  when  its  DO  statement  is
          executed.

          Once active, the DO-loop becomes inactive only when:

             (1) its iteration  count  is  tested  (11.10.4)  and
                 determined to be zero,

             (2) a RETURN statement is executed within its range,

             (3) control is transferred to a statement that is in
                 the  same  program unit and is outside the range
                 of the DO-loop, or

             (4) any STOP statement in the executable program  is
                 executed,  or  execution  is  terminated for any
                 other reason (12.6).

          Execution of a function  reference  or  CALL  statement
          that  appears  in the range of a DO-loop does not cause



          FORTRAN 77 Full Language                      Page 11-7







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          the DO-loop to become inactive, except when control  is
          returned by means of an alternate return specifier in a
          CALL statement to a statement that is not in the  range
          of the DO-loop.

          When a DO-loop becomes inactive, the DO-variable of the
          DO-loop retains its last defined value.

          11.10.3  Executing_a_DO_Statement.    The   effect   of
          executing  a  DO  statement is to perform the following
          steps in sequence:

             (1) The initial parameter m918, the terminal parameter
                 m928,  and  the  incrementation  parameter  m938 are
                 established by evaluating  e_918,  e_928,  and  e_938,
                 respectively,     including,    if    necessary,
                 conversion  to  the  type  of  the   DO-variable
                 according to the rules for arithmetic conversion
                 (Table 4).  If e_938 does not  appear,  m_938  has  a
                 value of one.  m_938 must not have a value of zero.

             (2) The DO-variable becomes defined with  the  value
                 of the initial parameter m_918.

             (3) The iteration count is established  and  is  the
                 value of the expression

                         MAX( INT( (m_928 - m_918 + m_938)/m_938), 0)

                 Note that the iteration count is zero whenever:

                         m_918 &gt; m_928 and m_938 &gt; 0, or

                         m_918 &lt; m_928 and m_938 &lt; 0.

          At the completion of execution  of  the  DO  statement,
          loop control processing begins.

          11.10.4  Loop_Control_Processing.      Loop     control
          processing determines if further execution of the range
          of the DO-loop is  required.  The  iteration  count  is
          tested.  If  it  is  not  zero,  execution of the first
          statement in the range of the DO-loop begins.   If  the
          iteration  count is zero, the DO-loop becomes inactive.
          If, as a  result,  all  of  the  DO-loops  sharing  the
          terminal statement of this DO-loop are inactive, normal
          execution  continues  with  execution   of   the   next
          executable  statement following the terminal statement.
          However, if some of the DO-loops sharing  the  terminal
          statement   are   active,   execution   continues  with
          incrementation processing, as described in 11.10.7.



          FORTRAN 77 Full Language                      Page 11-8







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          11.10.5  Execution_of_the_Range.   Statements  in   the
          range  of  a  DO-loop  are  executed until the terminal
          statement is reached.   Except  by  the  incrementation
          described  in  11.10.7,  the DO-variable of the DO-loop
          may neither be redefined nor  become  undefined  during
          execution of the range of the DO-loop.

          11.10.6  Terminal_Statement_Execution.   Execution   of
          the terminal statement occurs as a result of the normal
          execution sequence  or  as  a  result  of  transfer  of
          control,   subject  to  the  restrictions  in  11.10.8.
          Unless execution of the terminal statement results in a
          transfer  of  control,  execution  then  continues with
          incrementation processing, as described in 11.10.7.

          11.10.7  Incrementation_Processing.      Incrementation
          processing  has  the  effect  of  the  following  steps
          performed in sequence:

             (1) The DO-variable, the iteration  count,  and  the
                 incrementation  parameter  of the active DO-loop
                 whose DO statement was most  recently  executed,
                 are selected for processing.

             (2) The value of the DO-variable is  incremented  by
                 the value of the incrementation parameter m_938.

             (3) The iteration count is decremented by one.

             (4) Execution continues with loop control processing
                 (11.10.4)  of  the  same DO-loop whose iteration
                 count was decremented.

          For example:

                     N=0
                     DO 100 I=1,10
                     J=I
                     DO 100 K=1,5
                     L=K
                 100 N=N+1
                 101 CONTINUE

          After  execution  of  these  statements  and   at   the
          execution  of  the CONTINUE statement, I=11, J=10, K=6,
          L=5, and N=50.

          Also consider the following example:

                     N=0
                     DO 200=I=1,10



          FORTRAN 77 Full Language                      Page 11-9







          CONTROL STATEMENTS                       ANSI X3J3/90.4



                     J=I
                     D0 200 K=5,1
                     L=K
                 200 N=N+1
                 201 CONTINUE

          After  execution  of  these  statements  and   at   the
          execution  of  the CONTINUE statement, I=11, J=10, K=5,
          and N=0.  L is not defined by these statements.

          11.10.8  Transfer_into_the_Range_of_a_DO-Loop.
          Transfer  of  control  into the range of a DO-loop from
          outside the range is not permitted.

          11.11  CONTINUE_Statement

          The form of a CONTINUE statement is:

                               CONTINUE

          Execution of a CONTINUE statement has no effect.

          If the CONTINUE statement is the terminal statement  of
          a  DO-loop,  the next statement executed depends on the
          result  of  the   DO-loop   incrementation   processing
          (11.10.7).

          11.12  STOP_Statement

          The form of a STOP statement is:

                               STOP [n_]

          where n_ is a string of not more than five digits, or is
          a character constant.

          Execution of a STOP  statement  causes  termination  of
          execution  of  the  executable program.  At the time of
          termination, the digit string or character constant  is
          accessible.

          11.13  PAUSE_Statement

          The form of a PAUSE statement is:

                               PAUSE [n_]

          where n_ is a string of not more than five digits, or is
          a character constant.





          FORTRAN 77 Full Language                     Page 11-10







          CONTROL STATEMENTS                       ANSI X3J3/90.4



          Execution of a PAUSE statement causes  a  cessation  of
          execution of the executable program.  Execution must be
          resumable.  At the time of cessation of execution,  the
          digit  string  or  character  constant  is  accessible.
          Resumption of execution is not  under  control  of  the
          program.    If  execution  is  resumed,  the  execution
          sequence continues as though a CONTINUE statement  were
          executed.

          11.14  END_Statement

          The END statement indicates  the end of the sequence of
          statements  and  comment lines of a program unit (3.5).
          If executed in a function or subroutine subprogram,  it
          has  the  effect  of  a  RETURN  statement  (15.8).  If
          executed in a main program, it terminates the execution
          of the executable program.

          The form of an END statement is:

                               END

          An END statement is written only in columns  7  through
          72  of  an  initial line.  An END statement must not be
          continued.  No other statement in a  program  unit  may
          have  an  initial  line  that  appears  to  be  an  END
          statement.

          The last line of every program  unit  must  be  an  END
          statement.
























          FORTRAN 77 Full Language                     Page 11-11











                                 CONTENTS


          11.  CONTROL STATEMENTS.........................   11-1
               11.1   Unconditional GO TO
                      Statement...........................   11-1
               11.2   Computed GO TO Statement............   11-2
               11.3   Assigned GO TO Statement............   11-2
               11.4   Arithmetic IF Statement.............   11-3
               11.5   Logical IF Statement................   11-3
               11.6   Block IF Statement..................   11-4
                      11.6.1   IF-Level...................   11-4
                      11.6.2   IF-Block...................   11-4
                      11.6.3   Execution of a Block IF
                               Statement..................   11-4
               11.7   ELSE IF Statement...................   11-5
                      11.7.1   ELSE IF-Block..............   11-5
                      11.7.2   Execution of an ELSE IF
                               Statement..................   11-5
               11.8   ELSE Statement......................   11-5
                      11.8.1   ELSE-Block.................   11-5
                      11.8.2   Execution of an ELSE
                               Statement..................   11-6
               11.9   END IF Statement....................   11-6
               11.10  DO Statement........................   11-6
                      11.10.1  Range of a DO-Loop.........   11-7
                      11.10.2  Active and Inactive DO-
                               Loops......................   11-7
                      11.10.3  Executing a DO
                               Statement..................   11-8
                      11.10.4  Loop Control
                               Processing.................   11-8
                      11.10.5  Execution of the
                               Range......................   11-9
                      11.10.6  Terminal Statement
                               Execution..................   11-9
                      11.10.7  Incrementation
                               Processing.................   11-9
                      11.10.8  Transfer into the Range of
                               a DO-Loop..................  11-10
               11.11  CONTINUE Statement..................  11-10
               11.12  STOP Statement......................  11-10
               11.13  PAUSE Statement.....................  11-10
               11.14  END Statement.......................  11-11










                                   - i -







                                                   ANSI X3J3/90.4



                       12.  INPUT/OUTPUT_STATEMENTS

          Input statements provide the means of transferring data
          from  external  media  to  internal  storage or from an
          internal file to internal  storage.   This  process  is
          called reading.  Output statements provide the means of
          transferring data from  internal  storage  to  external
          media  or  from  internal  storage to an internal file.
          This process  is  called  writing.   Some  input/output
          statements  specify  that  editing of the data is to be
          performed.

          In addition to the statements that transfer data, there
          are auxiliary input/output statements to manipulate the
          external medium, or to inquire about  or  describe  the
          properties of the connection to the external medium.

          There are nine input/output statements:

             (1) READ

             (2) WRITE

             (3) PRINT

             (4) OPEN

             (5) CLOSE

             (6) INQUIRE

             (7) BACKSPACE

             (8) ENDFILE

             (9) REWIND

          The READ, WRITE, and PRINT statements are data transfer
          input/output   statements  (12.8).   The  OPEN,  CLOSE,
          INQUIRE, BACKSPACE, ENDFILE, and REWIND statements  are
          auxiliary   input/output   statements   (12.10).    The
          BACKSPACE, ENDFILE,  and  REWIND  statements  are  file
          positioning input/output statements (12.10.4).

          12.1  Records

          A record is a sequence (2.1) of values or a sequence of
          characters.   For  example,  a  punched card is usually
          considered to be a record.  However, a record does  not
          necessarily correspond to a physical entity.  There are
          three kinds of records:



          FORTRAN 77 Full Language                      Page 12-1







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



             (1) Formatted

             (2) Unformatted

             (3) Endfile

          12.1.1  Formatted_Record.  A formatted record  consists
          of  a  sequence  of  characters  that  are  capable  of
          representation in  the  processor.   The  length  of  a
          formatted  record is measured in characters and depends
          primarily on the number  of  characters  put  into  the
          record  when  it is written.  However, it may depend on
          the processor and the external medium.  The length  may
          be zero.  Formatted records may be read or written only
          by formatted input/output statements (12.8.1).

          Formatted records may be prepared by some  means  other
          than FORTRAN; for example, by some manual input device.

          12.1.2  Unformatted_Record.   An   unformatted   record
          consists  of  a  sequence  of  values  in  a processor-
          dependent form  and  may  contain  both  character  and
          noncharacter  data  or may contain no data.  The length
          of an unformatted  record  is  measured  in  processor-
          dependent units and depends on the output list (12.8.2)
          used when it is written, as well as  on  the  processor
          and the external medium.  The length may be zero.

          Unformatted records may be  read  or  written  only  by
          unformatted input/output statements (12.8.1).

          12.1.3  Endfile_Record.  An endfile record  is  written
          by  an  ENDFILE statement.  An endfile record may occur
          only as the last record of a file.  An  endfile  record
          does not have a length property.

          12.2  Files

          A file is a sequence (2.1) of records.

          There are two kinds of files:

             (1) External

             (2) Internal

          12.2.1  File_Existence.  At any given time, there is  a
          processor-determined  set  of  files  that  are said to
          exist for an executable program.  A file may  be  known
          to  the  processor,  yet  not  exist  for an executable
          program at a particular time.   For  example,  security



          FORTRAN 77 Full Language                      Page 12-2







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          reasons  may  prevent  a  file  from  existing  for  an
          executable program.  A file may exist  and  contain  no
          records;  an  example  is  a newly created file not yet
          written.

          To create a file means to cause a file  to  exist  that
          did  not  previously  exist.  To delete a file means to
          terminate the existence of the file.

          All input/output statements may  refer  to  files  that
          exist.   The  INQUIRE,  OPEN,  CLOSE, WRITE, PRINT, and
          ENDFILE statements may also refer to files that do  not
          exist.

          12.2.2  File_Properties.  At any given time, there is a
          processor-determined  set  of allowed access methods, a
          processor-determined  set  of  allowed  forms,  and   a
          processor-determined  set of allowed record lengths for
          a file.

          A file may have a name; a  file  that  has  a  name  is
          called  a  named  file.   The name of a named file is a
          character  string.   The  set  of  allowable  names  is
          processor dependent and may be empty.

          12.2.3  File_Position.  A file that is connected  to  a
          unit  (12.3)  has  a  position  property.  Execution of
          certain input/output statements affects the position of
          a  file.   Certain circumstances can cause the position
          of a file to become indeterminate.

          The initial point of a file is the position just before
          the  first  record  The  terminal point is the position
          just after the last record.

          If a file is positioned within a record, that record is
          the  current  record;  otherwise,  there  is no current
          record.

          Let n_ be the number of records in the file.  If 1 &lt; i_ &lt;
           n_  and  a file is positioned within the i_th record or
          between the (i_-1)th record and the i_th record, the (i_ -
          1)th  record  is the preceding record.  If n_ &gt;1 and the
          file is positioned at its terminal point, the preceding
          record is the n_th and last record.  If n_=0 or if a file
          is positioned at its initial point or within the  first
          record, there is no preceding record.

          If 1 &lt; i_ &lt; n_ and a file is positioned within the  i_ th
          record  or  between the i_th and (i_+1)th record, the (i_+
          1)th record is the next record.  If n_ &gt; 1 and the  file



          FORTRAN 77 Full Language                      Page 12-3







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          is positioned at its initial point, the first record is
          the next record.  If n_=0 or if a file is positioned  at
          its  terminal  point or within the n_th and last record,
          there is no next record.

          12.2.4  File_Access.   There   are   two   methods   of
          accessing  the  records of an external file: sequential
          and direct.  Some files may have more than one  allowed
          access  method;  other  files  may be restricted to one
          access method.  For example, a processor may allow only
          sequential  access  to  a file on magnetic tape.  Thus,
          the set of allowed access methods depends on  the  file
          and the processor.

          The method of accessing the file is determined when the
          file is connected to a unit (12.3.2).

          An internal file must be accessed sequentially.

          12.2.4.1  Sequential_Access.    When   connected    for
          sequential access, a file has the following properties:

             (1) The order of the records is the order  in  which
                 they were written if the direct access method is
                 not a  member  of  the  set  of  allowed  access
                 methods  for  the  file.   If  the direct access
                 method is also a member of the  set  of  allowed
                 access  methods  for  the file, the order of the
                 records is the same as that specified for direct
                 access (12.2.4.2).  The first record accessed by
                 sequential access is  the  record  whose  record
                 number  is  1  for  direct  access.   The second
                 record accessed  by  sequential  access  is  the
                 record  whose  record  number  is  2  for direct
                 access, etc.  A record that has not been written
                 since the file was created must not be read.

             (2) The records of the file are either all formatted
                 or  all unformatted, except that the last record
                 of the file may be an endfile record.

             (3) The records of the file  must  not  be  read  or
                 written by direct access input/output statements
                 (12.8.1).

          12.2.4.2  Direct_Access.   When  connected  for  direct
          access, a file has the following properties:

             (1) The order of the records is the order  of  their
                 record  numbers.   The  records  may  be read or
                 written in any order.



          FORTRAN 77 Full Language                      Page 12-4







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



             (2) The records of the file are either all formatted
                 or  all  unformatted.   If the sequential access
                 method is also a member of the  set  of  allowed
                 access methods for the file, its endfile record,
                 if any, is not considered to be part of the file
                 while it is connected for direct access.  If the
                 sequential access method is not a member of  the
                 set  of allowed access methods for the file, the
                 file must not contain an endfile record.

             (3) Reading and writing records is accomplished only
                 by   direct   access   input/output   statements
                 (12.8.1).

             (4) All records of the file have the same length.

             (5) Each record of the file is  uniquely  identified
                 by  a positive integer called the record number.
                 The record number of a record is specified  when
                 the  record  is  written.  Once established, the
                 record number of a record can never be changed.

                 Note that a record may not be deleted;  however,
                 a record may be rewritten.

             (6) Records need not be read or written in the order
                 of  their  record  numbers.   Any  record may be
                 written into the  file  while  it  is  connected
                 (12.3.2)   to   a  unit.   For  example,  it  is
                 permissible  to  write  record  3,  even  though
                 records  1  and  2  have  not been written.  Any
                 record may be read from the  file  while  it  is
                 connected  to  a  unit, provided that the record
                 was written since the file was created.

             (7) The records of the file  must  not  be  read  or
                 written using list-directed formatting.

          12.2.5  Internal_Files.  Internal files provide a means
          of  transferring  and  converting  data  from  internal
          storage to internal storage.

          12.2.5.1  Internal_File_Properties.  An  internal  file
          has the following properties:

             (1) The file  is  a  character  variable,  character
                 array  element,  character  array,  or character
                 substring.

             (2) A record of an  internal  file  is  a  character
                 variable,  character array element, or character



          FORTRAN 77 Full Language                      Page 12-5







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



                 substring.

             (3) If the file is a character  variable,  character
                 array   element,   or  character  substring,  it
                 consists of a single record whose length is  the
                 same  as  the  length  of  the  variable,  array
                 element, or  substring,  respectively.   If  the
                 file  is  a  character array, it is treated as a
                 sequence  of  character  array  elements.   Each
                 array  element  is  a  record  of the file.  The
                 ordering of the records of the file is the  same
                 as  the  ordering  of  the array elements in the
                 array (5.2.4).  Every record of the file has the
                 same  length,  which  is  the length of an array
                 element in the array.

             (4) The variable, array element, or  substring  that
                 is  the  record  of  the  internal  file becomes
                 defined by writing the record.  If the number of
                 characters  written in a record is less than the
                 length of the record, the remaining  portion  of
                 the record is filled with blanks.

             (5) A record may be read only if the variable, array
                 element,  or  substring  that  is  the record is
                 defined.

             (6) A variable, array element, or substring that  is
                 a  record of an internal file may become defined
                 (or undefined) by means  other  than  an  output
                 statement.   For  example,  the  variable, array
                 element, or substring may become  defined  by  a
                 character assignment statement.

             (7) An internal file is  always  positioned  at  the
                 beginning  of  the  first  record  prior to data
                 transfer.

          12.2.5.2  Internal_File_Restrictions.  An internal file
          has the following restrictions:

             (1) Reading and writing records is accomplished only
                 by   sequential  access  formatted  input/output
                 statements (12.8.1) that do  not  specify  list-
                 directed formatting.

             (2) An auxiliary  input/output  statement  must  not
                 specify an internal file.






          FORTRAN 77 Full Language                      Page 12-6







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          12.3  Units

          A unit is a means of referring to a file.

          12.3.1  Unit_Existence.  At any given time, there is  a
          processor-determined  set  of  units  that  are said to
          exist for an executable program.

          All input/output statements may  refer  to  units  that
          exist.  The INQUIRE and CLOSE statements may also refer
          to units that do not exist.

          12.3.2  Connection_of_a_Unit.  A unit has a property of
          being  connected  or  not  connected.  If connected, it
          refers to a file.   A  unit  may  become  connected  by
          preconnection or by the execution of an OPEN statement.
          The property of connection is symmetric: if a  unit  is
          connected to a file, the file is connected to the unit.

          Preconnection means that the unit  is  connected  to  a
          file  at  the  beginning of execution of the executable
          program and therefore may be referenced by input/output
          statements  without  the  prior  execution  of  an OPEN
          statement.

          All input/output statements  except  OPEN,  CLOSE,  and
          INQUIRE  must  reference  a unit that is connected to a
          file and thereby make use of or affect that file.

          A file may be connected and not exist.  An example is a
          preconnected new file.

          A unit must not be connected to more than one  file  at
          the same time, and a file must not be connected to more
          than one unit at the same  time.   However,  means  are
          provided  to change the status of a unit and to connect
          a unit to a different file.

          After a unit has been disconnected by the execution  of
          a CLOSE statement, it may be connected again within the
          same executable program to the same file or a different
          file.   After  a  file  has  been  disconnected  by the
          execution of a CLOSE statement,  it  may  be  connected
          again  within  the  same executable program to the same
          unit or a different unit.  Note, however, that the only
          means  to refer to a file that has been disconnected is
          by  its  name  in  an  OPEN   or   INQUIRE   statement.
          Therefore,  there  may  be  no means of reconnecting an
          unnamed file once it is disconnected.





          FORTRAN 77 Full Language                      Page 12-7







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          12.3.3  Unit_Specifier_and_Identifier.  The form  of  a
          unit specifier is:

                               [UNIT =] u_

          where u_ is an external unit identifier or  an  internal
          file identifier.

          An external unit identifier is  used  to  refer  to  an
          external  file.  An internal file identifier is used to
          refer to an internal file.

          An external unit identifier is one of the following:

             (1) An integer expression i_ whose value must be zero
                 or positive

             (2) An   asterisk,    identifying    a    particular
                 processor-determined   external   unit  that  is
                 preconnected  for  formatted  sequential  access
                 (12.9.2)

          The external unit identified by the value of i_  is  the
          same   external  unit  in  all  program  units  of  the
          executable program.  In the example:

                     SUBROUTINE A
                     READ (6) X

                     SUBROUTINE B
                     N=6
                     REWIND N

          the value 6 used in both program units  identifies  the
          same external unit.

          An   external   unit   identifier   in   an   auxiliary
          input/output statement (12.10) must not be an asterisk.

          An internal file identifier is the name of a  character
          variable,  character array, character array element, or
          character substring.

          If the optional characters UNIT= are omitted  from  the
          unit  specifier,  the  unit specifier must be the first
          item in a list of specifiers.








          FORTRAN 77 Full Language                      Page 12-8







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          12.4  Format_Specifier_and_Identifier

          The form of a format specifier is:

                               [FMT =] f_

          where f_ is a format identifier.

          A format identifier  identifies  a  format.   A  format
          identifier must be one of the following:

             (1) The statement label of a FORMAT  statement  that
                 appears  in  the same program unit as the format
                 identifier.

             (2) An integer variable name that has been  assigned
                 the  statement  label of a FORMAT statement that
                 appears in the same program unit as  the  format
                 identifier (10.3).

             (3) A character array name (13.1.2).

             (4) Any  character  expression  except  a  character
                 expression involving concatenation of an operand
                 whose length specification  is  an  asterisk  in
                 parentheses  unless  the operand is the symbolic
                 name of  a  constant.   Note  that  a  character
                 constant is permitted.

             (5) An    asterisk,     specifying     list-directed
                 formatting.

          If the optional characters FMT= are  omitted  from  the
          format  specifier,  the  format  specifier  must be the
          second item in the control  information  list  and  the
          first  item  must  be  the  unit  specifier without the
          optional characters UNIT=.

          12.5  Record_Specifier

          The form of a record specifier is:

                               REC = rn__

          where rn__  is  an  integer  expression  whose  value  is
          positive.   It  specifies the number of the record that
          is to be read or written in a file connected for direct
          access.






          FORTRAN 77 Full Language                      Page 12-9







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          12.6  Error_and_End-of-File_Conditions

          The set of input/output error conditions  is  processor
          dependent.

          An  end-of-file  condition  exists  if  either  of  the
          following events occurs:

             (1) An endfile  record  is  encountered  during  the
                 reading  of  a  file  connected  for  sequential
                 access.  In this case, the  file  is  positioned
                 after the endfile record.

             (2) An attempt is made to read a record  beyond  the
                 end of an internal file.

          If an error condition occurs  during  execution  of  an
          input/output  statement,  execution of the input/output
          statement terminates  and  the  position  of  the  file
          becomes indeterminate.

          If an  error  condition  or  an  end-of-file  condition
          occurs  during execution of a READ statement, execution
          of the  READ  statement  terminates  and  the  entities
          specified by the input list and implied-DO-variables in
          the input list become undefined.  Note  that  variables
          and   array  elements  appearing  only  in  subscripts,
          substring expressions, and implied-DO parameters in  an
          input  list  do  not become undefined when the entities
          specified by the list become undefined.

          If an error condition occurs  during  execution  of  an
          output  statement,  execution  of  the output statement
          terminates and implied-DO-variables in the output  list
          become undefined.

          If an error condition occurs  during  execution  of  an
          input/output   statement   that   contains  neither  an
          input/output  status  specifier  (12.7)  nor  an  error
          specifier  (12.7.1),  or  if  an  end-of-file condition
          occurs  during  execution  of  a  READ  statement  that
          contains  neither  an input/output status specifier nor
          an end-of-file specifier  (12.7.2),  execution  of  the
          executable program is terminated.










          FORTRAN 77 Full Language                     Page 12-10







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          12.7  Input/Output Status, Error, and End-of-File
                Specifiers

          The form of an input/output status specifier is:

                               IOSTAT = ios___

          where ios___ is  an  integer  variable  or  integer  array
          element.

          Execution of an input/output statement containing  this
          specifier causes ios___ to become defined:

             (1) with a zero value if neither an error  condition
                 nor  an  end-of-file condition is encountered by
                 the processor,

             (2) with  a  processor-dependent  positive   integer
                 value if an error condition is encountered, or

             (3) with  a  processor-dependent  negative   integer
                 value if an end-of-file condition is encountered
                 and no error condition is encountered.

          12.7.1  Error_Specifier.   The   form   of   an   error
          specifier is:

                               ERR = s_

          where s_  is  the  statement  label  of  an  executable
          statement  that appears in the same program unit as the
          error specifier.

          If  an  input/output  statement   contains   an   error
          specifier   and   the  processor  encounters  an  error
          condition during execution of the statement:

             (1) execution   of   the   input/output    statement
                 terminates,

             (2) the  position  of  the  file  specified  in  the
                 input/output  statement                  becomes
                 indeterminate,

             (3) if  the  input/output  statement   contains   an
                 input/output   status   specifier   (12.7),  the
                 variable or array element ios__ _  becomes  defined
                 with   a  processor-dependent  positive  integer
                 value, and





          FORTRAN 77 Full Language                     Page 12-11







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



             (4) execution continues with the statement labeled s_
                 .

          12.7.2  End-of-File_Specifier.  The form of an  end-of-
          file specifier is:

                               END = s_

          where s_  is  the  statement  label  of  an  executable
          statement  that appears in the same program unit as the
          end-of-file specifier.

          If a READ statement contains an  end-of-file  specifier
          and  the  processor encounters an end-of-file condition
          and  no  error  condition  during  execution   of   the
          statement:

             (1) execution of the READ statement terminates,

             (2) if the READ statement contains  an  input/output
                 status  specifier  (12.7), the variable or array
                 element ios___ becomes defined  with  a  processor-
                 dependent negative integer value, and

             (3) execution continues with the statement labeled s_
                 .

          12.8  READ,_WRITE,_and_PRINT_Statements

          The  READ  statement  is  the   data   transfer   input
          statement.  The WRITE and PRINT statements are the data
          transfer output statements.   The  forms  of  the  data
          transfer input/output statements are:

                               READ (cilist______) [iolist______]

                               READ f_ [,iolist______]

                               WRITE (cilist______) [iolist______]

                               PRINT f_ [,iolist______]

          where: cilist______ is a control  information  list  (12.8.1)
                     that includes:

                     (1) A reference to the source or destination
                         of the data to be transferred

                     (2) Optional   specification   of=   editing
                         processes




          FORTRAN 77 Full Language                     Page 12-12







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



                     (3) Optional specifiers that  determine  the
                         execution  sequence on the occurrence of
                         certain events

                     (4) Optional  specification  to  identify  a
                         record

                     (5) Optional specification to provide  t|%he
                         return of the input/output status

                 f_   is a format identifier (12.4)

                 iolist_ _ _ _ _ _ is  an  input/output  list  (12.8.2)
                     specifying the data to be transferred

          12.8.1  Control_Information_List.       A       control
          information  list,  cilist, is a list (2.10) whose list
          items may be any of the following:

8                              ______________

                               [UNIT =] u_
                               [FMT =] f_
                               REC = rn__
                               IOSTAT = ios___
                               ERR = s_
                               END = s_
8                              ______________
7                             |8|7|7|7|7|7|7|





9                                           |8|7|7|7|7|7|7|







9          A control information list  must  contain  exactly  one
          unit  specifier  (12.3.3), at most one format specifier
          (12.4), at most one record specifier  (12.5),  at  most
          one  input/output  status specifier (12.7), at most one
          error specifier (12.7.1), and at most  one  end-of-file
          specifier (12.7.2).

          If the  control  information  list  contains  a  format
          specifier,  the  statement  is a formatted input/output
          statement; otherwise, it is an unformatted input/output
          statement.

          If the  control  information  list  contains  a  record
          specifier,   the   statement   is   a   direct   access
          input/output statement; otherwise, it is  a  sequential
          access input/output statement.

          If the optional characters UNIT= are omitted  from  the
          unit  specifier,  the  unit specifier must be the first
          item in the control information list.

          If the optional characters FMT= are  omitted  from  the
          format  specifier,  the  format  specifier  must be the



          FORTRAN 77 Full Language                     Page 12-13







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          second item in the control  information  list  and  the
          first  item  must  be  the  unit  specifier without the
          optional characters UNIT=.

          A control information list  must  not  contain  both  a
          record specifier and an end-of-file specifier.

          If the format identifier is an asterisk, the  statement
          is  a list-directed input/output statement and a record
          specifier must not be present.

          In a WRITE statement, the control information list must
          not contain an end-of-file specifier.

          If the unit specifier specifies an internal  file,  the
          control   information   list   must  contain  a  format
          identifier other than an asterisk and must not  contain
          a record specifier.

          12.8.2  Input/Output_List.    An   input/output   list,
          iolist,   specifies   the  entities  whose  values  are
          transferred by a data transfer input/output statement.

          An input/output list is a list (2.10)  of  input/output
          list   items   and  implied-DO  lists  (12.8.2.3).   An
          input/output list item is either an input list item  or
          an output list item.

          If an array name appears as an input/output list  item,
          it  is  treated  as if all of the elements of the array
          were specified in the  order  given  by  array  element
          ordering  (5.2.4).   The  name of an assumed-size dummy
          array must not appear as an input/output list item.

          12.8.2.1  Input_List_Items.  An input list item must be
          one of the following:

             (1) A variable name

             (2) An array element name

             (3) A character substring name

             (4) An array name

          Only input list items may appear as  input/output  list
          items in an input statement.

          12.8.2.2  Output_List_Items.  An output list item  must
          be one of the following:




          FORTRAN 77 Full Language                     Page 12-14







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



             (1) A variable name

             (2) An array element name

             (3) A character substring name

             (4) An array name

             (5) Any  other   expression   except   a   character
                 expression involving concatenation of an operand
                 whose length specification  is  an  asterisk  in
                 parentheses  unless  the operand is the symbolic
                 name of a constant

          Note that a constant, an expression involving operators
          or  function  references,  or an expression enclosed in
          parentheses may appear as an output list item but  must
          not appear as an input list item.

          12.8.2.3  Implied-DO_List.  An implied-DO  list  is  of
          the form:

                               ( dlist_____, i_ = e_918, e_928 [,e_938 ] )

          where: i_ ,  are  as  specified  for  the  DO  statement
                     (11.10)

                 dlistunde&gt;r is an input/output list

          The range of an implied-DO list is the list dlist_ _ _ _ _ .
          Note  that  dlist_____ may contain implied-DO . lists.  The
          iteration count and the values of the DO-variable i_ are
          established  from  e_918, e_928, and e_938 exactly as for a DO-
          loop.  In an input statement, the DO-variable i_, or  an
          associated  entity,  must  not  appear as an input list
          item in dlist_____.  When an implied-DO list appears  in  an
          input/output  list,  the  list  items  in  dlist_ _ ___ are
          specified once for each  iteration  of  the  implied-DO
          list   with  appropriate substitution of values for any
          occurrence of the DO-variable i_.

          12.9  Execution of a Data Transfer Input/Output
                Statement

          The effect of executing a  data  transfer  input/output
          statement  must  be as if the following operations were
          performed in the order specified:

             (1) Determine the direction of data transfer





          FORTRAN 77 Full Language                     Page 12-15







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



             (2) Identify the unit

             (3) Establish the format if any is specified

             (4) Position the file prior to data transfer

             (5) Transfer data between the file and the  entities
                 specified by the input/output list (if any)

             (6) Position the file after data transfer

             (7) Cause the specified integer  variable  or  array
                 element in the input/output status specifier (if
                 any) to become defined

          12.9.1  Direction_of_Data_Transfer.   Execution  of   a
          READ  statement  causes values to be transferred from a
          file to the entities specified by the  input  list,  if
          one is specified.

          Execution of a WRITE or PRINT statement  causes  values
          to be transferred to a file from the entities specified
          by the output list and format specification  (if  any).
          Execution of a WRITE or PRINT statement for a file that
          does not  exist  creates  the  file,  unless  an  error
          condition occurs.

          12.9.2  Identifying_a_Unit.     A     data     transfer
          input/output   statement   that   contains   a  control
          information list (12.8.1)  includes  a  unit  specifier
          that  identifies  an external unit or an internal file.
          A READ  statement  that  does  not  contain  a  control
          information  list  specifies  a  particular  processor-
          determined  unit,  which  is  the  same  as  the   unit
          identified  by  an  asterisk  in  a READ statement that
          contains a control information list.  A PRINT statement
          specifies  some  other processor-determined unit, which
          is the same as the unit identified by an asterisk in  a
          WRITE statement.  Thus, each data transfer input/output
          statement identifies an external unit  or  an  internal
          file.

          The unit identified by  a  data  transfer  input/output
          statement must be connected to a file when execution of
          the statement begins.

          12.9.3  Establishing_a_Format.     If    the    control
          information  list  contains  a  format identifier other
          than an asterisk, the format  specification  identified
          by the format identifier is established.  If the format
          identifier is an asterisk, list-directed formatting  is



          FORTRAN 77 Full Language                     Page 12-16







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          established.

          On output, if an internal file has  been  specified,  a
          format  specification  (13.1) that is in the file or is
          associated (17.1) with the file must not be specified.

          12.9.4  File_Position_Prior_to_Data_Transfer.       The
          positioning  of the file prior to data transfer depends
          on the method of access: sequential or direct.

          If the file contains an endfile record, the  file  must
          not  be  positioned  after  the endfile record prior to
          data transfer.

          12.9.4.1  Sequential_Access.  On  input,  the  file  is
          positioned  at  the beginning of the next record.  This
          record becomes the current record.  On  output,  a  new
          record  is  created  and becomes the last record of the
          file.

          An internal file is always positioned at the  beginning
          of  the  first record of the file.  This record becomes
          the current record.

          12.9.4.2  Direct_Access.  For direct access,  the  file
          is  positioned at the beginning of the record specified
          by the record specifier (12.5).   This  record  becomes
          the current record.

          12.9.5  Data_Transfer.  Data  are  transferred  between
          records  and  entities  specified  by  the input/output
          list.  The list items are processed in the order of the
          input/output list.

          All values  needed  to  determine  which  entities  are
          specified  by  an input/output list item are determined
          at the beginning of the processing of that  item.   All
          values   are   transmitted  to  or  from  the  entities
          specified by a list item prior to the processing of any
          succeeding list item.  In the example,

                               READ (3) N, A(N)

          two values are read; one is  assigned  to  N,  and  the
          second is assigned to A(N) for the new value of N.

          An input list item, or an  entity  associated  with  it
          (17.1.3),   must   not   contain  any  portion  of  the
          established format specification.





          FORTRAN 77 Full Language                     Page 12-17







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          If an intern file has been specified,  an  input/output
          list  item  must  not be in the file or associated with
          the file.

          A DO-variable  becomes  defined  at  the  beginning  of
          processing of the items that constitute the range of an
          implied-DO list.

          On  output,  every  entity  whose  value   is   to   be
          transferred must be defined.

          On input, an  attempt  to  read  a  record  of  a  file
          connected  for  direct  access  that has not previously
          been written causes all entities specified by the input
          list to become undefined.

          12.9.5.1  Unformatted_Data_Transfer.             During
          unformatted data transfer, data are transferred without
          editing between the current  record  and  the  entities
          specified by the input/output list.  Exactly one record
          is read or written.

          On input, the file  must  be  positioned  so  that  the
          record  read  is  an  unformatted  record or an endfile
          record.

          On input, the number of values required  by  the  input
          list must be less than or equal to the number of values
          in the record.

          On input, the type of each value  in  the  record  must
          agree  with the type of the corresponding entity in the
          input  list,  except  that  one   complex   value   may
          correspond to two real list entities or two real values
          may correspond to  one  complex  list  entity.   If  an
          entity  in  the  input  list  is of type character, the
          length of the character  entity  must  agree  with  the
          length of the character value.

          On output to a file connected for  direct  access,  the
          output  list  must not specify more values than can fit
          into a record.

          On output, if the file is connected for  direct  access
          and the values specified by the output list do not fill
          the record, the remainder of the record is undefined.

          If the file is connected  for  formatted  input/output,
          unformatted data transfer is prohibited.





          FORTRAN 77 Full Language                     Page 12-18







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          The unit specified must be an external unit.

          12.9.5.2  Formatted_Data_Transfer.   During   formatted
          data   transfer,  data  are  transferred  with  editing
          between the entities specified by the input/output list
          and   the   file.   The  current  record  and  possibly
          additional records are read or written.

          On input, the file  must  be  positioned  so  that  the
          record read is a formatted record or an endfile record.

          If the file is connected for unformatted  input/output,
          formatted data transfer is prohibited.

          12.9.5.2.1  Using_a_Format_Specification.  If a  format
          specification  has  been  established,  format  control
          (13.3)  is  initiated  and  editing  is  performed   as
          described in 13.3 through 13.5.

          On input, the input list and format specification  must
          not  require  more  characters  from  a record than the
          record contains.

          If the file is connected for direct access, the  record
          number is increased by one as each succeeding record is
          read or written.

          On output, if the file is connected for  direct  access
          or  is an internal file and the characters specified by
          the output list and format do not fill a record,  blank
          characters are added to fill the record.

          On output, if the file is connected for  direct  access
          or  is  an  internal  file,  the output list and format
          specification must not specify more  characters  for  a
          record than can fit into the record.

          12.9.5.2.2  List-Directed_Formatting.  If list-directed
          formatting  has  been established, editing is performed
          as described in 13.6.

          12.9.5.2.3  Printing_of_Formatted_Records.          The
          transfer  of  information  in  a  formatted  record  to
          certain devices determined by the processor  is  called
          printing.   If a formatted record is printed, the first
          character of the record is not printed.  The  remaining
          characters  of  the  record, if any, are printed in one
          line beginning at the left margin.

          The  first  character  of  such  a  record   determines
          vertical spacing as follows:



          FORTRAN 77 Full Language                     Page 12-19







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



8              ______________________________________________

               Character   Vertical Spacing Before Printing
8              ______________________________________________

                 Blank     One Line
                   0       Two Lines
                   1       To First Line of Next Page
                   +       No Advance
8              ______________________________________________
7             |7|7|7|7|7|7|7|






                        |7|7|7|7|7|7|7|






                                                           |7|7|7|7|7|7|7|








          If there are no characters in the record (13.5.4),  the
          vertical  spacing  is  one line and no characters other
          than blank are printed in that line.

          A PRINT statement does not  imply  that  printing  will
          occur,  and  a  WRITE  statement  does  not  imply that
          printing will not occur.

          12.9.6  File_Position_After_Data_Transfer.  If an  end-
          of-file  condition  exists  as  a  result of reading an
          endfile  record,  the  file  is  positioned  after  the
          endfile record.

          If no error condition or end-of-file condition  exists,
          the  file  is  positioned after the last record read or
          written and that record becomes the  preceding  record.
          A  record  written  on  a file connected for sequential
          access becomes the last record of the file.

           If the file is positioned after  the  endfile  record,
          execution  of a data transfer input/output statement is
          prohibited.  However, a BACKSPACE or  REWIND  statement
          may be used to reposition the file.

          If an error condition exists, the position of the  file
          is indeterminate.

          12.9.7  Input/Output_Status_Specifier_Definition.    If
          the  data  transfer  input/output statement contains an
          input/output status specifier, the integer variable  or
          array  element  ios_ _ _  becomes  defined.   If no error
          condition or end-of-file condition exists, the value of
          ios_ __ is zero.  If an error condition exists, the value
          of ios___ is positive.  If an end-of-file condition exists
          and  no  error  condition  exists,  the value of ios___ is
          negative.





9


          FORTRAN 77 Full Language                     Page 12-20







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          12.10  Auxiliary_Input/Output_Statements

          12.10.1  OPEN_Statement.  An OPEN statement may be used
          to  connect (12.3.2) an existing file to a unit, create
          a file (12.2.1) that is preconnected, create a file and
          connect it to a unit, or change certain specifiers of a
          connection between a file and a unit.

          The form of an OPEN statement is:

                               OPEN (olist_____)

          where olist_____ is a list (2.10) of specifiers:

8                              ______________

                               [UNIT =] u_
                               IOSTAT = ios___
                               ERR = s_
                               FILE = fin___
                               STATUS = sta___
                               ACCESS = acc___
                               FORM = fm__
                               RECL = rl__
                               BLANK = blnk____
8                              ______________
7                             |8|7|7|7|7|7|7|7|7|7|








9                                           |8|7|7|7|7|7|7|7|7|7|










9          olist_____ must contain exactly one external unit  specifier
          (12.3.3)  and  may  contain  at most one of each of the
          other specifiers.

          The other specifiers are described as follows:

          IOSTAT = ios___

                 is  an  input/output  status  specifier  (12.7).
                 Execution  of  an OPEN statement containing this
                 specifier causes ios___ to become  defined  with  a
                 zero  value if no error condition exists or with
                 a processor-dependent positive integer value  if
                 an error condition exists.

          ERR = s_

                 is an error specifier (12.7.1).

          FILE = fin___

                 fin___ is a character expression whose  value  when
                 any  trailing  blanks are removed is the name of
                 the file to be connected to the specified  unit.
                 The  file name must be a name that is allowed by



          FORTRAN 77 Full Language                     Page 12-21







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



                 the processor.  If this specifier is omitted and
                 the  unit is not connected to a file, it becomes
                 connected to a processor-determined file.   (See
                 also 12.10.1.1.)

          STATUS = sta___

                 sta___ is a character expression whose  value  when
                 any  trailing  blanks  are  removed is OLD, NEW,
                 SCRATCH,  or  UNKNOWN.   If  OLD   or   NEW   is
                 specified,  a FILE= specifier must be given.  If
                 OLD is specified, the file must exist.   If  NEW
                 is   specified,   the   file   must  not  exist.
                 Successful execution of an OPEN  statement  with
                 NEW  specified  creates the file and changes the
                 status  to  OLD  (12.10.1.1).   If  SCRATCH   is
                 specified  with  an  unnamed  file,  the file is
                 connected to the specified unit for use  by  the
                 executable  program  but  is deleted (12.2.1) at
                 the execution of a CLOSE statement referring  to
                 the  same  unit  or  at  the  termination of the
                 executable  program.   SCRATCH   must   not   be
                 specified  with  a  named  file.   If UNKNOWN is
                 specified, the status  is  processor  dependent.
                 If this specifier is omitted, a value of UNKNOWN
                 is assumed.

          ACCESS = acc___

                 acc___ is a character expression whose  value  when
                 any trailing blanks are removed is SEQUENTIAL or
                 DIRECT.  It specifies the access method for  the
                 connection  of  the  file as being sequential or
                 direct (12.2.4).  If this specifier is  omitted,
                 the   assumed   value  is  SEQUENTIAL.   For  an
                 existing file, the specified access method  must
                 be included in the set of allowed access methods
                 for the file (12.2.4).   For  a  new  file,  the
                 processor creates the file with a set of allowed
                 access  methods  that  includes  the   specified
                 method.

          FORM = fm__

                 fm__ is a character expression  whose  value  when
                 any  trailing blanks are removed is FORMATTED or
                 UNFORMATTED.  It  specifies  that  the  file  is
                 being  connected  for  formatted  or unformatted
                 input/output, respectively.  If  this  specifier
                 is omitted, a value of UNFORMATTED is assumed if
                 the file is being connected for  direct  access,



          FORTRAN 77 Full Language                     Page 12-22







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



                 and  a value of FORMATTED is assumed if the file
                 is being connected for sequential  access.   For
                 an  existing  file,  the  specified form must be
                 included in the set of  allowed  forms  for  the
                 file  (12.2.2).   For  a new file, the processor
                 creates the file with a  set  of  allowed  forms
                 that includes the specified form.

          RECL = rl__

                 rl__ is an integer expression whose value must  be
                 positive.   It  specifies  the  length  of  each
                 record in a  file  being  connected  for  direct
                 access.   If  the  file  is  being connected for
                 formatted input/output, the length is the number
                 of  characters.   If the file is being connected
                 for  unformatted  input/output,  the  length  is
                 measured  in  processor-dependent units.  For an
                 existing file, the value of rl__ must be  included
                 in  the  set  of  allowed record lengths for the
                 file (12.2.2).  For a new  file,  the  processor
                 creates  the  file  with a set of allowed record
                 lengths that includes the specified value.  This
                 specifier  must  be  given  when a file is being
                 connected for direct access; otherwise, it  must
                 be omitted.

          BLANK = blnk____

                 blnk____ is a character expression whose value  when
                 any trailing blanks are removed is NULL or ZERO.
                 If NULL is specified, all  blank  characters  in
                 numeric  formatted input fields on the specified
                 unit are ignored, except that  a  field  of  all
                 blanks   has  a  value  of  zero.   If  ZERO  is
                 specified, all blanks other than leading  blanks
                 are  treated  as  zeros.   If  this specifier is
                 omitted, a  value  of  NULL  is  assumed.   This
                 specifier  is  permitted  only  for a file being
                 connected for formatted input/output.

          The unit specifier is required  to  appear;  all  other
          specifiers are optional, except that the record length rl
          __ must be specified if a file is being  connected  for
          direct  access.   Note  that some of the specifications
          have an assumed value if they are omitted.

          The unit specified must exist.

          A unit  may  be  connected  by  execution  of  an  OPEN
          statement  in any program unit of an executable program



          FORTRAN 77 Full Language                     Page 12-23







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          and, once connected, may be referenced in  any  program
          unit of the executable program.

          12.10.1.1  Open_of_a_Connected_Unit.   If  a  unit   is
          connected  to  a file that exists, execution of an OPEN
          statement for that unit is  permitted.   If  the  FILE=
          specifier  is  not  included in the OPEN statement, the
          file to be connected to the unit is  the  same  as  the
          file to which the unit is connected.

          If the file to be connected to the unit does not exist,
          but  is  the  same  as  the  file  to which the unit is
          preconnected, the  properties  specified  by  the  OPEN
          statement become a part of the connection.

          If the file to be connected to the unit is not the same
          as  the file to which the unit is connected, the effect
          is as if a CLOSE statement (12.10.2) without a  STATUS=
          specifier  had  been  executed for the unit immediately
          prior to the execution of the OPEN statement.

          If the file to be connected to the unit is the same  as
          the  file  to  which  the  unit  is connected, only the
          BLANK= specifier may have a value  different  from  the
          one   currently  in  effect.   Execution  of  the  OPEN
          statement causes the new value of the BLANK=  specifier
          to   be  in  effect.   The  position  of  the  file  is
          unaffected.

          If a file is connected to a unit, execution of an  OPEN
          statement  on  that  file  and  a different unit is not
          permitted.

          12.10.2  CLOSE_Statement.  A CLOSE statement is used to
          terminate  the  connection  of  a  particular file to a
          unit.

          The form of a CLOSE statement is:

                               CLOSE (cllist______)

          where cllist______ is a list (2.10) of specifiers:

8                              ______________

                               [UNIT =] u_
                               IOSTAT = ios___
                               ERR = s_
                               STATUS = sta___
8                              ______________
7                             |8|7|7|7|7|



9                                           |8|7|7|7|7|





9



          FORTRAN 77 Full Language                     Page 12-24







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          cllist______ must contain exactly one external unit specifier
          (12.3.3)  and  may  contain  at most one of each of the
          other specifiers.

          The other specifiers are described as follows:

          IOSTAT = ios___

                 is  an  input/output  status  specifier  (12.7).
                 Execution  of  a CLOSE statement containing this
                 specifier causes ios___ to become  defined  with  a
                 zero  value if no error condition exists or with
                 a processor-dependent positive integer value  if
                 an error condition exists.

          ERR = s_

                 is an error specifier (12.7.1).

          STATUS = sta___

                 sta___ is a character expression whose  value  when
                 any  trailing  blanks  are  removed  is  KEEP or
                 DELETE.  sta___ determines the disposition  of  the
                 file  that  is  connected to the specified unit.
                 KEEP must not be  specified  for  a  file  whose
                 status prior to execution of the CLOSE statement
                 is SCRATCH.   If KEEP is specified  for  a  file
                 that  exists,  the file continues to exist after
                 the execution of the CLOSE statement.   If  KEEP
                 is specified for a file that does not exist, the
                 file will not exist after the execution  of  the
                 CLOSE  statement.   If  DELETE is specified, the
                 file will not exist after execution of the CLOSE
                 statement.   If  this  specifier is omitted, the
                 assumed value is KEEP, unless  the  file  status
                 prior  to  execution  of  the CLOSE statement is
                 SCRATCH, in which  case  the  assumed  value  is
                 DELETE.

          Execution of a CLOSE statement that refers  to  a  unit
          may  occur in any program unit of an executable program
          and need not occur in the  same  program  unit  as  the
          execution of an OPEN statement referring to that unit.

          Execution of a CLOSE statement specifying a  unit  that
          does  not  exist  or  has  no  file  connected to it is
          permitted and affects no file.

          After a unit has been disconnected by  execution  of  a
          CLOSE  statement,  it may be connected again within the



          FORTRAN 77 Full Language                     Page 12-25







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          same executable program, either to the same file or  to
          a  different  file.  After a file has been disconnected
          by execution of a CLOSE statement, it may be  connected
          again within the same executable program, either to the
          same unit or to a different  unit,  provided  that  the
          file still exists.

          12.10.2.1  Implicit_Close_at_Termination_of_Execution.
          At  termination  of  execution of an executable program
          for reasons other than an error  condition,  all  units
          that  are  connected  are  closed.  Each unit is closed
          with status  KEEP  unless  the  file  status  prior  to
          termination of execution was SCRATCH, in which case the
          unit is closed  with  status  DELETE.   Note  that  the
          effect is as though a CLOSE statement without a STATUS=
          specifier were executed on each connected unit.

          12.10.3  INQUIRE_Statement.  An INQUIRE  statement  may
          be  used  to  inquire  about properties of a particular
          named file or of the connection to a  particular  unit.
          There  are  two forms of the INQUIRE statement: inquire
          by file and inquire by unit.  All value assignments are
          done according to the rules for assignment statements.

          The INQUIRE statement may be executed before, while, or
          after  a  file  is  connected  to  a  unit.  All values
          assigned by the INQUIRE statement are  those  that  are
          current at the time the statement is executed.

          12.10.3.1  INQUIRE_by_File.  The form of an INQUIRE  by
          file statement is:

                               INQUIRE (iflist______)

          where iflist______ is a list (2.10) of specifiers  that  must
          contain  exactly  one  file  specifier  and may contain
          other inquiry specifiers.  The iflist______  may  contain  at
          most one of each of the inquiry specifiers described in
          12.10.3.3.

          The form of a file specifier is:

                               FILE = fin___

          where fin___ is a character expression  whose  value  when
          any  trailing  blanks are removed specifies the name of
          the file being inquired about.  The named file need not
          exist or be connected to a unit.  The value of fin___ must
          be of a form acceptable to  the  processor  as  a  file
          name.




          FORTRAN 77 Full Language                     Page 12-26







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          12.10.3.2  INQUIRE_by_Unit.  The form of an INQUIRE  by
          unit statement is:

                               INQUIRE (iulist______)

          where iulist______ is a list (2.10) of specifiers  that  must
          contain  exactly  one  external unit specifier (12.3.3)
          and may contain other inquiry specifiers.  The iulist____ _ _
          may  contain  at  most  one  of  each  of  the  inquiry
          specifiers described in 12.10.3.3.  The unit  specified
          need  not  exist  or  be connected to a file.  If it is
          connected to a file, the inquiry is  being  made  about
          the connection and about the file connected.

          12.10.3.3  Inquiry_Specifiers.  The  following  inquiry
          specifiers  may  be  used in either form of the INQUIRE
          statement:

8                            ___________________

                             IOSTAT = ios___
                             ERR = s_
                             EXIST = ex__
                             OPENED = od__
                             NUMBER = num___
                             NAMED = nmd___
                             NAME = fn__
                             ACCESS = acc___
                             SEQUENTIAL = seq___
                             DIRECT = dir___
                             FORM = fm__
                             FORMATTED = fmt___
                             UNFORMATTED = unf___
                             RECL = rcl___
                             NEXTREC = nr__
                             BLANK = blnk____
8                            ___________________
7                           |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















9                                              |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|

















9          The specifiers are described as follows:

          IOSTAT = ios___

                 is  an  input/output  status  specifier  (12.7).
                 Execution  of  an  INQUIRE  statement containing
                 this specifier causes ios___ to become defined with
                 a  zero  value  if  no error condition exists or
                 with  a  processor-dependent  positive   integer
                 value if an error condition exists.

          ERR = s_





          FORTRAN 77 Full Language                     Page 12-27







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



                 is an error specifier (12.7.1).

          EXIST = ex__

                 ex__  is  a  logical  variable  or  logical  array
                 element.    Execution  of  an  INQUIRE  by  file
                 statement causes ex__ to  be  assigned  the  value
                 true  if  there exists a file with the specified
                 name; otherwise, ex__ is assigned the value false.
                 Execution of an INQUIRE by unit statement causes
                 ex_ _  to  be  assigned  the  value  true  if  the
                 specified unit exists; otherwise, ex__ is assigned
                 the value false.

          OPENED = od__

                 od__  is  a  logical  variable  or  logical  array
                 element.    Execution  of  an  INQUIRE  by  file
                 statement causes od__ to  be  assigned  the  value
                 true  if  the  file  specified is connected to a
                 unit; otherwise, od__ is assigned the value false.
                 Execution of an INQUIRE by unit statement causes
                 od_ _  to  be  assigned  the  value  true  if  the
                 specified   unit   is   connected   to  a  file;
                 otherwise, od__ is assigned the value false.

          NUMBER = num___

                 num___ is an  integer  variable  or  integer  array
                 element  that  is  assigned  the  value  of  the
                 external unit identifier of  the  unit  that  is
                 currently connected to the file.  If there is no
                 unit  connected  to  the  file,  num_ _ _  becomes
                 undefined.

          NAMED = nmd___

                 nmd___ is  a  logical  variable  or  logical  array
                 element  that  is assigned the value true if the
                 file has a name; otherwise, it is  assigned  the
                 value false.

          NAME = fn__

                 fn__ is a character variable  or  character  array
                 element  that  is assigned the value of the name
                 of the file, if the file has a name;  otherwise,
                 it   becomes   undefined.   Note  that  if  this
                 specifier  appears  in  an   INQUIRE   by   file
                 statement, its value is not necessarily the same
                 as the name given in the FILE=  specifier.   For



          FORTRAN 77 Full Language                     Page 12-28







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



                 example,  the  processor  may return a file name
                 qualified by a  user  identification.   However,
                 the  value  returned must be suitable for use as
                 the value  of  a  FILE=  specifier  in  an  OPEN
                 statement.

          ACCESS = acc___

                 acc___ is a character variable or character  array#
                 element that is assigned the value SEQUENTIAL if
                 the file is connected for sequential access, and
                 DIRECT  if  the  file  is  connected  for direct
                 access.  If there is no connection, acc___  becomes
                 undefined.

          SEQUENTIAL = seq___

                 seq___ is a character variable or  character  array
                 element  that  is  assigned  the  value  YES  if
                 SEQUENTIAL is included in  the  set  of  allowed
                 access methods for the file, NO if SEQUENTIAL is
                 not  included  in  the  set  of  allowed  access
                 methods   for  the  file,  and  UNKNOWN  if  the
                 processor is unable to determine whether or  not
                 SEQUENTIAL  is  included  in  the set of allowed
                 access methods for the file.

          DIRECT = dir___

                 dir___ is a character variable or  character  array
                 element that is assigned the value YES if DIRECT
                 is included in the set of allowed access methods
                 for  the  file,  NO if DIRECT is not included in
                 the set of allowed access methods for the  file,
                 and  UNKNOWN  if  the  processor  is  unable  to
                 determine whether or not DIRECT is  included  in
                 the set of allowed access methods for the file.

          FORM = fm__

                 fm__ is a character variable  or  character  array
                 element  that is assigned the value FORMATTED if
                 the   file   is    connected    for    formatted
                 input/output,   and   is   assigned   the  value
                 UNFORMATTED  if  the  file  is   connected   for
                 unformatted   input/output.    If  there  is  no
                 connection, fm__ becomes undefined.

          FORMATTED = fmt___





          FORTRAN 77 Full Language                     Page 12-29







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



                 fmt___ is a character variable or  character  array
                 element  that  is  assigned  the  value  YES  if
                 FORMATTED is included  in  the  set  of  allowed
                 forms  for  the  file,  NO  if  FORMATTED is not
                 included in the set of  allowed  forms  for  the
                 file,  and UNKNOWN if the processor is unable to
                 determine whether or not FORMATTED  is  included
                 in the set of allowed forms for the file.

          UNFORMATTED = unf___

                 unf___ is a character variable or  character  array
                 element  that  is  assigned  the  value  YES  if
                 UNFORMATTED is included in the  set  of  allowed
                 forms  for  the  file,  NO if UNFORMATTED is not
                 included in the set of  allowed  forms  for  the
                 file,  and UNKNOWN if the processor is unable to
                 determine whether or not UNFORMATTED is included
                 in the set of allowed forms for the file.

          RECL = rcl___

                 rcl___ is an  integer  variable  or  integer  array
                 element that is assigned the value of the record
                 length of the file connected for direct  access.
                 If   the   file   is   connected  for  formatted
                 input/output,  the  length  is  the  number   of
                 characters.    If  the  file  is  connected  for
                 unformatted input/output, the length is measured
                 in  processor-dependent  units.   If there is no
                 connection or  if  the  connection  is  not  for
                 direct access, rcl___ becomes undefined.

          NEXTREC = nr__

                 nr__ is  an  integer  variable  or  integer  array
                 element  that is assigned the value n_+1, where n_
                 is the record number of the last record read  or
                 written on the file connected for direct access.
                 If the file is connected  but  no  records  have
                 been read or written since the connection, nr__ is
                 assigned the  value  1.   If  the  file  is  not
                 connected  for  direct access or if the position
                 of  the  file  is  indeterminate  because  of  a
                 previous error condition, nr__ becomes undefined.

          BLANK = blnk____

                 blnk____ is a character variable or character  array
                 element  assigned  the  value NULL if null blank
                 control is in effect for the file connected  for



          FORTRAN 77 Full Language                     Page 12-30







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



                 formatted  input/output,  and  is  assigned  the
                 value ZERO if zero blank control  is  in  effect
                 for    the    file   connected   for   formatted
                 input/output.  If there is no connection, or  if
                 the    connection    is    not   for   formatted
                 input/output, blnk____ becomes undefined.

          A variable or array element that may become defined  or
          undefined  as  a result of its use as a specifier in an
          INQUIRE statement, or any associated entity,  must  not
          be  referenced  by  any  other  specifier  in  the same
          INQUIRE statement.

          Execution of an INQUIRE by file  statement  causes  the
          specifier  variables  or  array  elements nmd, fn, seq,
          dir, fmt, and unf to be assigned  values  only  if  the
          value  of  fin___ is acceptable to the processor as a file
          name  and  if  there  exists  a  file  by  that   name;
          otherwise,  they  become  undefined.   Note  that  num___
          becomes defined it and only if od__ becomes defined  with
          the value true.  Note also that the specifier variables
          or array elements acc, fm, rcl, nr, and blnk may become
          defined only if od__ becomes defined with the value true.

          Execution of an INQUIRE by unit  statement  causes  the
          specifier  variables  or  array  elements num, nmd, fn,
          acc, seq, dir, fm, fmt, unf, rcl, nr, and  blnk  to  be
          assigned  values  only if the specified unit exists and
          if a file is connected to  the  unit;  otherwise,  they
          become undefined.

          If an error condition occurs  during  execution  of  an
          INQUIRE   statement,   all  of  the  inquiry  specifier
          variables  and  array  elements  except  ios_ _ _  become
          undefined.

          Note that the specifier variables or array elements ex_ _
          and  od__ always become defined unless an error condition
          occurs.

          12.10.4  File_Positioning_Statements.  The forms of the
          file positioning statements are:

                     BACKSPACE u_
                     BACKSPACE (alist_____)

                     ENDFILE u_
                     ENDFILE (alist_____)

                     REWIND u_
                     REWIND (alist_____)



          FORTRAN 77 Full Language                     Page 12-31







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          where: u_   is an external unit identifier (12.3.3)

                 alist_____ is a list (2.20) of specifiers:

8                              ______________

                               [ UNIT =] u_
                               IOSTAT = ios___
                               ERR = s_
8                              ______________
7                             |8|7|7|7|


9                                           |8|7|7|7|




9          alist_____ must contain exactly one external unit  specifier
          (12.3.3)  and  may  contain  at most one of each of the
          other specifiers.

          The external unit specified by a BACKSPACE, ENDFILE, or
          REWIND  statement  must  be  connected  for  sequential
          access.

          Execution of a file positioning statement containing an
          input/output  status  specifier  causes  ios___ to become
          defined with a zero value if no error condition  exists
          or with a processor-dependent positive integer value if
          an error condition exists.

          12.10.4.1  BACKSPACE_Statement.    Execution    of    a
          BACKSPACE  statement  causes  the file connected to the
          specified unit to be positioned  before  the  preceding
          record.   If there is no preceding record, the position
          of the file is not changed.  Note that if the preceding
          record   is   an   endfile  record,  the  file  becomes
          positioned before the endfile record.

          Backspacing a file that is connected but does not exist
          is prohibited.

          Backspacing over records  written  using  list-directed
          formatting is prohibited.

          12.10.4.2  ENDFILE_Statement.  Execution of an  ENDFILE
          statement  writes  an endfile record as the next record
          of the file.  The file is  then  positioned  after  the
          endfile  record.  If the file may also be connected for
          direct access, only those records  before  the  endfile
          record are considered to have been written.  Thus, only
          those records may  be  read  during  subsequent  direct
          access connections to the file.

          After execution of an ENDFILE statement, a BACKSPACE or
          REWIND  statement  must  be used to reposition the file
          prior to execution of any  data  transfer  input/output
          statement.



          FORTRAN 77 Full Language                     Page 12-32







          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4



          Execution of an ENDFILE statement for a  file  that  is
          connected but does not exist creates the file.

          12.10.4.3  REWIND_Statement.   Execution  of  a  REWIND
          statement causes the specified file to be positioned at
          its initial point.  Note that if the  file  is  already
          positioned  at  its  initial  point,  execution of this
          statement has no effect on the position of the file.

          Execution of a REWIND statement  for  a  file  that  is
          connected  but  does  not exist is permitted but has no
          effect.

          12.11  Restrictions on Function References and List
                 Items

          A function must not be referenced within an  expression
          appearing anywhere in an input/output statement if such
          a reference causes  an  input/output  statement  to  be
          executed.  Note that a restriction in the evaluation of
          expressions (6.6) prohibits certain side effects.

          12.12  Restriction_on_Input/Output_Statements

          If a unit, or a file connected to a unit, does not have
          all  of  the  properties  required for the execution of
          certain input/output statements, those statements  must
          not refer to the unit.


























          FORTRAN 77 Full Language                     Page 12-33











                                 CONTENTS


          12.  INPUT/OUTPUT STATEMENTS....................   12-1
               12.1   Records.............................   12-1
                      12.1.1   Formatted Record...........   12-2
                      12.1.2   Unformatted Record.........   12-2
                      12.1.3   Endfile Record.............   12-2
               12.2   Files...............................   12-2
                      12.2.1   File Existence.............   12-2
                      12.2.2   File Properties............   12-3
                      12.2.3   File Position..............   12-3
                      12.2.4   File Access................   12-4
                      12.2.5   Internal Files.............   12-5
               12.3   Units...............................   12-7
                      12.3.1   Unit Existence.............   12-7
                      12.3.2   Connection of a
                               Unit.......................   12-7
                      12.3.3   Unit Specifier and
                               Identifier.................   12-8
               12.4   Format Specifier and
                      Identifier..........................   12-9
               12.5   Record Specifier....................   12-9
               12.6   Error and End-of-File
                      Conditions..........................  12-10
               12.7   Input/Output Status, Error, and
                      End-of-File Specifiers..............  12-11
                      12.7.1   Error Specifier............  12-11
                      12.7.2   End-of-File
                               Specifier..................  12-12
               12.8   READ, WRITE, and PRINT
                      Statements..........................  12-12
                      12.8.1   Control Information
                               List.......................  12-13
                      12.8.2   Input/Output List..........  12-14
               12.9   Execution of a Data Transfer
                      Input/Output Statement..............  12-15
                      12.9.1   Direction of Data
                               Transfer...................  12-16
                      12.9.2   Identifying a Unit.........  12-16
                      12.9.3   Establishing a
                               Format.....................  12-16
                      12.9.4   File Position Prior to
                               Data Transfer..............  12-17
                      12.9.5   Data Transfer..............  12-17
                      12.9.6   File Position After Data
                               Transfer...................  12-20
                      12.9.7   Input/Output Status
                               Specifier
                               Definition.................  12-20




                                   - i -











               12.10  Auxiliary Input/Output
                      Statements..........................  12-21
                      12.10.1  OPEN Statement.............  12-21
                      12.10.2  CLOSE Statement............  12-24
                      12.10.3  INQUIRE Statement..........  12-26
                      12.10.4  File Positioning
                               Statements.................  12-31
               12.11  Restrictions on Function References
                      and List Items......................  12-33
               12.12  Restriction on Input/Output
                      Statements..........................  12-33











































                                  - ii -







                                                   ANSI X3J3/90.4



                         13.  FORMAT_SPECIFICATION

          A   format   used   in   conjunction   with   formatted
          input/output   statements   provides  information  that
          directs the editing between the internal representation
          and  the character strings of a record or a sequence of
          records in the file.

          A  format  specification  provides   explicit   editing
          information.  An asterisk (*) as a format identifier in
          an  input/output  statement   indicates   list-directed
          formatting (13.6).

          13.1  Format_Specification_Methods

          Format specifications may be given:

             (1) In FORMAT statements

             (2) As  values  of   character   arrays,   character
                 variables, or other character expressions

          13.1.1  FORMAT_Statement.   The  form   of   a   FORMAT
          statement is:

                               FORMAT fs__

          where fs__ is a format  specification,  as  described  in
          13.2.  The statement must be labeled.

          13.1.2  Character_Format_Specification.  If the  format
          identifier (12.4) in a formatted input/output statement
          is a character array name, character variable name,  or
          other  character  expression,  the  leftmost  character
          positions of the specified entity must be in a  defined
          state  with  character  data  that  constitute a format
          specification when the statement is executed.

          A character format specification must be  of  the  form
          described  in  13.2.   Note that the form begins with a
          left parenthesis and ends  with  a  right  parenthesis.
          Character  data  may  follow the right parenthesis that
          ends the format specification, with no  effect  on  the
          format specification.  Blank characters may precede the
          format specification.

          If the format identifier is a character array name, the
          length  of  the  format  specification  may  exceed the
          length of the first element of the array;  a  character
          array  format  specification  is  considered  to  be  a
          concatenation of all the array elements of the array in



          FORTRAN 77 Full Language                      Page 13-1







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



          the  order  given  by  array  element ordering (5.2.4).
          However, if a character array element name is specified
          as  a  format  identifier,  the  length  of  the format
          specification must not exceed the length of  the  array
          element.

          13.2  Form_of_a_Format_Specification

          The form of a format specification is:

                               ( [flist_____] )

          where flist_____ is a list (2.10).  The forms of the flist___ _ _
          items are:

                               [r_] ed__

                                   ned___

                               [r_] fs__

          where: ed__  is a repeatable edit descriptor (13.2.1)

                 ned___ is a nonrepeatable edit descriptor (13.2.1)

                 fs__  is a format specification  with  a  nonempty
                     list flist_____

                 r_   is a  nonzero,  unsigned,  integer  constant
                     called a repeat______ specification_____________

          The comma used to separate list items in the list flist_____
          may be omitted as follows:

             (1) Between a P edit descriptor and  an  immediately
                 following F, E, D, or G edit descriptor (13.5.9)

             (2) Before or after a slash edit descriptor (13.5.4)

             (3) Before or after a colon edit descriptor (13.5.5)

          13.2.1  Edit_Descriptors.  An edit descriptor is either
          a  repeatable  edit  descriptor or a nonrepeatable edit
          descriptor.

          The forms of a repeatable edit descriptor are:

                     Iw_
                     Iw_.m_
                     Fw_.d_
                     Ew_.d_



          FORTRAN 77 Full Language                      Page 13-2







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



                     Ew_.d_Ee_
                     Dw_.d_
                     Gw_.d_
                     Gw_.d_Ee_
                     Lw_
                     A
                     Aw_

          where: I, F, E, D, G, L, and A indicate the  manner  of
                     editing

                 w_ and e_ are nonzero, unsigned, integer constants

                 d_ and m_ are unsigned integer constants

          The forms of a nonrepeatable edit descriptor are:

                     'h_918 h_928 ... h_9n8'
                     n_Hh_918h_928 ... h_9n
8                     Tc_
                     TLc_
                     TRc_
                     n_X
                     /
                     :
                     S
                     SP
                     SS
                     k_P
                     BN
                     BZ

          where: apostrophe, H, T, TL, TR, X,  slash,  colon,  S,
                     SP, SS, P, BN, and BZ indicate the manner of
                     editing

                 h_   is  one  of  the  characters   capable   of
                     representation by the processor

                 n_   and  c_  are  nonzero,  unsigned,   integer
                     constants

                 k_   is an optionally signed integer constant

          13.3  Interaction_Between_Input/Output_List_and_Format

          The beginning of formatted data transfer using a format
          specification  (12.9.5.2.1)  initiates  format control.
          Each action of format control  depends  on  information
          jointly provided by:




          FORTRAN 77 Full Language                      Page 13-3







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



             (1) the next edit descriptor contained in the format
                 specification, and

             (2) the next item in the input/output list,  if  one
                 exists.

          If an input/output list specifies  at  least  one  list
          item,  at  least  one  repeatable  edit descriptor must
          exist in the format specification.  Note that an  empty
          format  specification  of the form ( ) may be used only
          if no list items are specified; in this case, one input
          record  is  skipped  or one output record containing no
          characters is written.  Except for an  edit  descriptor
          preceded  by a repeat specification, r_ ed__, and a format
          specification preceded by a repeat specification, r_(flist___
          __), a format specification is interpreted from left to
          right.   A  format  specification  or  edit  descriptor
          preceded  by a repeat specification r_ is processed as a
          list of r_ format  specifications  or  edit  descriptors
          identical   to   the   format   specification  or  edit
          descriptor without the repeat specification.  Note that
          an  omitted repeat specification is treated the same as
          a repeat specification whose value is one.

          To each repeatable edit  descriptor  interpreted  in  a
          format   specification,   there  corresponds  one  item
          specified by the  input/output  list  (12.8.2),  except
          that   a   list  item  of  type  complex  requires  the
          interpretation of two F, E, D, or G  edit  descriptors.
          To  each  P, X, T, TL, TR, S, SP, SS, H, BN, BZ, slash,
          colon, or  apostrophe  edit  descriptor,  there  is  no
          corresponding  item specified by the input/output list,
          and format control  communicates  information  directly
          with the record.

          Whenever format control encounters  a  repeatable  edit
          descriptor  in  a  format  specification, it determines
          whether there is a corresponding item specified by  the
          input/output  list.   If  there  is  such  an  item, it
          transmits appropriately edited information between  the
          item  and the record, and then format control proceeds.
          If there  is  no  corresponding  item,  format  control
          terminates.

          If format control encounters a colon edit descriptor in
          a  format  specification  and  another list item is not
          specified, format control terminates.

          If format control encounters the rightmost  parenthesis
          of  a  complete  format  specification and another list
          item  is  not  specified,  format  control  terminates.



          FORTRAN 77 Full Language                      Page 13-4







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



          However, if another list item is specified, the file is
          positioned at the beginning  of  the  next  record  and
          format  control  then  reverts  to the beginning of the
          format specification terminated by the  last  preceding
          right parenthesis.  If there is no such preceding right
          parenthesis, format control reverts to the  first  left
          parenthesis  of  the  format  specification.   If  such
          reversion occurs, the  reused  portion  of  the  format
          specification must contain at least one repeatable edit
          descriptor.  If format control reverts to a parenthesis
          that  is preceded by a repeat specification, the repeat
          specification is reused.  Reversion of format  control,
          of  itself, has no effect on the scale factor (13.5.7),
          the S, SP, or SS edit descriptor sign control (13.5.6),
          or the BN or BZ edit descriptor blank control (13.5.8).

          13.4  Positioning_by_Format_Control

          After each I, F, E, D, G, L, A, H, or  apostrophe  edit
          descriptor  is  processed, the file is positioned after
          the last character  read  or  written  in  the  current
          record.

          After each T, TL, TR,  X, or slash edit  descriptor  is
          processed,  the  file  is  positioned  as  described in
          13.5.3 and 13.5.4.

          If format control reverts as  described  in  13.3,  the
          file  is positioned in a manner identical to the way it
          is positioned when a slash edit descriptor is processed
          (13.5.4).

          During a read operation, any unprocessed characters  of
          the  record  are  skipped  whenever  the next record is
          read.

          13.5  Editing

          Edit descriptors are used to  specify  the  form  of  a
          record and to direct the editing between the characters
          in a record and internal representations of data.

          A field is a part of a record that is read on input  or
          written  on output when format control processes one I,
          F, E, D, G, L, A, H,  or  apostrophe  edit  descriptor.
          The field width is the size in characters of the field.

          The internal representation of a datum  corresponds  to
          the  internal  representation  of  a  constant  of  the
          corresponding type (Section 4).




          FORTRAN 77 Full Language                      Page 13-5







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



          13.5.1  Apostrophe_Editing.    The   apostrophe    edit
          descriptor  has  the  form of a character constant.  It
          causes characters  to  be  written  from  the  enclosed
          characters  (including  blanks)  of the edit descriptor
          itself.  An apostrophe edit descriptor must not be used
          on input.

          The width of the field  is  the  number  of  characters
          contained   in,   but  not  including,  the  delimiting
          apostrophes.   Within  the   field,   two   consecutive
          apostrophes with no intervening blanks are counted as a
          single apostrophe.

          13.5.2  H_Editing.  The  n_ H  edit  descriptor  causes
          character   information  to  be  written  from  the  n_
          characters (including blanks) following the H of the n_H
          edit descriptor in the format specification itself.  An
          H edit descriptor must not be used on input.

          Note that if an  H  edit  descriptor  occurs  within  a
          character  constant  and  includes  an  apostrophe, the
          apostrophe  must  be  represented  by  two  consecutive
          apostrophes,  which  are  counted  as  one character in
          specifying n_.

          13.5.3  Positional_Editing.  The T, TL, TR, and X  edit
          descriptors  specify  the  position  at  which the next
          character will be transmitted to or from the record.

          The position specified by a T edit descriptor may be in
          either  direction from the current position.  On input,
          this allows portions of a record to be  processed  more
          than once, possibly with different editing.

          The position specified  by  an  X  edit  descriptor  is
          forward   from  the  current  position.   On  input,  a
          position beyond the last character of the record may be
          specified  if  no  characters are transmitted from such
          positions.

          On output, a T, TL, TR, or X edit descriptor  does  not
          by  itself  cause  characters  to  be  transmitted  and
          therefore does not by itself affect the length  of  the
          record.   If characters are transmitted to positions at
          or after the position specified by a T, TL,  TR,  or  X
          edit  descriptor,  positions skipped and not previously
          filled are filled with blanks.  The result is as if the
          entire record were initially filled with blanks.

          On output, a character in the record may  be  replaced.
          However,  a  T,  TL,  TR,  or  X  edit descriptor never



          FORTRAN 77 Full Language                      Page 13-6







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



          directly causes  a  character  already  placed  in  the
          record  to  be  replaced.   Such  edit  descriptors may
          result in positioning so that subsequent editing causes
          a replacement.

          13.5.3.1  T,_TL,_and_TR_Editing.    The   Tc  _    edit
          descriptor  indicates that the transmission of the next
          character to or from a record is to occur at the  c_ th
          character position.

          The TLc_ edit descriptor indicates that the transmission
          of the next character to or from the record is to occur
          at the character position c_  characters  backward  from
          the current position.  However, if the current position
          is less than or equal to position c_ ,  the  TLc_  edit
          descriptor  indicates that the transmission of the next
          character to or from the record is to occur at position
          one of the current record.

          The TRc_ edit descriptor indicates that the transmission
          of the next character to or from the record is to occur
          at the character position c_ characters forward from the
          current position.

          13.5.3.2  X_Editing.  The n_X edit descriptor  indicates
          that  the transmission of the next character to or from
          a record is to occur  at  the  position  n_  characters
          forward from the current position.

          13.5.4  Slash_Editing.   The  slash   edit   descriptor
          indicates  the  end  of  data  transfer  on the current
          record.

          On input from a file connected for  sequential  access,
          the  remaining portion of the current record is skipped
          and the file is positioned at the beginning of the next
          record.   This  record  becomes the current record.  On
          output to a file connected for sequential access, a new
          record  is  created  and  becomes  the last and current
          record of the file.

          Note that a record that contains no characters  may  be
          written  on output.  If the file is an internal file or
          a file connected  for  direct  access,  the  record  is
          filled with blank characters.  Note also that an entire
          record may be skipped on input.

          For a file connected  for  direct  access,  the  record
          number  is  increased by one and the file is positioned
          at the beginning of the record  that  has  that  record
          number.  This record becomes the current record.



          FORTRAN 77 Full Language                      Page 13-7







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



          13.5.5  Colon_Editing.   The  colon   edit   descriptor
          terminates format control if there are no more items in
          the  input/output  list   (13.3).    The   colon   edit
          descriptor has no effect if there are more items in the
          input/output list.

          13.5.6  S,_SP,_and_SS_Editing.  The S, SP, and SS  edit
          descriptors  may  be  used  to  control  optional  plus
          characters in numeric output fields.  At the  beginning
          of  execution  of  each formatted output statement, the
          processor has the option of producing a plus in numeric
          output fields.  If an SP edit descriptor is encountered
          in a format specification, the processor must produce a
          plus  in any subsequent position that normally contains
          an  optional  plus.   If  an  SS  edit  descriptor   is
          encountered,  the  processor must not produce a plus in
          any  subsequent  position  that  normally  contains  an
          optional plus.  If an S edit descriptor is encountered,
          the option of producing the plus  is  restored  to  the
          processor.

          The S, SP, and SS edit descriptors affect only I, F, E,
          D,  and  G  editing  during  the execution of an output
          statement.  The S, SP, and SS edit descriptors have  no
          effect during the execution of an input statement.

          13.5.7  P_Editing.  A scale factor is specified by a  P
          edit descriptor, which is of the form:

                               k_P

          where k_  is  an  optionally  signed  integer  constant,
          called the scale factor.

          13.5.7.1  Scale_Factor.  The value of the scale  factor
          is   zero   at  the  beginning  of  execution  of  each
          input/output statement.  It applies to all subsequently
          interpreted  F,  E,  D,  and  G  edit descriptors until
          another scale factor  is  encountered,  and  then  that
          scale  factor  is  established.  Note that reversion of
          format control (13.3) does not affect  the  established
          scale factor.

          The scale factor k_ affects the appropriate  editing  in
          the following manner:

             (1) On input, with F, E, D, and G editing  (provided
                 that  no  exponent  exists  in  the field) and F
                 output editing, the scale factor effect is  that
                 the  externally  represented  number  equals the
                 internally represented number multiplied by 10**k



          FORTRAN 77 Full Language                      Page 13-8







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



                 _


             .(2) On input, with F, E,  D,  and  G  editing,  the
                 scale  factor  has  no  effect  if  there  is an
                 exponent in the field.

             (3) On output, with E and D editing, the basic  real
                 constant  (4.4.1)  part  of  the  quantity to be
                 produced is multiplied by 10**k_ and the exponent
                 is reduced by k_.

             (4) On output, with G editing,  the  effect  of  the
                 scale  factor  is suspended unless the magnitude
                 of the datum to be edited is outside  the  range
                 that  permits  the use of F editing.  If the use
                 of E editing is required, the scale  factor  has
                 the same effect as with E output editing.

          13.5.8  BN_and_BZ_Editing.   The   BN   and   BZ   edit
          descriptors  may  be used to specify the interpretation
          of blanks, other than leading blanks, in numeric  input
          fields.    At   the  beginning  of  execution  of  each
          formatted input statement, such  blank  characters  are
          interpreted  as  zeros or are ignored, depending on the
          value of the BLANK= specifier  (12.10.1)  currently  in
          effect  for  the  unit.   If  a  BN  edit descriptor is
          encountered in a format specification, all  such  blank
          characters  in  succeeding  numeric  input  fields  are
          ignored.  The effect of ignoring blanks is to treat the
          input   field  as  if  blanks  had  been  removed,  the
          remaining portion of the field right-justified, and the
          blanks replaced as leading blanks.  However, a field of
          all blanks has the value zero.  If a BZ edit descriptor
          is  encountered  in  a  format  specification, all such
          blank characters in succeeding numeric input fields are
          treated as zeros.

          The BN and BZ edit descriptors affect only I, F, E,  D,
          and  G  editing during execution of an input statement.
          They have no  effect  during  execution  of  an  output
          statement.

          13.5.9  Numeric_Editing.  The I, F, E, D,  and  G  edit
          descriptors   are   used  to  specify  input/output  of
          integer, real, double precision, and complex data.  The
          following general rules apply:

             (1) On input, leading blanks  are  not  significant.
                 The interpretation of blanks, other than leading
                 blanks, is determined by a  combination  of  any



          FORTRAN 77 Full Language                      Page 13-9







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



                 BLANK=  specifier and any BN or BZ blank control
                 that  is  currently  in  effect  for  the   unit
                 (13.5.8).   Plus  signs may be omitted.  A field
                 of all blanks is considered to be zero.

             (2) On input, with F, E, D, and G editing, a decimal
                 point appearing in the input field overrides the
                 portion of an edit descriptor that specifies the
                 decimal  point  location.   The  input field may
                 have more digits  than  the  processor  uses  to
                 approximate the value of the datum.

             (3) On output, the representation of a  positive  or
                 zero internal value in the field may be prefixed
                 with a plus, as controlled by the S, SP, and  SS
                 edit descriptors (13.5.6) or the processor.  The
                 representation of a negative internal  value  in
                 the   field  must  be  prefixed  with  a  minus.
                 However,  the  processor  must  not  produce   a
                 negative  signed  zero  in  a  formatted  output
                 record.

             (4) On output, the representation is right-justified
                 in  the  field.   If  the  number  of characters
                 produced by the  editing  is  smaller  than  the
                 field  width, leading blanks will be inserted in
                 the field.

             (5) On output, if the number of characters  produced
                 exceeds  the  field  width  or  if  an  exponent
                 exceeds its specified length using the Ew_.d_Ee_ or
                 Gw_.d_Ee_ edit descriptor, the processor will fill
                 the entire field of  width  w_  with  asterisks.
                 However,   the   processor   must   not  produce
                 asterisks if the field  width  is  not  exceeded
                 when optional characters are omitted.  Note that
                 when an SP edit descriptor is in effect, a  plus
                 is not optional (13.5.6).

          13.5.9.1  Integer_Editing.  The Iw_  and  Iw_ .m_  edit
          descriptors  indicate  that  the  field  to  be  edited
          occupies w_ positions.  The specified input/output  list
          item  must be of type integer.  On input, the specified
          list item will become defined with  an  integer  datum.
          On output, the specified list item must be defined with
          an integer datum.

          On  input,  an  Iw_ .m_  edit  descriptor  is   treated
          identically to an Iw_ edit descriptor.





          FORTRAN 77 Full Language                     Page 13-10







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



          In the input field, the character string must be in the
          form  of  an optionally signed integer constant, except
          for the interpretation of blanks (13.5.9, item (1)).

          The output field for the Iw_ edit descriptor consists of
          zero  or more leading blanks followed by a minus if the
          value of the internal datum is negative, or an optional
          plus  otherwise,  followed  by  the  magnitude  of  the
          internal value in  the  form  of  an  unsigned  integer
          constant  without  leading zeros.  Note that an integer
          constant always consists of at least one digit.

          The output field for the Iw_.m_ edit  descriptor  is  the
          same  as  for  the  Iw_ edit descriptor, except that the
          unsigned integer constant consists of at least m_ digits
          and,  if  necessary, has leading zeros.  The value of m_
          must not exceed the value of w_.  If m_ is zero  and  the
          value  of  the internal datum is zero, the output field
          consists of only blank characters,  regardless  of  the
          sign control in effect.

          13.5.9.2  Real_and_Double_Precision_Editing.  The F, E,
          D,  and G edit descriptors specify the editing of real,
          double precision, and complex  data.   An  input/output
          list  item  corresponding  to  an  F,  E,  D, or G edit
          descriptor must be real, double precision, or  complex.
          An  input  list  item  will become defined with a datum
          whose type is the same as that of the  list  item.   An
          output  list  item  must  be defined with a datum whose
          type is the same as that of the list item.

          13.5.9.2.1  F_Editing.   The  Fw_ .d_  edit  descriptor
          indicates  that  the  field  occupies  w_ positions, the
          fractional part of which consists of d_ digits.

          The input field consists of an optional sign,  followed
          by  a  string of digits optionally containing a decimal
          point.  If the decimal point is omitted, the rightmost d
          _  digits  of the string, with leading zeros assumed if
          necessary, are interpreted as the  fractional  part  of
          the  value  represented.   The  string  of  digits  may
          contain  more  digits  than   a   processor   uses   to
          approximate  the value of the constant.  The basic form
          may be followed by an exponent of one of the  following
          forms:

             (1) Signed integer constant

             (2) E followed by zero or more blanks,  followed  by
                 an optionally signed integer constant




          FORTRAN 77 Full Language                     Page 13-11







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



             (3) D followed by zero or more blanks,  followed  by
                 an optionally signed integer constant

          An exponent containing a D is processed identically  to
          an exponent containing an E.

          The output field  consists  of  blanks,  if  necessary,
          followed  by a minus if the internal value is negative,
          or an optional plus otherwise, followed by a string  of
          digits that contains a decimal point and represents the
          magnitude of the internal value,  as  modified  by  the
          established  scale  factor  and rounded to d_ fractional
          digits.  Leading zeros are not permitted except for  an
          optional  zero  immediately  to the left of the decimal
          point if the magnitude of the value in the output field
          is  less  than  one.   The optional zero must appear if
          there would otherwise be no digits in the output field.

          13.5.9.2.2  E_and_D_Editing.  The Ew_.d_, Dw_.d_, and Ew_.d_Ee
          _  edit  descriptors  indicate  that the external field
          occupies w_ positions,  the  fractional  part  of  which
          consists  of  d_  digits, unless a scale factor greater
          than one is in effect, and the exponent  part  consists
          of e_ digits.  The e_ has no effect on input.

          The form of the input  field  is  the  same  as  for  F
          editing (13.5.9.2.1).

          The form of the output field for a scale factor of zero
          is:

                               [+_] [0] . x918x928...x9d8 exp___

          where: +_   signifies a plus or a minus (13.5.9)

                 x918,x928...x9d8 are the Ld_ most significant digits of
                     the value of the datum after rounding

                 exp___ is a decimal exponent, one of the  following
                     forms:














          FORTRAN 77 Full Language                     Page 13-12







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



8             _________________________________________________

              Edit         Absolute Value    Form of
              Descriptor   of Exponent       Exponent
8             _________________________________________________

              Ew_.d_         |exp___|&lt;99          E+_z_918z_928 or +_0z_918z_92
7                          ____________________________________

                           99&lt;|exp___|&lt;999      +_z_918z_928z_93
7             _________________________________________________

              Ew_.d_Ee_       |exp___|&lt;(10**e_)-1   E+_z_918z_928...z_9e
7             _________________________________________________

              Dw_.d_         |exp___|&lt;99          D+_z_918z_928 or E+_z_918z_92
8                                             or +_0z_918z_92
7                          ____________________________________

                           99&lt;|exp___|&lt;999      +_z_918z_928z_93
7             _________________________________________________
7            |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















                        |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















                                          |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















                                                             |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|

















          where z_ is a  digit.   The  sign  in  the  exponent  is
          required.   A  plus  sign  must be used if the exponent
          value is zero.  The forms Ew_.d_ and Dw_.d_  must  not  be
          used if |exp___| &gt; 999.

          The scale factor k_ controls the  decimal  normalization
          (13.5.7).   If   - d_ &lt; k_ &lt; 0, the output field contains
          exactly |k_| leading zeros and d_   -  |k_ |  significant
          digits  after the decimal point.  If 0 &lt; k_ &lt; d_ + 2, the
          output field contains exactly k_ significant  digits  to
          the left of the decimal point and d_ - k_ + 1 significant
          digits to the right of the decimal point.  Other values
          of k_ are not permitted.

          13.5.9.2.3  G_Editing.  The Gw_.d_ and  Gw_ .d_ Ee_  edit
          descriptors indicate that the external field occupies w_
          positions, the fractional part of which consists of  d_
          digits,  unless  a  scale factor greater than one is in
          effect, and the exponent part consists of e_ digits.

          G  input  editing  is  the  same  as  for   F   editing
          (13.5.9.2.1).

          The  method  of  representation  in  the  output  field
          depends  on  the  magnitude  of the datum being edited.
          Let N be the  magnitude  of  the  internal  datum.   If
          N &lt; 0.1 or N &gt; 10**d_,Gw_.d_ output editing is the same as
          k_PEw_.d_ output editing and Gw_.d_Ee_ output editing is  the
          same  as  k_PEw_.d_Ee_ output editing, where k_ is the scale
          factor currently in effect.  If N is  greater  than  or
          equal  to  0.1 and is less than 10**d_, the scale factor
          has no effect,  and  the  value  of  N  determines  the
          editing as follows:

9
          FORTRAN 77 Full Language                     Page 13-13







          FORMAT SPECIFICATION                     ANSI X3J3/90.4



8              _______________________________________________

               Magnitude of Datum      Equivalent Conversion
8              _______________________________________________

               0.1=N&lt;1                 F(w_-n_).d_, n_('b_')

               1<n<10 f(w_-n_).(d_-1), n_('b_') . . . . . . 10**(d_-2)<n<10**(d_-1) f(w_-n_).1, n_('b_') 10**(d_-1)<n<10**d_ f(w_-n_).0, n_('b_') 8 _______________________________________________ 7 |7|7|7|7|7|7|7|7|7|7|7|7|7|7| |7|7|7|7|7|7|7|7|7|7|7|7|7|7| |7|7|7|7|7|7|7|7|7|7|7|7|7|7| where: b_ is a blank n_ is 4 for gw_.d_ and e_+_2 for gw_.d_ee_ note that the scale factor has no effect unless the magnitude of the datum to be edited is outside of the range that permits effective use of f editing. 13.5.9.2.4 complex_editing. a complex datum consists of a pair of separate real data; therefore, the editing is specified by two successively interpreted f, e, d, or g edit descriptors. the first of the edit descriptors specifies the real part; the second specifies the imaginary part. the two edit descriptors may be different. note that nonrepeatable edit descriptors may appear between the two successive f, e, d, or g edit descriptors. 13.5.10 l_editing. the lw_ edit descriptor indicates that the field occupies w_ positions. the specified input output list item must be of type logical. on input, the list item will become defined with a logical datum. on output, the specified list item must be defined with a logical datum. the input field consists of optional blanks, optionally followed by a decimal point, followed by a t for true or f for false. the t or f may be followed by additional characters in the field. note that the logical constants .true. and .false. are acceptable input forms. the output field consists of w_ - 1 blanks followed by a t or f, as the value of the internal datum is true or false, respectively. 9 fortran 77 full language page 13-14 format specification ansi x3j3 90.4 13.5.11 a_editing. the a[w_] edit descriptor is used with an input output list item of type character. on input, the input list item will become defined with character data. on output, the output list item must be defined with character data. if a field width w_ is specified with the a edit descriptor, the field consists of w_ characters. if a field width w_ is not specified with the a edit descriptor, the number of characters in the field is the length of the character input output list item. let len___ be the length of the input output list item. if the specified field width w_ for a input is greater than or equal to len___, the rightmost len___ characters will be taken from the input field. if the specified field width is less than len___, the w_ characters will appear left-justified with len_ _ _ - w_ trailing blanks in the internal representation. if the specified field width w_ for a output is greater than len___, the output field will consist of w_-len___ blanks followed by the len_ _ _ characters from the internal representation. if the specified field width w_ is less than or equal to len___, the output field will consist of the leftmost w _ characters from the internal representation. 13.6 list-directed_formatting the characters in one or more list-directed records constitute a sequence of values and value separators. the end of a record has the same effect as a blank character, unless it is within a character constant. any sequence of two or more consecutive blanks is treated as a single blank, unless it is within a character constant. each value is either a constant, a null value, or of one of the forms: r_*c_ r_* where r_ is an unsigned, nonzero, integer constant. the r_ *c_ form is equivalent to r_ successive appearances of the constant c_, add the r_* form is equivalent to r_ successive appearances of the null values. neither of these forms may contain embedded blanks, except where permitted within the constant c_. fortran 77 full language page 13-15 format specification ansi x3j3 90.4 a value separator is one of the following: (1) a comma optionally preceded by one or more contiguous blanks and optionally followed by one or more contiguous blanks (2) a slash optionally preceded by one or more contiguous blanks and optionally followed by one or more contiguous blanks (3) one or more contiguous blanks between two constants or following the last constant 13.6.1 list-directed_input. input forms acceptable to format specifications for a given type are acceptable for list-directed formatting, except as noted below. the form of the input value must be acceptable for the type of the input list item. blanks are never used as zeros, and embedded blanks are not permitted in constants, except within character constants and complex constants as specified below. note that the end of a record has the effect of a blank, except when it appears within a character constant. when the corresponding input list item is of type real or double precision, the input form is that of a numeric input field. a numeric input field is a field suitable for f editing (13.5.9.2) that is assumed to have no fractional digits unless a decimal point appears within the field. when the corresponding list item is of type complex, the input form consists of a left parenthesis followed by an ordered pair of numeric input fields separated by a comma, and followed by a right parenthesis. the first numeric input field is the real part of the complex constant and the second is the imaginary part. each of the numeric input fields may be preceded or followed by blanks. the end of a record may occur between the real part and the comma or between the comma and the imaginary part. when the corresponding list item is of type logical, the input form must not include either slashes or commas among the optional characters permitted for l editing (13.5.10). when the corresponding list item is of type character, the input form consists of a nonempty string of characters enclosed in apostrophes. each apostrophe within a character constant must be represented by two fortran 77 full language page 13-16 format specification ansi x3j3 90.4 consecutive apostrophes without an intervening blank or end of record. character constants may be continued from the end of one record to the beginning of the next record. the end of the record does not cause a blank or any other character to become part of the constant. the constant may be continued on as many records as needed. the characters blank, comma, and slash may appear in character constants. let len___ be the length of the list item, and let w_ be the length of the character constant. if len___ is less than or equal to w_, the leftmost len___ characters of the constant are transmitted to the list item. if len___ is greater than w_, the constant is transmitted to the leftmost w_ characters of the list item and the remaining len___-w_ characters of the list item are filled with blanks. note that the effect is as though the constant were assigned to the list item in a character assignment statement (10.4). a null value is specified by having no characters between successive value separators, no characters preceding the first value separator in the first record read by each execution of a list-directed input statement, or the r_* form. a null value has no effect on the definition status of the corresponding input list item. if the input list item is defined, it retains its previous value; if it is undefined, it remains undefined. a null value may not be used as either the real or imaginary part of a complex constant, but a single null value may represent an entire complex constant. note that the end of a record following any other separator, with or without separating blanks, does not specify a null value. a slash encountered as a value separator during execution of a list-directed input statement causes termination of execution of that input statement after the assignment of the previous value. if there are additional items in the input list, the effect is as if null values had been supplied for them. note that all blanks in a list-directed input record are considered to be part of some value separator except for the following: (1) blanks embedded in a character constant (2) embedded blanks surrounding the real or imaginary part of a complex constant fortran 77 full language page 13-17 format specification ansi x3j3 90.4 (3) leading blanks in the first record read by each execution of a list-directed input statement, unless immediately followed by a slash or comma 13.6.2 list-directed_output. the form of the values produced is the same as that required for input, except as noted otherwise. with the exception of character constants, the values are separated by one of the following: (1) one or more blanks (2) a comma optionally preceded by one or more blanks and optionally followed by o<one or more blanks the processor may begin new records as necessary, but, except for complex constants and character constants, the end of a record must not occur within a constant and blanks must not appear within a constant. logical output constants are t for the value true and f for the value false. integer output constants are produced with the effect of an iw_ edit descriptor, for some reasonable value of w _. real and double precision constants are produced with the effect of either an f edit descriptor or an e edit descriptor, depending on the magnitude x_ of the value and a range 10**d_918 < x_ < 10**d_928, where d_918 and d_928 are processor-dependent integer values. if the magnitude x_ is within this range, the constant is produced using opfw_.d_; otherwise, 1pew_ .d_ ee_ is used. reasonable processor-dependent values of w_, d_, and e_ are used for each of the cases involved. complex constants are enclosed in parentheses, with a comma separating the real and imaginary parts. the end of a record may occur between the comma and the imaginary part only if the entire constant is as long as, or longer than, an entire record. the only embedded blanks permitted within a complex constant are between the comma and the end of a record and one blank at the beginning of the next record. character constants produced are not delimited by apostrophes, are not preceded or followed by a value separator, have each internal apostrophe represented externally by one apostrophe, and have a blank fortran 77 full language page 13-18 format specification ansi x3j3 90.4 character inserted by the processor for carriage control at the beginning of any record that begins with the continuation of a character constant from the preceding record. if two or more successive values in an output record produced have identical values, the processor has the option of producing a repeated constant of the form r_*c_ instead of the sequence of identical values. slashes, as value separators, and null values are not produced by list-directed formatting. each output record begins with a blank character to provide carriage control when the record is printed. fortran 77 full language page 13-19 contents 13. format specification....................... 13-1 13.1 format specification methods......... 13-1 13.1.1 format statement............ 13-1 13.1.2 character format specification............... 13-1 13.2 form of a format specification........................ 13-2 13.2.1 edit descriptors............ 13-2 13.3 interaction between input output list and format...................... 13-3 13.4 positioning by format control........ 13-5 13.5 editing.............................. 13-5 13.5.1 apostrophe editing.......... 13-6 13.5.2 h editing................... 13-6 13.5.3 positional editing.......... 13-6 13.5.4 slash editing............... 13-7 13.5.5 colon editing............... 13-8 13.5.6 s, sp, and ss editing..................... 13-8 13.5.7 p editing................... 13-8 13.5.8 bn and bz editing........... 13-9 13.5.9 numeric editing............. 13-9 13.5.10 l editing................... 13-14 13.5.11 a editing................... 13-15 13.6 list-directed formatting............. 13-15 13.6.1 list-directed input......... 13-16 13.6.2 list-directed output........ 13- 18 - i - ansi x3j3 90.4 14. main_program a main program is a program unit that does not have a function, subroutine, or block data statement as its first statement. it may have a program statement as its first statement. there must be exactly one main program in an executable program. execution of an executable program begins with the execution of the first executable statement of the main program. 14.1 program_statement the form of a program statement is: program pgm___ where pgm___ is the symbolic name of the main program in which the program statement appears. a program statement is not required to appear in an executable program. if it does appear, it must be the first statement of the main program. the symbolic name pgm_ _ _ is global (18.1.1) to the executable program and must not be the same as the name of an external procedure, block data subprogram, or common block in the same executable program. the name pgm ___ must not be the same as any local name in the main program. 14.2 main_program_restrictions the program statement may appear only as the first statement of a main program. a main program may contain any other statement except a block data, function, subroutine, entry, or return statement. the appearance of a save statement in a main program has no effect. a main program may not be referenced from a subprogram or from itself. fortran 77 full language page 14-1 contents 14. main program................................ 14-1 14.1 program statement..................... 14-1 14.2 main program restrictions............. 14-1 - i - ansi x3j3 90.4 15. functions_and_subroutines 15.1 categories_of_functions_and_subroutines 15.1.1 procedures. functions and subroutines are procedures. there are four categories of procedures: (1) intrinsic functions (2) statement functions (3) external functions (4) subroutines intrinsic functions, statement functions, and external functions are referred to collectively as functions. external functions and subroutines are referred to collectively as external procedures. 15.1.2 external_functions. there are two categories of external functions: (1) external functions specified in function subprograms (2) external functions specified by means other than fortran subprograms 15.1.3 subroutines. there are two categories of subroutines: (1) subroutines specified in subroutine subprograms (2) subroutines specified by means other than fortran subprograms 15.1.4 dummy_procedure. a dummy procedure is a dummy argument that is identified as a procedure (18.2.11). 15.2 referencing_a_function a function is referenced in an expression and supplies a value to the expression. the value supplied is the value of the function. an intrinsic function may be referenced in the main program or in any procedure subprogram of an executable program. fortran 77 full language page 15-1 functions and subroutines ansi x3j3 90.4 a statement function may be referenced only in the program unit in which the statement function statement appears. an external function specified by a function subprogram may be referenced within any other procedure subprogram or the main program of the executable program. a subprogram must not reference itself, either directly or indirectly. an external function specified by means other than a subprogram may be referenced within any procedure subprogram or the main program of the executable program. if a character function is referenced in a program unit, the function length specified in the program unit must be an integer constant expression. 15.2.1 form_of_a_function_reference. a function reference is used to reference an intrinsic function, statement function, or external function. the form of a function reference is: fun___ ( [a_ [,a_]...] ) where: fun___ is the symbolic name of a function or a dummy procedure a_ is an actual argument the type of the result of a statement function or external function reference is the same as the type of the function name. the type is specified in the same manner as for variables and arrays (4.1.2). the type of the result of an intrinsic function is specified in table 5 (15.10). 15.2.2 execution_of_a_function_reference. a function reference may appear only as a primary in an arithmetic, logical, or character expression. execution of a function reference in an expression causes the evaluation of the function identified by fun. return of control from a referenced function completes execution of the function reference. the value of the function is available to the referencing expression. fortran 77 full language page 15-2 functions and subroutines ansi x3j3 90.4 15.3 intrinsic_functions intrinsic functions are supplied by the processor and have a special meaning. the specific names that identify the intrinsic functions, their generic names, function definitions, type of arguments, and type of results appear in table 5. an implicit statement does not change the type of an intrinsic function. 15.3.1 specific_names_and_generic_names. generic names simplify the referencing of intrinsic functions, because the same function name may be used with more than one type of argument. only a specific intrinsic function name may be used as an actual argument when the argument is an intrinsic function. if a generic name is used to reference an intrinsic function, the type of the result (except for intrinsic functions performing type conversion, nearest integer, and absolute value with a complex argument) is the same as the type of the argument. for those intrinsic functions that have more than one argument, all arguments must be of the same type. if the specific name or generic name of an intrinsic function appears in the dummy argument list of a function or subroutine in a subprogram, that symbolic name does not identify an intrinsic function in the program unit. the data type identified with the symbolic name is specified in the same manner as for variables and arrays (4.1.2). a name in an intrinsic statement must be the specific name or generic name of an intrinsic function. 15.3.2 referencing_an_intrinsic_function. an intrinsic function is referenced by using its reference as a primary in an expression. for each intrinsic function described in table 5, execution of an intrinsic function reference causes the actions specified in table 5, and the result depends on the values of the actual arguments. the resulting value is available to the expression that contains the function reference. the actual arguments that constitute the argument list must agree in order, number, and type with the specification in table 5 and may be any expression of fortran 77 full language page 15-3 functions and subroutines ansi x3j3 90.4 the specified type. an actual argument in an intrinsic function reference may be any expression except a character expression involving concatenation of an operand whose length specification is an asterisk in parentheses unless the operand is the symbolic name of a constant. a specific name of an intrinsic function that appears in an intrinsic statement may be used as an actual argument in an external procedure reference; however, the names of intrinsic functions for type conversion, lexical relationship, and for choosing the largest or smallest value must not be used as actual arguments. note that such an appearance does not cause the intrinsic function to be classified as an external function (18.2.10). 15.3.3 intrinsic_function_restrictions. arguments for which the result is not mathematically defined or exceeds the numeric range of the processor cause the result of the function to become undefined. restrictions on the range of arguments and results for intrinsic functions are described in 15.10.1. 15.4 statement_function a statement function is a procedure specified by a single statement that is similar in form to an arithmetic, logical, or character assignment statement. a statement function statement must appear only after the specification statements and before the first executable statement of the program unit in which it is referenced (3.5). a statement function statement is classified as a nonexecutable statement; it is not a part of the normal execution sequence. 15.4.1 form_of_a_statement_function_statement. the form of a statement function statement is: fun___ ( [d_ [,d_]...] )="e_" where: fun__ _ is the symbolic name of the statement function d_ is a statement function dummy argument e_ is an expression fortran 77 full language page 15-4 functions and subroutines ansi x3j3 90.4 the relationship between fun___ and e_ must conform to the assignment rules in 10.1, 10.2, and 10.4. note that the type of the expression may be different from the type of the statement function name. each d_ is a variable name called a statement function dummy argument. the statement function dummy argument list serves only to indicate order, number, and type of arguments for the statement function. the variable names that appear as dummy arguments of a statement function have a scope of that statement (18.1). a given symbolic name may appear only once in any statement function dummy argument list. the symbolic name of a statement function dummy argument may be used to identify other dummy arguments of the same type in different statement function statements. the name may also be used to identify a variable of the same type appearing elsewhere in the program unit, including its appearance as a dummy argument in a function, subroutine, or entry statement. the name must not be used to identify any other entity in the program unit except a common block. each primary of the expression e_ must be one of the following: (1) a constant (2) the symbolic name of a constant (3) a variable reference (4) an array element reference (5) an intrinsic function reference (6) a reference to a statement function for which the statement function statement appears in preceding lines of the program unit (7) an external function reference (8) a dummy procedure reference (9) an expression enclosed in parentheses that meets all of the requirements specified for the expression e_ each variable reference may be either a reference to a dummy argument of the statement function or a reference to a variable that appears within the same program unit fortran 77 full language page 15-5 functions and subroutines ansi x3j3 90.4 as the statement function statement. if a statement function dummy argument name is the same as the name of another entity, the appearance of that name in the expression of a statement function statement is a reference to the statement function dummy argument. a dummy argument that appears in a function or subroutine statement may be referenced in the expression of a statement function statement within the subprogram. a dummy argument that appears in an entry statement that precedes a statement function statement may be referenced in the expression of the statement function statement within the subprogram. 15.4.2 referencing_a_statement_function. a statement function is referenced by using its function reference as a primary in an expression. execution of a statement function reference results in: (1) evaluation of actual arguments that are expressions, (2) association of actual arguments with the corresponding dummy arguments, (3) evaluation of the expression e_, and (4) conversion, if necessary, of an arithmetic expression value to the type of the statement function according to the assignment rules in 10.1 or a change, if necessary, in the length of a character expression value according to the rules in 10.4. the resulting value is available to the expression that contains the function reference. the actual arguments, which constitute the argument list, must agree in order, number, and type with the corresponding dummy arguments. an actual argument in a statement function reference may be any expression except a character expression involving concatenation of an operand whose length specification is an asterisk in parentheses unless the operand is the symbolic name of a constant. when a statement function reference is executed, its actual arguments must be defined. fortran 77 full language page 15-6 functions and subroutines ansi x3j3 90.4 15.4.3 statement_function_restrictions. a statement function may be referenced only in the program unit that contains the statement function statement. a statement function statement must not contain a reference to another statement function that appears following the reference in the sequence of lines in the program unit. the symbolic name used to identify a statement function must not appear as a symbolic name in any specification statement except in a type- statement (to specify the type of the function) or as the name of a common block in the same program unit. an external function reference in the expression of a statement function statement must not cause a dummy argument of the statement function to become undefined or redefined. the symbolic name of a statement function is a local name (18.1.2) and must not be the same as the name of any other entity in the program unit except the name of a common block. the symbolic name of a statement function may not be an actual argument. it must not appear in an external statement. a statement function statement in a function subprogram must not contain a function reference to the name of the function subprogram or an entry name in the function subprogram. the length specification of a character statement function or statement function dummy argument of type character must be an integer constant expression. 15.5 external_functions an external function is specified externally to the program unit that references it. an external function is a procedure and may be specified in a function subprogram or by some other means. 15.5.1 function_subprogram_and_function_statement. a function subprogram specifies one or more external functions (15.7). a function subprogram is a program unit that has a function statement as its first statement. the form of a function subprogram is as described in 2.4 and 3.5, except as noted in 15.5.3 and 15.7.4. fortran 77 full language page 15-7 functions and subroutines ansi x3j3 90.4 the form of a function statement is: [typ___] function fun___ ( [d_ [,d_]...] ) where: typ___ is one of integer, real, double precision, complex, logical, or character [*len___] where len ___ is the length specification of the result of the character function. len___ may have any of the forms allowed in a character statement (8.4.2) except that an integer constant expression must not include the symbolic name of a constant. if a length is not specified in a character function statement, the character function has a length of one. fun_ _ _ is the symbolic name of the function subprogram in which the function statement appears. fun___ is an external function name. d_ is a variable name, array name, or dummy procedure name. d_ is a dummy argument. the symbolic name of a function subprogram or an associated entry name of the same type must appear as a variable name in the function subprogram. during every execution of the external function, this variable must become defined and, once defined, may be referenced or become redefined. the value of this variable when a return or end statement is executed in the subprogram is the value of the function. if this variable is a character variable with a length specification that is an asterisk in parentheses, it must not appear as an operand for concatenation except in a character assignment statement (10.4). an external function in a function subprogram may define one or more of its dummy arguments to return values in addition to the value of the function. 15.5.2 referencing_an_external_function. an external function is referenced by using its reference as a primary in an expression. 15.5.2.1 execution_of_an_external_function_reference. execution of an external function reference results in: (1) evaluation of actual arguments that are expressions, fortran 77 full language page 15-8 functions and subroutines ansi x3j3 90.4 (2) association of actual arguments with the corresponding dummy arguments, and (3) the actions specified by the referenced function. the type of the function name in the function reference must be the same as the type of the function name in the referenced function. the length of the character function in a character function reference must be the same as the length of the character function in the referenced function. when an external function reference is executed, the function must be one of the external functions in the executable program. 15.5.2.2 actual_arguments_for_an_external_function. the actual arguments in an external function reference must agree in order, number, and type with the corresponding dummy arguments in the referenced function. the use of a subroutine name as an actual argument is an exception to the rule requiring agreement of type because subroutine names do not have a type. an actual argument in tan external function reference must be one of the following: (1) an expression except a character expression involving concatenation of an operand whose length specification is an asterisk in parentheses unless the operand is the symbolic name of a constant (2) an array name (3) an intrinsic function name (4) an external procedure name (5) a dummy procedure name note that an actual argument in a function reference may be a dummy argument that appears in a dummy argument list within the subprogram containing the reference. 15.5.3 function_subprogram_restrictions. a function statement must appear only as the first statement of a function subprogram. a function subprogram may contain fortran 77 full language page 15-9 functions and subroutines ansi x3j3 90.4 any other statement except a block data, subroutine, or program statement. the symbolic name of an external function is a global name (18.1.1) and must not be the same as any other global name or any local name, except a variable name, in the function subprogram. within a function subprogram, the symbolic name of a function specified by a function or entry statement must not appear in any other nonexecutable statement, except a type-statement. in an executable statement, such a name may appear only as a variable. if the type of a function is specified in a function statement, the function name must not appear in a type-statement. note that a name must not have its type explicitly specified more than once in a program unit. if the name of a function subprogram is of type character, each entry name in the function subprogram must be of type character. if the name of the function subprogram or any entry in the subprogram has a length of (*) declared, all such entities must have a length of (*) declared; otherwise, all such entities must have a length specification of the same integer value. in a function subprogram, the symbolic name of a dummy argument is local to the program unit and must not appear in an equivalence, parameter, save, intrinsic, data, or common statement, except as a common block name. a character dummy argument whose length specification is an asterisk in parentheses must not appear as an operand for concatenation, except in a character assignment statement (10.4). a function specified in a subprogram may be referenced within any other procedure subprogram or the main program of the executable program. a function subprogram must not reference itself, either directly or indirectly. 15.6 subroutines a subroutine is specified externally to the program unit that references it. a subroutine is a procedure and may be specified in a subroutine subprogram or by some other means. fortran 77 full language page 15-10 functions and subroutines ansi x3j3 90.4 15.6.1 subroutine_subprogram_and_subroutine_statement. a subroutine subprogram specifies one or more subroutines (15.7). a subroutine subprogram is a program unit that has a subroutine statement as its first statement. the form of a subroutine subprogram is as described in 2.4 and 3.5, except as noted in 15.6.3 and 15.7.4. the form of a subroutine statement is: subroutine sub___ [( [d_ [,d_]...] )] where: sub___ is the symbolic name of the subroutine subprogram in which the subroutine statement appears. sub___ is a subroutine name. d_ is a variable name, array name, or dummy procedure name, or is an asterisk (15.9.3.5). d_ is a dummy argument. note that if there are no dummy arguments, either of the forms sub___ or sub___() may be used in the subroutine statement. a subroutine that is specified by either form may be referenced by a call statement of the form call sub___ or call sub___(). one or more dummy arguments of a subroutine in a subprogram may become defined or redefined to return results. 15.6.2 subroutine_reference. a subroutine is referenced by a call statement. 15.6.2.1 form_of_a_call_statement. the form of a call statement is: call sub___ [( [a_ [,a_]...] )] where: sub___ is the symbolic name of a subroutine or dummy procedure a_ is an actual argument 15.6.2.2 execution_of_a_call_statement. execution of a call statement results in (1) evaluation of actual arguments that are expressions, (2) association of actual arguments with the corresponding dummy arguments, and fortran 77 full language page 15-11 functions and subroutines ansi x3j3 90.4 (3) the actions specified by the referenced subroutine. return of control from the referenced subroutine completes execution of the call statement. a subroutine specified in a subprogram may be referenced within any other procedure subprogram or the main program of the executable program. a subprogram must not reference itself, either directly or indirectly. when a call statement is executed, the referenced subroutine must be one of the subroutines specified in subroutine subprograms or by other means in the executable program. 15.6.2.3 actual_arguments_for_a_subroutine. the actual arguments in a subroutine reference must agree in order, number, and type with the corresponding dummy arguments in the dummy argument list of the referenced subroutine. the use of a subroutine name or an alternate return specifier as an actual argument is an exception to the rule requiring agreement of type. an actual argument in a subroutine reference must be one of the following: (1) an expression except a character expression involving concatenation of an operand whose length specification is an asterisk in parentheses unless the operand is the symbolic name of a constant (2) an array name (3) an intrinsic function name (4) an external procedure name (5) a dummy procedure name (6) an alternate return specifier, of the form *s_ , where s_ is the statement label of an executable statement that appears in the same program unit as the call statement (15.8.3) note that an actual argument in a subroutine reference may be a dummy argument name that appears in a dummy argument list within the subprogram containing the reference. an asterisk dummy argument must not be used fortran 77 full language page 15-12 functions and subroutines ansi x3j3 90.4 as an actual argument in a subprogram reference. 15.6.3 subroutine_subprogram_restrictions. a subroutine statement must appear only as the first statement of a subroutine subprogram. a subroutine subprogram may contain any other statement except a block data, function, or program statement. the symbolic name of a subroutine is a global name (18.1.1) and must not be the same as any other global name or any local name in the program unit. in a subroutine subprogram, the symbolic name of a dummy argument is local to the program unit and must not appear in an equivalence, parameter, save, intrinsic, data, or common statement, except as a common block name. a character dummy argument whose length specification is an asterisk in parentheses must not appear as an operand for concatenation, except in a character assignment statement (10.4). 15.7 entry_statement an entry statement permits a procedure reference to begin with a particular executable statement within the function or subroutine subprogram in which the entry statement appears. it may appear anywhere within a function subprogram after the function statement or within a subroutine subprogram after the subroutine statement, except that an entry statement must not appear between a block if statement and its corresponding end if statement, or between a do statement and the terminal statement of its do-loop. optionally, a subprogram may have one or more entry statements. an entry statement is classified as a nonexecutable statement. 15.7.1 form_of_an_entry_statement. the form of an entry statement is: entry en__ [( [d_ [,d_]...] )] where: en__ is the symbolic name of an entry in a function or subroutine subprogram and is called an entry name. if the entry statement appears in a subroutine fortran 77 full language page 15-13 functions and subroutines ansi x3j3 90.4 subprogram, en__ is a subroutine name. if the entry statement appears in a function subprogram, en__ is an external function name. d_ is a variable name, array name, or dummy procedure name, or is an asterisk. d_ is a dummy argument. an asterisk is permitted in an entry statement only in a subroutine subprogram. note that if there are no dummy arguments, either of the forms en_ _ or en_ _ () may be used in the entry statement. a function that is specified by either form must be referenced by the form en__() (15.2.1). a subroutine that is specified by either form may be referenced by a call statement of the form call en__ or call en__(). the entry name en__ in a function subprogram may appear in a type-statement. 15.7.2 referencing_external_procedure_by_entry_name. an entry name in an entry statement in a function subprogram identifies an external function within the executable program and may be referenced as an external function (15.5.2). an entry name in an entry statement in a subroutine subprogram identifies a subroutine within the executable program and may be referenced as a subroutine (15.6.2). when an entry name en__ is used to reference a procedure, execution of the procedure begins with the first executable statement that follows the entry statement whose entry name is en__. an entry name is available for reference in any program unit of an executable program, except in the program unit that contains the entry name in an entry statement. the order, number, type, and names of the dummy arguments in an entry statement may be different from the order, number, type, and names of the dummy arguments in the function statement or subroutine statement and other entry statements in the same subprogram. however, each reference to a function or subroutine must use an actual argument list that agrees in order, number, and type with the dummy argument list in the corresponding function, subroutine, or entry statement. the use of a subroutine name or an alternate return specifier as an actual argument is an fortran 77 full language page 15-14 functions and subroutines ansi x3j3 90.4 exception to the rule requiring agreement of type. 15.7.3 entry_association. within a function subprogram, all variables whose names are also the names of entries are associated with each other and with the variable, if any, whose name is also the name of the function subprogram (17.1.3). therefore, any such variable that becomes defined causes all associated variables of the same type to become defined and all associated variables of different type to become undefined. such variables are not required to be of the same type unless the type is character, but the variable whose name is used to reference the function must be in a defined state when a return or end statement is executed in the subprogram. an associated variable of a different type must not become defined during the execution of the function reference. 15.7.4 entry_statement_restrictions. within a subprogram, an entry name must not appear both as an entry name in an entry statement and as a dummy argument in a function, subroutine, or entry statement and must not appear in an external statement. in a function subprogram, a variable name that is the same as an entry name must not appear in any statement that precedes the appearance of the entry name in an entry statement, except in a type-statement. if an entry name in a function subprogram is of type character, each entry name and the name of the function subprogram must be of type character. if the name of the function subprogram or any entry in the subprogram has a length of (*) declared, all such entities must have a length of (*) declared; otherwise, all such entities must have a length specification of the same integer value. in a subprogram, a name that appears as a dummy argument in an entry statement must not appear in an executable statement preceding that entry statement unless it also appears in a function, subroutine, or entry statement that precedes the executable statement. in a subprogram, a name that appears as a dummy argument in an entry statement must not appear in the expression of a statement function statement unless the name is also a dummy argument of the statement function, appears in a function or subroutine statement, or appears in an entry statement that precedes the statement function statement. fortran 77 full language page 15-15 functions and subroutines ansi x3j3 90.4 if a dummy argument appears in an executable statement, the execution of the executable statement is permitted during the execution of a reference to the function or subroutine only if the dummy argument appears in the dummy argument list of the procedure name referenced. note that the association of dummy arguments with actual arguments is not retained between references to a function or subroutine. 15.8 return_statement a return statement causes return of control to the referencing program unit and may appear only in a function subprogram or subroutine subprogram. 15.8.1 form_of_a_return_statement. the form of a return statement in a function subprogram is: return the form of a return statement in a subroutine subprogram is: return [e_] where e_ is an integer expression. 15.8.2 execution_of_a_return_statement. execution of a return statement terminates the reference of a function or subroutine subprogram. such subprograms may contain more than one return statement; however, a subprogram need not contain a return statement. execution of an end statement in a function or subroutine subprogram has the same effect as executing a return statement in the subprogram. in the execution of an executable program, a function or subroutine subprogram must not be referenced a second time without the prior execution of a return or end statement in that procedure. execution of a return statement in a function subprogram causes return of control to the currently referencing program unit. the value of the function (15.5) must be defined and is available to the referencing program unit. execution of a return statement in a subroutine subprogram causes return of control to the currently referencing program unit. return of control to the referencing program unit completes execution of the fortran 77 full language page 15-16 functions and subroutines ansi x3j3 90.4 call statement. execution of a return statement terminates the association between the dummy arguments of the external procedure in the subprogram and the current actual arguments. 15.8.3 alternate_return. if e_ is not specified in a return statement, or if the value of e_ is less than one or greater than the number of asterisks in the subroutine or subroutine entry statement that specifies the currently referenced name, control returns to the call statement that initiated the subprogram reference and this completes the execution of the call statement. if 1 < e_ < n_, where n_ is the number of asterisks in the subroutine or subroutine entry statement that specifies the currently referenced name, the value of e _ identifies the e_th asterisk in the dummy argument list. control is returned to the statement identified by the alternate return specifier in the call statement that is associated with the e_ th asterisk in the dummy argument list of the currently referenced name. this completes the execution of the call statement. 15.8.4 definition_status. execution of a return statement (or end statement) within a subprogram causes all entities within the subprogram to become undefined, except for the following: (1) entities specified by save statements (2) entities in blank common (3) initially defined entities that have neither been redefined or become undefined (4) entities in a named common block that appears in the subprogram and appears in at least one other program unit that is referencing, either directly or indirectly, the subprogram note that if a named common block appears in the main program, the entities in the named common block do not become undefined at the execution of any return statement in the executable program. fortran 77 full language page 15-17 functions and subroutines ansi x3j3 90.4 15.9 arguments_and_common_blocks arguments and common blocks provide means of communication between the referencing program unit and the referenced procedure. data may be communicated to a statement function or intrinsic function by an argument list. data may be communicated to and from an external procedure by an argument list or common blocks. procedure names may be communicated to an external procedure only by an argument list. a dummy argument appears in the argument list of a procedure. an actual argument appears in the argument list of a procedure reference. the number of actual arguments must be the same as the number of dummy arguments in the procedure referenced. 15.9.1 dummy_arguments. statement functions, function subprograms, and subroutine subprograms use dummy arguments to indicate the types of actual arguments and whether each argument is a single value, array of values, procedure, or statement label. note that a statement function dummy argument may be only a variable. each dummy argument is classified as a variable, array, dummy procedure, or asterisk. dummy argument names may appear wherever an actual name of the same class (section 18) and type may appear, except where they are explicitly prohibited. dummy argument names of type integer may appear in adjustable dimensions in dummy array declarators (5.5.1). dummy argument names must not appear in equivalence, data, parameter, save, intrinsic, or common statements, except as common block names. a dummy argument name must not be the same as the procedure name appearing in a function, subroutine, entry, or statement function statement in the same program unit. 15.9.2 actual_arguments. actual arguments specify the entities that are to be associated with the dummy arguments for a particular reference of a subroutine or function. an actual argument must not be the name of a statement function in the program unit containing the reference. actual arguments may be constants, symbolic names of constants, function references, expressions fortran 77 full language page 15-18 functions and subroutines ansi x3j3 90.4 involving operators, and expressions enclosed in parentheses if and only if the associated dummy argument is a variable that is not defined during execution of the referenced external procedure. the type of each actual argument must agree with the type of its associated dummy argument, except when the actual argument is a subroutine name (15.9.3.4) or an alternate return specifier (15.6.2.3). 15.9.3 association_of_dummy_and_actual_arguments. at the execution of a function or subroutine reference, an association is established between the corresponding dummy and actual arguments. the first dummy argument becomes associated with the first actual argument, the second dummy argument becomes associated with the second actual argument, etc. all appearances within a function or subroutine subprogram of a dummy argument whose name appears in the dummy argument list of the procedure name referenced become associated with the actual argument when a reference to the function or subroutine is executed. a valid association occurs only if the type of the actual argument is the same as the type of the corresponding dummy argument. a subroutine name has no type and must be associated with a dummy procedure name. an alternate return specifier has no type and must be associated with an asterisk. if an actual argument is an expression, it is evaluated just before the association of arguments takes place. if an actual argument is an array element name, its subscript is evaluated just before the association of arguments takes place. note that the subscript value remains constant as long as that association of arguments persists, even if the subscript contains variables that are redefined during the association. if an actual argument is a character substring name, its substring expressions are evaluated just before the association of arguments takes place. note that the value of each of the substring expressions remains constant as long as that association of arguments persists, even if the substring expression contains variables that are redefined during the association. fortran 77 full language page 15-19 functions and subroutines ansi x3j3 90.4 if an actual argument is an external procedure name, the procedure must be available at the time a reference to it is executed. if an actual argument becomes associated with a dummy argument that appears in an adjustable dimension (5.5.1), the actual argument must be defined with an integer value at the time the procedure is referenced. a dummy argument is undefined if it is not currently associated with an actual argument. an adjustable array is undefined if the dummy argument array is not currently associated with an actual argument array or if any variable appearing in the adjustable array declarator is not currently associated with an actual argument and is not in a common block. argument association may be carried through more than one level of procedure reference. a valid association exists at the last level only if a valid association exists at all intermediate levels. argument association within a program unit terminates at the execution of a return or end statement in the program unit. note that there is no retention of argument association between one reference of a subprogram and the next reference of the subprogram. 15.9.3.1 length of character dummy and actual arguments. if a dummy argument is of type character, the associated actual argument must be of type character and the length of the dummy argument must be less than or equal to the length of the actual argument. if the length len___ of a dummy argument of type character is less than the length of an associated actual argument, the leftmost len___ characters of the actual argument are associated with the dummy argument. if a dummy argument of type character is an array name, the restriction on length is for the entire array and not for each array element. the length of an array element in the dummy argument array may be different from the length of an array element in an associated actual argument array, array element, or array element substring, but the dummy argument array must not extend beyond the end of the associated actual argument array. if an actual argument is a character substring, the length of the actual argument is the length of the substring. if an actual argument is the concatenation of two or more operands, its length is the sum of the lengths of the operands. fortran 77 full language page 15-20 functions and subroutines ansi x3j3 90.4 15.9.3.2 variables_as_dummy_arguments. a dummy argument that is a variable may be associated with an actual argument that is a variable, array element, substring, or expression. if the actual argument is a variable name, array element name, or substring name, the associated dummy argument may be defined or redefined within the subprogram. if the actual argument is a constant, a symbolic name of a constant, a function reference, an expression involving operators, or an expression enclosed in parentheses, the associated dummy argument must not be redefined within the subprogram. 15.9.3.3 arrays_as_dummy_arguments. within a program unit, the array declarator given for an array provides all array declarator information needed for the array in an execution of the program unit. the number and size of dimensions in an actual argument array declarator may be different from the number and size of the dimensions in an associated dummy argument array declarator. a dummy argument that is an array may be associated with an actual argument that is an array, array element, or array element substring. if the actual argument is a noncharacter array name, the size of the dummy argument array must not exceed the size of the actual argument array, and each actual argument array element becomes associated with the dummy argument array element that has the same subscript value as the actual argument array element. note that association by array elements exists for character arrays if there is agreement in length between the actual argument and the dummy argument array elements; if the lengths do not agree, the dummy and actual argument array elements do not consist of the same characters, but an association still exists. if the actual argument is a noncharacter array element name, the size of the dummy argument array must not exceed the size of the actual argument array plus one minus the subscript value of the array element. when an actual argument is a noncharacter array element name with a subscript value of as__, the dummy argument array element with a subscript value of ds__ becomes associated with the actual argument array element that has a subscript value of as__ + ds__ - 1 (table 1, 5.4.3). fortran 77 full language page 15-21 functions and subroutines ansi x3j3 90.4 if the actual argument is a character array name, character array element name, or character array element substring name and begins at character storage unit acu___ of an array, character storage unit dcu___ of an associated dummy argument array becomes associated with character storage unit acu_ __ + dcu___ - 1 of the actual argument array. 15.9.3.4 procedures_as_dummy_arguments. a dummy argument that is a dummy procedure may be associated only with an actual argument that is an intrinsic function, external function, subroutine, or another dummy procedure. if a dummy argument is used as if it were an external function, the associated actual argument must be an intrinsic function, external function, or dummy procedure. a dummy argument that becomes associated with an intrinsic function never has any automatic typing property, even if the dummy argument name appears in table 5 (15.10). therefore, the type of the dummy argument must agree with the type of the result of all specific actual arguments that become associated with the dummy argument. if a dummy argument name is used as if it were an external function and that name also appears in table 5, the intrinsic function corresponding to the dummy argument name is not available for referencing within the subprogram. a dummy argument that is used as a procedure name in a function reference and is associated with an intrinsic function must have arguments that agree in order, number, and type with those specified in table 5 for the intrinsic function. if a dummy argument appears in a type-statement and an external statement, the actual argument must be the name of an intrinsic function, external function, or dummy procedure. if the dummy argument is referenced as a subroutine, the actual argument must be the name of a subroutine or dummy procedure and must not appear in a type-statement or be referenced as a function. note that it may not be possible to determine in a given program unit whether a dummy procedure is associated with a function or a subroutine. if a procedure name appears only in a dummy argument list, an external statement, and an actual argument list, it is not possible to determine whether the symbolic name fortran 77 full language page 15-22 functions and subroutines ansi x3j3 90.4 becomes associated with a function or subroutine by examination of the subprogram alone. 15.9.3.5 asterisks_as_dummy_arguments. a dummy argument that is an asterisk may appear only in the dummy argument list of a subroutine statement or an entry statement in a subroutine subprogram. a dummy argument that is an asterisk may be associated only with an actual argument that is an alternate return specifier in the call statement that identifies the current referencing name. if a dummy argument is an asterisk, the corresponding actual argument must be an alternate return specifier. 15.9.3.6 restrictions_on_association_of_entities. if a subprogram reference causes a dummy argument in the referenced subprogram to become associated with another dummy argument in the referenced subprogram, neither dummy argument may become defined during execution of that subprogram. for example, if a subroutine is headed by subroutine xyz (a,b) and is referenced by call xyz (c,c) the[n the dummy arguments a and b each become associated with the same actual argument c and therefore with each other. neither a nor b may become defined during this execution of subroutine xyz or by any procedures referenced by xyz. if a subprogram reference causes a dummy argument to become associated with an entity in a common block in the referenced subprogram or in a subprogram referenced by the referenced subprogram, neither the dummy argument nor the entity in the common block may become defined within the subprogram or within a subprogram referenced by the referenced subprogram. for example, if a subroutine contains the statements: subroutine xyz (a) common c and is referenced by a program unit that contains the statements: common b fortran 77 full language page 15-23 functions and subroutines ansi x3j3 90.4 call xyz (b) then the dummy argument a becomes associated with the actual argument b, which is associated with c, which is in a common block. neither a nor c may become defined during execution of the subroutine xyz or by any procedures referenced by xyz. 15.9.4 common_blocks. a common block provides a means of communication between external procedures or between a main program and an external procedure. the variables and arrays in a common block may be defined and referenced in all subprograms that contain a declaration of that common block. because association is by storage rather than by name, the names of the variables and arrays may be different in the different subprograms. a reference to a datum in a common block is proper if the datum is in a defined state of the same type as the type of the name used to reference the datum. however, an integer variable that has been assigned a statement label must not be referenced in any program unit other than the one in which it was assigned (10.3). no difference in data type is permitted between the defined state and the type of the reference, except that either part of a complex datum may be referenced also as a real datum. in a subprogram that has declared a named common block, the entities in the block remain defined after the execution of a return or end statement if a common block of the same name has been declared in any program unit that is currently referencing the subprogram, either directly or indirectly. otherwise, such entities become undefined at the execution of a return or end statement, except for those that are specified by save statements and those that were initially defined by data statements and have neither been redefined nor become undefined. execution of a return or end statement does not cause entities in blank common or in any named common block that appears in the main program to become undefined. common blocks may be used also to reduce the total number of storage units required for an executable program by causing two or more subprograms to share some of the same storage units. this sharing of storage is permitted if the rules for defining and referencing data are not violated. fortran 77 full language page 15-24 functions and subroutines ansi x3j3 90.4 15.10 table_of_intrinsic_functions fortran 77 full language page 15-25 functions and subroutines ansi x3j3 90.4 fortran 77 full language page 15-26 functions and subroutines ansi x3j3 90.4 fortran 77 full language page 15-27 functions and subroutines ansi x3j3 90.4 fortran 77 full language page 15-28 functions and subroutines ansi x3j3 90.4 notes for table 5: (1) for a_ of type integer, int(a_)="a_." for a_ of type real or double precision, there are two cases: if |a_| < 1, int(a_)="0;" if |a_|> 1, int(a_) is  the
                 integer  whose  magnitude is the largest integer
                 that does not exceed the  magnitude  of  a_  and
                 whose  sign  is  the same as the sign of a_.  For
                 example,

                                      int(-3.7) = -3

                 For a_ of type complex,  int(a_ )  is  the  value
                 obtained  by applying the above rule to the real
                 part of a_.

                 For a_ of type real, IFIX(a_) is the same as INT(a_
                 ).

             (2) For a_ of type real, REAL(a_) is a_.  For a_ of type
                 integer  or double precision, REAL(a_) is as much
                 precision of the significant part of a_ as a real
                 datum can contain.  For a_ of type complex, REAL(a
                 _) is the real part of a_.

                 For a_ of type integer, FLOAT(a_) is the  same  as
                 REAL(a_).

             (3) For a_ of type double precision, DBLE(a_) is  a_ .
                 For  a_  of  type integer or real, DBLE(a_) is as
                 much precision of the significant part of a_ as a
                 double  precision  datum  can contain.  For a_ of
                 type complex, DBLE(a_) is as  much  precision  of
                 the  significant part of the real part of a_ as a
                 double precision datum can contain.

             (4) CMPLX may have one or two arguments.   If  there
                 is  one  argument,  it may be of  type  integer,
                 real, double precision, or  complex.   If  there
                 are two arguments, they must both be of the same
                 type and may be of type integer, real, or double
                 precision.

                 For a_ of type complex, CMPLX(a_) is a_.  For a_  of
                 type integer, real, or double precision, CMPLX(a_
                 ) is the complex value whose real part is REAL(a_
                 ) and whose imaginary part is zero.

                 CMPLX(a_918,a_928) is the  complex  value  whose  real
                 part  is  REAL(a_918)  and whose imaginary part is
                 REAL(a_928).



          FORTRAN 77 Full Language                     Page 15-29







          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4



             (5) ICHAR provides a  means  of  converting  from  a
                 character  to  an integer, based on the position
                 of the  character  in  the  processor  collating
                 sequence.   The first character in the collating
                 sequence corresponds to position 0 and the  last
                 to  position  n_ - 1,  where  n_ is the number of
                 characters in the collating sequence.

                 The value of ICHAR(a_ )  is  an  integer  in  the
                 range:   0  &lt;  ICHAR(a_ )  &lt;  n_-1, where a_ is an
                 argument of type character of length  one.   The
                 value  of  a_  must  be  a  character capable of
                 representation in the processor.   The  position
                 of  that  character in the collating sequence is
                 the value of ICHAR.

                 For  any  characters  c_918  and  c_928  capable  of
                 representation  in the processor, (c_918 .LE c_928) is
                 true if and only if (ICHAR(c_918) .LE. ICHAR(c_928))
                 is true, and (c_918 .EQ. c_928) is true if and only if
                 (ICHAR(c_918) .EQ. ICHAR(c_928)) is true.

                 CHAR(i_)  returns  the  character  in  the  i_ th
                 position  of  the  processor collating sequence.
                 The value is of type character of length one.  i_
                 must  be  an integer expression whose value must
                 be in the range 0 &lt; i_ &lt; n_-1.

                        ICHAR(CHAR(i_)) = i_ for 0 &lt; i_ <n_-1. char(ichar(c_))="c_" for any character c_ capable of representation in the processor. (6) a complex value is expressed as an ordered pair of reals, (ar__,ai__), where ar__ is the real part and ai__ is the imaginary part. (7) all angles are expressed in radians. (8) the result of a function of type complex is the principal value. (9) all arguments in an intrinsic function reference must be of the same type. (10) index(a_918,a_928) returns an integer value indicating the starting position within the character string a_918 of a substring identical to string a_928. if a_928 occurs more than once in a_918, the starting fortran 77 full language page 15-30 functions and subroutines ansi x3j3 90.4 position of the first occurrence is returned. if a_928 does not occur in a_918, the value zero is returned. note that zero is returned if len(a _918) < len(a_928). (11) the value of the argument of the len function need not be defined at the time the function reference is executed. (12) lge(a_918,a_928) returns the value true if a_918="a_928" or if a _918 follows a_928 in the collating sequence described in american national standard code for information interchange, ansi x3.4-1977 (ascii), and otherwise returns the value false. lgt(a_918,a_928) returns the value true if a_918 follows a _928 in the collating sequence described in ansi x3.4-1977 (ascii), and otherwise returns the value false. lle(a_918,a_928) returns the value true if a_918="a_928" or if a_918 precedes a_928 in the collating sequence described in ansi x3.4-1977 (ascii), and otherwise returns the value false. llt(a_918,a_928) returns the value true if a_918 precedes a_928 in the collating sequence described in ansi x3.4-1977 (ascii), and otherwise returns the value false. if the operands for lge, lgt, lle, and llt are of unequal length, the shorter operand is considered as if it were extended on the right with blanks to the length of the longer operand. if either of the character entities being compared contains a character that is not in the ascii character set, the result is processor- dependent. 15.10.1 restrictions on range of arguments and results. restrictions on the range of arguments and results for intrinsic functions when referenced by their specific names are as follows: (1) remaindering: the result for mod, amod, and dmod is undefined when the value of the second argument is zero. fortran 77 full language page 15-31 functions and subroutines ansi x3j3 90.4 (2) transfer of sign: if the value of the first argument of isign, sign, or dsign is zero, the result is zero, which is neither positive or negative (4.1.3). (3) square root: the value of the argument of sqrt and dsqrt must be greater than or equal to zero. the result of csqrt is the principal value with the real part greater than or equal to zero. when the real part of the result is zero, the imaginary part is greater than or equal to zero. (4) logarithms: the value of the argument of alog, dlog, alog10, and dlog10 must be greater than zero. the value of the argument of clog must not be (0.,0.). the range of the imaginary part of the result of clog is: -j < imaginary part < j. the imaginary part of the result is j only when the real part of the argument is less than zero and the imaginary part of the argument is zero. (5) sine, cosine, and tangent: the absolute value of the argument of sin, dsin, cos, dcos, tan, and dtan is not restricted to be less than 2j. (6) arcsine: the absolute value of the argument of asin and dasin must be less than or equal to one. the range of the result is: -j 2 < result < j 2. (7) arccosine: the absolute value of the argument of acos and dacos must be less than or equal to one. the range of the result is: 0 < result <j. (8) arctangent: the range of the result for atan and datan is: -j 2 < result < j 2. if the value of the first argument of atan2 or datan2 is positive, the result is positive. if the value of the first argument is zero, the result is zero if the second argument is positive and j if the second argument is negative. if the value of the first argument is negative, the result is negative. if the value of the second argument is zero, the absolute value of the result is j 2. the arguments must not both have the value zero. the range of the result for atan2 and datan2 is: -j < result < j. fortran 77 full language page 15-32 functions and subroutines ansi x3j3 90.4 the above restrictions on arguments and results also apply to the intrinsic functions when referenced by their generic names. fortran 77 full language page 15-33 functions and subroutines ansi x3j3 90.4 table 5_______ intrinsic functions 8 ________________________________________________________________________________________________ number of generic specific type of intrinsic function definition arguments name name argument function 8 ________________________________________________________________________________________________ type conversion conversion 1 int - integer integer to integer int real integer int(a_) ifix real integer see note 1 idint double integer - complex integer 8 ___________________________________________________________________________ conversion 1 real real integer real to real float integer real see note 2 - real real sngl double real - complex real 8 ___________________________________________________________________________ conversion 1 dble - integer double to double - real double see note 3 - double double - complex double 8 ___________________________________________________________________________ conversion 1 or 2 cmplx - integer complex to complex - real complex see note 4 - double complex - complex complex 8 ___________________________________________________________________________ conversion 1 ichar character integer to integer see note 5 8 ___________________________________________________________________________ conversion 1 char integer character to character see note 5 8 ________________________________________________________________________________________________ truncation int(a_) 1 aint aint real real see note 1 dint double double 8 ________________________________________________________________________________________________ nearest whole int(a_+.5) if a_>0       1       ANINT     ANINT      Real        Real
             Number             int(a_-.5) if a_&lt;0                         DNINT      Double      Double
8          ________________________________________________________________________________________________

           Nearest Integer      int(a_+.5) if a_&gt;0       1       NINT      NINT       Real        Integer
                                int(a_-.5) if a_&lt;0                         IDNINT     Double      Integer
8          ________________________________________________________________________________________________

           Absolute Value       |a_|                    1       ABS       IABS       Integer     Integer
                                                                         ABS        Real        Real
                                See Note 6                               DABS       Double      Double
                                (a_r_829+a_i_829)81/29                             CABS       Complex     Real
8          ________________________________________________________________________________________________
7         |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


















































9                             |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


















































9                                                |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


















































9                                                            |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


















































9                                                                      |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


















































9                                                                                 |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


















































9                                                                                             |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
















































                                                                                                         |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|




















































9




          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4



                            Table 5 (continued)
                            Intrinsic Functions

8          ________________________________________________________________________________________________

                                                    Number of   Generic   Specific         Type of
           Intrinsic Function    Definition         Arguments    Name     Name       Argument    Function
8          ________________________________________________________________________________________________

           Remaindering          a_918-int(a_918/a_928)*a_928       2       MOD       MOD        Integer     Integer
                                 See Note 1                               AMOD       Real        Real
                                                                          DMOD       Double      Double
8          ________________________________________________________________________________________________

           Transfer of Sign      |a_918|  if a_928 &gt; 0        2       SIGN      ISIGN      Integer     Integer
                                 -|a_918| if a_928 &lt; 0                          SIGN       Real        Real
                                                                          DSIGN      Double      Double
8          ________________________________________________________________________________________________

           Positive Difference   a_918-a_928 if a_918&gt;a_928         2       DIM       IDIM       Integer     Integer
                                   0   if a_918<a_928 dim real real ddim double double 8 ________________________________________________________________________________________________ double precision a_918*a_928 2 dprod real double product 8 ________________________________________________________________________________________________ choosing largest max(a_918,a_928,...)>2       Max       MAX0       Integer     Integer
             Value                                                        AMAX1      Real        Real
                                                                          DMAX1      Double      Double
8                                                               ___________________________________________

                                                                          AMAX0      Integer     Real
                                                                          MAX1       Real        Integer
8          ________________________________________________________________________________________________

           Choosing Smallest     min(a_918,a_928,...)        &gt;2       MIN       MIN0       Integer     Integer
             Value                                                        AMIN1      Real        Real
                                                                          DMIN1      Double      Double
8                                                               ___________________________________________

                                                                          AMIN0      Integer     Real
                                                                          MIN1       Real        Integer
8          ________________________________________________________________________________________________

           Length                Length of              1                 LEN        Character   Integer
                                 Character Entity
8          ________________________________________________________________________________________________

           Index of              Location of            2                 INDEX      Character   Integer
           a Substring           Substring a_92
8                                 in String a_91
8                                 See Note 10
8          ________________________________________________________________________________________________

           Imaginary Part of     ai__                     1                 AIMAG      Complex     Real
            Complex Argument     See Note 6
8          ________________________________________________________________________________________________

           Conjugate of a        (ar__,-ai__)               1                 CONJG      Complex     Complex
            Complex Argument     See Note 6
8          ________________________________________________________________________________________________

           Square Root           (a_)81/29                 1       SQRT      SQRT       Real        Real
                                                                          DSQRT      Double      Double
                                                                          CSQRT      Complex     Complex
8          ________________________________________________________________________________________________
7         |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|























































                              |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|























































                                                 |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|























































                                                             |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|























































                                                                       |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|























































                                                                                  |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|























































                                                                                              |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|




















































9                                                                                                         |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|




























































          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4



                            Table 5 (continued)
                            Intrinsic Functions

8          ___________________________________________________________________________________________

                                                Number of   Generic   Specific         Type of
           Intrinsic Function   Definition      Arguments    Name     Name       Argument   Function
8          ___________________________________________________________________________________________

           Exponential          e**a_                1       EXP       EXP        Real       Real
                                                                      DEXP       Double     Double
                                                                      CEXP       Complex    Complex
8          ___________________________________________________________________________________________

           Natural Logarithm    log(a_)              1       LOG       ALOG       Real       Real
                                                                      DLOG       Double     Double
                                                                      CLOG       Complex    Complex
8          ___________________________________________________________________________________________

           Common Logarithm     log10(a_)            1       LOG10     ALOG10     Real       Real
                                                                      DLOG10     Double     Double
8          ___________________________________________________________________________________________

           Sine                 sin(a_)              1       SIN       SIN        Real       Real
                                                                      DSIN       Double     Double
                                                                      CSIN       Complex    Complex
8          ___________________________________________________________________________________________

           Cosine               cos(a_)              1       COS       COS        Real       Real
                                                                      DCOS       Double     Double
                                                                      CCOS       Complex    Complex
8          ___________________________________________________________________________________________

           Tangent              tan(a_)              1       TAN       TAN        Real       Real
                                                                      DTAN       Double     Double
8          ___________________________________________________________________________________________

           Arcsine              arcsin(a_)           1       ASIN      ASIN       Real       Real
                                                                      DASIN      Double     Double
8          ___________________________________________________________________________________________

           Arccosine            arccos(a_)           1       ACOS      ACOS       Real       Real
                                                                      DACOS      Double     Double
8          ___________________________________________________________________________________________

           Arctangent           arctan(a_)           1       ATAN      ATAN       Real       Real
                                                                      DATAN      Double     Double
8                               ______________________________________________________________________

                                arctan(a_918/a_928)       2       ATAN2     ATAN2      Real       Real
                                                                      DATAN2     Double     Double
8          ___________________________________________________________________________________________

           Hyperbolic Sine      sinh(a_)             1       SINH      SINH       Real       Real
                                                                      DSINH      Double     Double
8          ___________________________________________________________________________________________

           Hyperbolic Cosine    cosh(a_)             1       COSH      COSH       Real       Real
                                                                      DCOSH      Double     Double
8          ___________________________________________________________________________________________

           Hyperbolic Tangent   tanh(a_)             1       TANH      TANH       Real       Real
                                                                      DTANH      Double     Double
8          ___________________________________________________________________________________________
7         |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



















































                             |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



















































                                             |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



















































                                                         |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



















































                                                                   |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



















































                                                                              |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|



















































                                                                                         |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
















































9                                                                                                    |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|






















































9


          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4



                            Table 5 (continued)
                            Intrinsic Functions

8          __________________________________________________________________________________________

                                              Number of   Generic   Specific         Type of
           Intrinsic Function   Definition    Arguments    Name     Name       Argument    Function
8          __________________________________________________________________________________________

           Lexically Greater    a_918 &gt; a_928           2                 LGE        Character   Logical
             Than or Equal      See Note 12
8          __________________________________________________________________________________________

           Lexically Greater    a_918 &gt; a_928           2                 LGT        Character   Logical
             Than               See Note 12
8          __________________________________________________________________________________________

           Lexically Less       a_918 &lt; a_928           2                 LLE        Character   Logical
             Than or Equal      See Note 12
8          __________________________________________________________________________________________

           Lexically Less       a_918 &lt; a_928           2                 LLT        Character   Logical
             Than               See Note 12
8          __________________________________________________________________________________________
7         |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















9                             |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















9                                           |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















9                                                       |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















9                                                                 |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















9                                                                            |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|















9                                                                                        |7|7|7|7|7|7|7|7|7|7|7|7|7|7|













                                                                                                   |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|

















9































          FORTRAN 77 Full Language                     Page 15-26







          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4

























































          FORTRAN 77 Full Language                     Page 15-27











                                 CONTENTS


          15.  FUNCTIONS AND SUBROUTINES..................   15-1
               15.1   Categories of Functions and
                      Subroutines.........................   15-1
                      15.1.1   Procedures.................   15-1
                      15.1.2   External Functions.........   15-1
                      15.1.3   Subroutines................   15-1
                      15.1.4   Dummy Procedure............   15-1
               15.2   Referencing a Function..............   15-1
                      15.2.1   Form of a Function
                               Reference..................   15-2
                      15.2.2   Execution of a Function
                               Reference..................   15-2
               15.3   Intrinsic Functions.................   15-3
                      15.3.1   Specific Names and Generic
                               Names......................   15-3
                      15.3.2   Referencing an Intrinsic
                               Function...................   15-3
                      15.3.3   Intrinsic Function
                               Restrictions...............   15-4
               15.4   Statement Function..................   15-4
                      15.4.1   Form of a Statement
                               Function Statement.........   15-4
                      15.4.2   Referencing a Statement
                               Function...................   15-6
                      15.4.3   Statement Function
                               Restrictions...............   15-7
               15.5   External Functions..................   15-7
                      15.5.1   Function Subprogram and
                               FUNCTION Statement.........   15-7
                      15.5.2   Referencing an External
                               Function...................   15-8
                      15.5.3   Function Subprogram
                               Restrictions...............   15-9
               15.6   Subroutines.........................  15-10
                      15.6.1   Subroutine Subprogram and
                               SUBROUTINE
                               Statement..................  15-11
                      15.6.2   Subroutine
                               Reference..................  15-11
                      15.6.3   Subroutine Subprogram
                               Restrictions...............  15-13
               15.7   ENTRY Statement.....................  15-13
                      15.7.1   Form of an ENTRY
                               Statement..................  15-13
                      15.7.2   Referencing External
                               Procedure by Entry
                               Name.......................  15-14
                      15.7.3   Entry Association..........  15-15



                                   - i -











                      15.7.4   ENTRY Statement
                               Restrictions...............  15-15
               15.8   RETURN Statement....................  15-16
                      15.8.1   Form of a RETURN
                               Statement..................  15-16
                      15.8.2   Execution of a RETURN
                               Statement..................  15-16
                      15.8.3   Alternate Return...........  15-17
                      15.8.4   Definition Status..........  15-17
               15.9   Arguments and Common Blocks.........  15-18
                      15.9.1   Dummy Arguments............  15-18
                      15.9.2   Actual Arguments...........  15-18
                      15.9.3   Association of Dummy and
                               Actual Arguments...........  15-19
                      15.9.4   Common Blocks..............  15-24
               15.10  Table of Intrinsic Functions........  15-25
                      15.10.1  Restrictions on Range of
                               Arguments and
                               Results....................  15-31



































                                  - ii -







                                                   ANSI X3J3/90.4



                        16.  BLOCK_DATA_SUBPROGRAM

          Block data subprograms  are  used  to  provide  initial
          values for variables and array elements in named common
          blocks.

          A block data subprogram is a program unit  that  has  a
          BLOCK  DATA  statement as its first statement.  A block
          data subprogram is nonexecutable.  There  may  be  more
          than   one  block  data  subprogram  in  an  executable
          program.

          16.1  BLOCK_DATA_Statement

          The form of a BLOCK DATA statement is:

                               BLOCK DATA [sub___]

          where sub is  the  symbolic  name  of  the  block  data
          subprogram in which the BLOCK DATA statement appears.

          The optional name sub is a  global  name  (18.1.1)  and
          must  not  be  the  same  as  the  name  of an external
          procedure, main program, common block, or  other  block
          data  subprogram  in  the same executable program.  The
          name sub must not be the same as any local name in  the
          subprogram.

          16.2  Block_Data_Subprogram_Restrictions

          The BLOCK DATA statement must appear only as the  first
          statement  of  a block data subprogram.  The only other
          statements that may appear in a block  data  subprogram
          are   IMPLICIT,  PARAMETER,  DIMENSION,  COMMON,  SAVE,
          EQUIVALENCE, DATA, END, and type-statements.  Note that
          comment lines are permitted.

          If an entity in  a  named  common  block  is  initially
          defined,  all  entities  having  storage  units  in the
          common block storage sequence must be specified even if
          they  are  not  all  initially  defined.  More than one
          named common block may have entities initially  defined
          in a single block data subprogram.

          Only an entity in a named common block may be initially
          defined in a block data subprogram.  Note that entities
          associated  with  an  entity  in  a  common  block  are
          considered to be in that common block.

          The same named common block may  not  be  specified  in
          more  than  one  block  data  subprogram  in  the  same



          FORTRAN 77 Full Language                      Page 16-1







          BLOCK DATA SUBPROGRAM                    ANSI X3J3/90.4



          executable program.

          There must not be more  than  one  unnamed  block  data
          subprogram in an executable program.


















































          FORTRAN 77 Full Language                      Page 16-2











                                 CONTENTS


          16.  BLOCK DATA SUBPROGRAM.......................  16-1
               16.1  BLOCK DATA Statement..................  16-1
               16.2  Block Data Subprogram
                     Restrictions..........................  16-1















































                                   - i -







                                                   ANSI X3J3/90.4



                      17.  ASSOCIATION_AND_DEFINITION

          17.1  Storage_and_Association

          Storage sequences are used  to  describe  relationships
          that exist among variables, array elements, substrings,
          common blocks, and arguments.

          17.1.1  Storage_Sequence.   A  storage  sequence  is  a
          sequence (2.1) of storage units.  The size of a storage
          sequence is the number of storage units in the  storage
          sequence.   A  storage unit is a character storage unit
          or a numeric storage unit.

          A variable or array element of type integer,  real,  or
          logical  has  a storage sequence of one numeric storage
          unit.

          A variable or array element of type double precision or
          complex  has  a storage sequence of two numeric storage
          units.  In a complex storage sequence,  the  real  part
          has  the  first storage unit and the imaginary part has
          the second storage unit.

          A  variable,  array  element,  or  substring  of   type
          character  has  a storage sequence of character storage
          units.  The number of character storage  units  in  the
          storage sequence is the length of the character entity.
          The order of the sequence corresponds to  the  ordering
          of character positions (4.8).

          Each array and common  block  has  a  storage  sequence
          (5.2.5 and 8.3.2).

          17.1.2  Association_of_Storage_Sequences.  Two  storage
          sequences  s_918 and s_928 are associated if the ith storage
          unit of s_918 is the same as the jth storage unit of  s_928.
          This  causes  the  (i+k)th storage unit of s_918 to be the
          same as the (j+k)th  storage  unit  of  s_928,  for  each
          integer  k such that 1 &lt; i+k &lt; size of s_918 and 1 &lt; j+k &lt;
           size of s_928.

          17.1.3  Association_of_Entities.  Two variables,  array
          elements, or substrings are associated if their storage
          sequences are associated.   Two  entities  are  totally
          associated if they have the same storage sequence.  Two
          entities  are  partially   associated   if   they   are
          associated but not totally associated.

          The definition status and value of  an  entity  affects
          the  definition  status  and  value  of  any associated



          FORTRAN 77 Full Language                      Page 17-1







          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4



          entity.  An EQUIVALENCE statement, a COMMON  statement,
          an  ENTRY  statement (15.7.3), or a procedure reference
          (argument association) may cause association of storage
          sequences.

          An EQUIVALENCE statement causes association of entities
          only  within  one  program  unit,  unless  one  of  the
          equivalenced entities is also in a common block (8.3).

          Arguments and COMMON statements cause entities  in  one
          program  unit  to  become  associated  with entities in
          another  program  unit  (8.3  and  15.9).   Note   that
          association between actual and dummy arguments does not
          imply association of storage sequences except when  the
          actual  argument  is  the  name  of  a  variable, array
          element, array, or substring.

          In a function subprogram, an ENTRY statement causes the
          entry  name  to  become associated with the name of the
          function  subprogram  which  appears  in  the  FUNCTION
          statement.

          Partial  association  may  exist   only   between   two
          character  entities  or  between  a double precision or
          complex entity and an entity  of  type  integer,  real,
          logical, double precision, or complex.

          Except for character entities, partial association  may
          occur  only  through the use of COMMON, EQUIVALENCE, or
          ENTRY statements.  Partial association must  not  occur
          through  argument  association, except for arguments of
          type character.

          In the example:

                     REAL A(4)a,B
                     COMPLEX C(2)
                     DOUBLE PRECISION D
                     EQUIVALENCE (C(2),A(2),B), (A,D)

          the third storage unit of C, the second storage unit of
          A,  the  storage unit of B, and the second storage unit
          of D are specified as the same.  The storage  sequences
          may be illustrated as:

            storage unit     1  |   2       3  |   4      5  |
                        |7|99  ----C(1)----   ----C(2)----
                                |  A(1)   A(2)    A(3)|7|7|9999  A(4)|
                                       |7|7|7|999999  --B--
                                   -----D-----
7                                |
7                                               |8|7|


9


          FORTRAN 77 Full Language                      Page 17-2







          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4



          A(2) and B are totally associated.  The  following  are
          partially  associated:  A(1)  and  C(1), A(2) and C(2),
          A(3) and C(2), B and C(2), A(1) and D, A(2)  and  D,  B
          and  D, C(1) and D, and C(2) and D.  Note that although
          C(1) and C(2) are each associated with D, C(1) and C(2)
          are not associated with each other.

          Partial association of character entities  occurs  when
          some, but not all, of the storage units of the entities
          are the same.  In the example:

                     CHARACTER A*4,B*4,C*3
                     EQUIVALENCE (A(2:3),B,C)

          A, B, and C are partially associated.

          17.2  Events_That_Cause_Entities_to_Become_Defined

          Variables,  array  elements,  and   substrings   become
          defined as follows:

             (1) Execution  of   an   arithmetic,   logical,   or
                 character assignment statement causes the entity
                 that precedes the equals to become defined.

             (2) As execution of  an  input  statement  proceeds,
                 each  entity  that  is  assigned  a value of its
                 corresponding type from the input medium becomes
                 defined at the time of such assignment.

             (3) Execution of  a  DO  statement  causes  the  DO-
                 variable to become defined.

             (4) Beginning of execution of action specified by an
                 implied-DO  list  in  an  input/output statement
                 causes   the   implied-DO-variable   to   become
                 defined.

             (5) A  DATA  statement  causes  entities  to  become
                 initially  defined at the beginning of execution
                 of an executable program.

             (6) Execution of  an  ASSIGN  statement  causes  the
                 variable in the statement to become defined with
                 a statement label value.

             (7) When an entity of a given type becomes  defined,
                 all totally associated entities of the same type
                 become  defined  except  that  entities  totally
                 associated   with  the  variable  in  an  ASSIGN
                 statement  become  undefined  when  the   ASSIGN



          FORTRAN 77 Full Language                      Page 17-3







          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4



                 statement is executed.

             (8) A reference  to  a  subprogram  causes  a  dummy
                 argument  to become defined if the corresponding
                 actual argument is defined with a value that  is
                 not  a  statement  label value.  Note that there
                 must be agreement between  the  actual  argument
                 and the dummy argument (15.9.3).

             (9) Execution   of   an    input/output    statement
                 containing   an  input/output  status  specifier
                 causes the specified integer variable  or  array
                 element to become defined.

            (10) Execution of an  INQUIRE  statement  causes  any
                 entity  that  is  assigned  a  value  during the
                 execution of the statement to become defined  if
                 no error condition exists.

            (11) When  a  complex  entity  becomes  defined,  all
                 partially   associated   real   entities  become
                 defined.

            (12) When both  parts  of  a  complex  entity  become
                 defined as a result of partially associated real
                 or  complex  entities  becoming   defined,   the
                 complex entity becomes defined.

            (13) When all characters of a character entity become
                 defined, the character entity becomes defined.

          17.3  Events_That_Caused_Entities_to_Become_Undefined

          Variables,  array  elements,  and   substrings   become
          undefined as follows:

             (1) All entities are undefined at the  beginning  of
                 execution  of an executable program except those
                 entities initially defined by DATA statements.

             (2) When an entity of a given type becomes  defined,
                 all  totally  associated  entities  of different
                 type become undefined.

             (3) Execution of  an  ASSIGN  statement  causes  the
                 variable in the statement to become undefined as
                 an integer.  Entities that are  associated  with
                 the variable become undefined.

             (4) When an entity  of  type  other  than  character
                 becomes   defined,   all   partially  associated



          FORTRAN 77 Full Language                      Page 17-4







          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4



                 entities become  undefined.   However,  when  an
                 entity of type real is partially associated with
                 an entity of type complex,  the  complex  entity
                 does  not  become undefined when the real entity
                 becomes defined and the  real  entity  does  not
                 become undefined when the complex entity becomes
                 defined.  When an  entity  of  type  complex  is
                 partially associated with another entity of type
                 complex, definition of one entity does not cause
                 the other to become undefined.

             (5) When the evaluation  of  a  function  causes  an
                 argument  of the function or an entity in common
                 to become defined and  if  a  reference  to  the
                 function  appears  in an expression in which the
                 value of the function is not needed to determine
                 the  value  of the expression, then the argument
                 or the entity in common becomes  undefined  when
                 the expression is evaluated (6.6.1).

             (6) The execution of a RETURN statement  or  an  END
                 statement   within   a   subprogram  causes  all
                 entities  within  the   subprogram   to   become
                 undefined except for the following:

                (a) Entities in blank common

                (b) Initially defined entities that have  neither
                    been redefined nor become undefined

                (c) Entities specified by SAVE statements

                (d) Entities in a named common block that appears
                    in the subprogram and appears in at least one
                    other program unit that is either directly or
                    indirectly referencing the subprogram

             (7) When an error condition or end-of-file condition
                 occurs  during  execution of an input statement,
                 all of the  entities specified by the input list
                 of the statement become undefined.

             (8) Execution of a  direct  access  input  statement
                 that  specifies  a  record  that  has  not  been
                 previously written causes all  of  the  entities
                 specified  by the input list of the statement to
                 become undefined.

             (9) Execution of  an  INQUIRE  statement  may  cause
                 entities to become undefined (12.10.3).




          FORTRAN 77 Full Language                      Page 17-5







          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4



            (10) When any character of a character entity becomes
                 undefined,    the   character   entity   becomes
                 undefined.

            (11) When an entity becomes undefined as a result  of
                 conditions  described  in  (5) through (10), all
                 totally associated entities become undefined and
                 all  partially associated entities of type other
                 than character become undefined.













































          FORTRAN 77 Full Language                      Page 17-6











                                 CONTENTS


          17.  ASSOCIATION AND DEFINITION..................  17-1
               17.1  Storage and Association...............  17-1
                     17.1.1  Storage Sequence..............  17-1
                     17.1.2  Association of Storage
                             Sequences.....................  17-1
                     17.1.3  Association of
                             Entities......................  17-1
               17.2  Events That Cause Entities to Become
                     Defined...............................  17-3
               17.3  Events That Caused Entities to Become
                     Undefined.............................  17-4








































                                   - i -







                                                   ANSI X3J3/90.4



                 18.  SCOPES_AND_CLASSES_OF_SYMBOLIC_NAMES

          A symbolic name consists of  one  to  six  alphanumeric
          characters,  the first of which must be a letter.  Some
          sequences  of   characters,   such   as   format   edit
          descriptors and keywords that uniquely identify certain
          statements, for example, GO TO, READ, FORMAT, etc,  are
          not symbolic names in such occurrences nor do they form
          the  first  characters  of  symbolic  names   in   such
          occurrences.

          18.1  Scope_of_Symbolic_Names

          The scope of a symbolic name is an executable  program,
          a  program unit, a statement function statement,  or an
          implied-DO list in a DATA statement.

          The name of the main program and  the  names  of  block
          data  subprograms, external functions, subroutines, and
          common blocks have a scope of an executable program.

          The names of variables,  arrays,  constants,  statement
          functions,  intrinsic  functions,  and dummy procedures
          have a scope of a program unit.

          The names of variables that appear as  dummy  arguments
          in  a statement function statement have a scope of that
          statement.

          The names of variables that appear as  the  DO-variable
          of  an  implied-DO  in a DATA statement have a scope of
          the implied-DO list.

          18.1.1  Global_Entities.   The  main  program,   common
          blocks, subprograms, and external procedures are global
          entities of an executable  program.   A  symbolic  name
          that  identifies  a  global  entity must not be used to
          identify any other global entity in the same executable
          program.

          18.1.1.1  Classes_of_Global_Entities.  A symbolic  name
          in  one  of the following classes is a global entity in
          an executable program:

             (1) Common block

             (2) External function

             (3) Subroutine





          FORTRAN 77 Full Language                      Page 18-1







          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4



             (4) Main program

             (5) Block data subprogram

          18.1.2  Local_Entities.  The symbolic name of  a  local
          entity identifies that entity in a single program unit.
          Within a program unit, a symbolic name that is  in  one
          class  of  entities  local to the program unit must not
          also be in another  class  of  entities  local  to  the
          program unit.  However, a symbolic name that identifies
          a local  entity  may,  in  a  different  program  unit,
          identify an entity of any class that is either local to
          that program unit or global to the executable  program.
          A  symbolic  name  that identifies a global entity in a
          program unit must not  be  used  to  identify  a  local
          entity  in that program unit, except for a common block
          name and an external function name (18.2.1 and 18.2.2).

          18.1.2.1  Classes_of_Local_Entities.  A  symbolic  name
          in  one of the following classes is a local entity in a
          program unit.

             (1) Array

             (2) Variable

             (3) Constant

             (4) Statement function

             (5) Intrinsic function

             (6) Dummy procedure

          A symbolic name that is a dummy argument of a procedure
          is classified as a variable, array, or dummy procedure.
          The  specification  and  usage  must  not  violate  the
          respective class rules.

          18.2  Classes_of_Symbolic_Names

          In a program unit, a symbolic name must not be in  more
          than  one  class  except  as  noted  in  the  following
          paragraphs of this section.  There are no  restrictions
          on  the  appearances  of  the  same  symbolic  name  in
          different program units of an executable program  other
          than those noted in this section.

          18.2.1  Common_block.  A symbolic name is the name of a
          common  block if and only if it appears as a block name
          in a COMMON statement (8.3).



          FORTRAN 77 Full Language                      Page 18-2







          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4



          A  common  block  name  is  global  to  the  executable
          program.

          A common block name in a program unit may also  be  the
          name  of  any  local  entity  other  than  a  constant,
          intrinsic function, or a local variable that is also an
          external  function in a function subprogram.  If a name
          is used for both a common block and a local entity, the
          appearance  of that name in any context other than as a
          common  block  name  in  a  COMMON  or  SAVE  statement
          identifies   only  the  local  entity.   Note  that  an
          intrinsic function name may be a common block name in a
          program  unit  that  does  not  reference the intrinsic
          function.

          18.2.2  External_Function.  A symbolic name is the name
          of  an  external  function  if  it  meets either of the
          following conditions:

             (1) The name appears immediately following the  word
                 FUNCTION  in  a  FUNCTION  statement or the word
                 ENTRY in an ENTRY statement  within  a  function
                 subprogram.

             (2) It is not  an  array  name,  character  variable
                 name,   statement   function   name,   intrinsic
                 function name,  dummy  argument,  or  subroutine
                 name,   and   every  appearance  is  immediately
                 followed by  a  left  parenthesis  except  in  a
                 type-statement,  in an EXTERNAL statement, or as
                 an actual argument.

          In a function subprogram, the name of a  function  that
          appears  immediately  after  the  word  FUNCTION  in  a
          FUNCTION statement or immediately after the word  ENTRY
          in  an  ENTRY  statement  may  also  be  the  name of a
          variable in that subprogram  (15.5.1).   At  least  one
          such  function name must be the name of a variable in a
          function subprogram.

          An external function name is global to  the  executable
          program.

          18.2.3  Subroutine.  A symbolic name is the name  of  a
          subroutine   if   it  meets  either  of  the  following
          conditions:

             (1) The name appears immediately following the  word
                 SUBROUTINE in a SUBROUTINE statement or the word
                 ENTRY in an ENTRY statement within a  subroutine
                 subprogram.



          FORTRAN 77 Full Language                      Page 18-3







          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4



             (2) The name appears immediately following the  word
                 CALL  in  a  CALL  statement  and is not a dummy
                 argument.

          A subroutine name is global to the executable program.

          18.2.4  Main_Program.  A symbolic name is the name of a
          main  program  if  and  only if it appears in a PROGRAM
          statement in the main program.

          A  main  program  name  is  global  to  the  executable
          program.

          18.2.5  Block_Data_Subprogram.  A symbolic name is  the
          name  of  a  block  data  subprogram  if and only if it
          appears in a BLOCK DATA statement.

          A  block  data  subprogram  name  is  global   to   the
          executable program.

          18.2.6  Array.  A symbolic name is the name of an array
          if  it appears as the array name in an array declarator
          (5.1) in a DIMENSION, COMMON, or type-statement.

          An array name is local to a program unit.

          An array name may be the same as a common block name.

          18.2.7  Variable.  A symbolic name is  the  name  of  a
          variable if it meets all of the following conditions:

             (1) It does not appear in a PARAMETER, INTRINSIC, or
                 EXTERNAL statement.

             (2) It is not the name of an array, subroutine, main
                 program, or block data subprogram.

             (3) It appears other than as the name  of  a  common
                 block,  the  name  of  an external function in a
                 FUNCTION statement, or an entry name in an ENTRY
                 statement in an external function.

             (4) It is  never  immediately  followed  by  a  left
                 parenthesis unless it is immediately preceded by
                 the word FUNCTION in a  FUNCTION  statement,  is
                 immediately  preceded  by  the  word ENTRY in an
                 ENTRY statement, or is at  the  beginning  of  a
                 character substring name (5.7.1).

          A variable  name  in  the  dummy  argument  list  of  a
          statement  function statement is local to the statement



          FORTRAN 77 Full Language                      Page 18-4







          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4



          function statement in which it occurs.  Note  that  the
          use  of  a  name  that  appears  in  Table 5 as a dummy
          argument of a statement function removes  it  from  the
          class  of  intrinsic  functions.   A variable name that
          appears as an implied-DO-variable in a  DATA  statement
          is  local  to  the implied-DO list.  All other variable
          names are local to a program unit.

          A statement function dummy argument name  may  also  be
          the  name  of a variable or common block in the program
          unit.  The appearance of the name in any context  other
          than  as  a  dummy  argument  of the statement function
          identifies the local variable  or  common  block.   The
          statement   function  dummy  argument  name  and  local
          variable name have  the  same  type  and,  if  of  type
          character, both have the same constant length.

          The name of an implied-DO-variable in a DATA  statement
          may  also  be the name of a variable or common block in
          the program unit.  The appearance of the  name  in  any
          context  other  than  as  an implied-DO-variable in the
          DATA statement identifies the local variable or  common
          block.  The implied- DO-variable and the local variable
          have the same type.

          18.2.8  Constant.  A symbolic name is  the  name  of  a
          constant  if  it  appears  as  a  symbolic  name  in  a
          PARAMETER statement.

          The symbolic name of a constant is local to  a  program
          unit.

          18.2.9  Statement_Function.  A  symbolic  name  is  the
          name  of  a  statement function if a statement function
          statement (15.4) is present for that symbolic name  and
          it is not an array name.

          A statement function name is local to a  program  unit.
          A  statement  function name may be the same as a common
          block name.

          18.2.10  Intrinsic_Function.  A symbolic  name  is  the
          name  of  an  intrinsic function if it meets all of the
          following  conditions:

             (1) The name appears in the Specific Name column  or
                 the Generic Name column of Table 5.

             (2) It is not  an  array  name,  statement  function
                 name, subroutine name, or dummy argument name.




          FORTRAN 77 Full Language                      Page 18-5







          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4



             (3) Every appearance of the symbolic name, except in
                 an  INTRINSIC statement, a type-statement, or as
                 an actual argument, is immediately  followed  by
                 an actual argument list enclosed in parentheses.

          An intrinsic function name is local to a program unit.

          18.2.11  Dummy_Procedure.  A symbolic name is the  name
          of  a  dummy procedure if the name appears in the dummy
          argument list  of  a  FUNCTION,  SUBROUTINE,  or  ENTRY
          statement  and  meets  one  or  more  of  the following
          conditions:

             (1) It appears in an EXTERNAL statement.

             (2) It appears immediately following the  word  CALL
                 in a CALL statement.

             (3) It is not an array name  or  character  variable
                 name,   and   every  appearance  is  immediately
                 followed by  a  left  parenthesis  except  in  a
                 type-statement,  in  an EXTERNAL statement, in a
                 CALL statement,  as  a  dummy  argument,  as  an
                 actual  argument, or as a common block name in a
                 COMMON or SAVE statement.

          A dummy procedure name is local to a program unit.



























          FORTRAN 77 Full Language                      Page 18-6











                                 CONTENTS


          18.  SCOPES AND CLASSES OF SYMBOLIC NAMES........  18-1
               18.1  Scope of Symbolic Names...............  18-1
                     18.1.1   Global Entities..............  18-1
                     18.1.2   Local Entities...............  18-2
               18.2  Classes of Symbolic Names.............  18-2
                     18.2.1   Common block.................  18-2
                     18.2.2   External Function............  18-3
                     18.2.3   Subroutine...................  18-3
                     18.2.4   Main Program.................  18-4
                     18.2.5   Block Data Subprogram........  18-4
                     18.2.6   Array........................  18-4
                     18.2.7   Variable.....................  18-4
                     18.2.8   Constant.....................  18-5
                     18.2.9   Statement Function...........  18-5
                     18.2.10  Intrinsic Function...........  18-5
                     18.2.11  Dummy Procedure..............  18-6



































                                   - i -







                                                   ANSI X3J3/90.4



             APPENDIX_A:_CRITERIA,_CONFLICTS,_AND_PORTABILITY


          A1.  Criteria

          The principal criteria used in developing this  FORTRAN
          standard were:

             (1) Interchangeability of FORTRAN  programs  between
                 processors

             (2) Compatibility  with   ANSI   X3.9-1966,   allied
                 standards, and existing practices

             (3) Consistency and simplicity to user

             (4) Suitability for  efficient  processor  operation
                 for  a  wide  range  of  computing  equipment of
                 varying structure and power

             (5) Allowance for future growth in the language

             (6) Achievement  of   capabilities   not   currently
                 available,     but    needed    for    processes
                 appropriately expressed in FORTRAN

             (7) Acceptability by a significant portion of users

             (8) Improved ability to  use  FORTRAN  programs  and
                 data  in  conjunction  with  other languages and
                 environments


          A2.  Conflicts_with_ANSI_X3.9-1966

          An extremely important consideration in the preparation
          of this standard was the minimization of conflicts with
          the previous standard, ANSI X3.9-1966.   This  standard
          includes  changes that create conflicts with ANSI X3.9-
          1966 only when such changes were necessary  to  correct
          an  error  in  the  previous  standard or to add to the
          power of the FORTRAN language in a significant  manner.
          The following is a list of known conflicts:

             (1) A line that contains only  blank  characters  in
                 columns  1  through  72 is a comment line.  ANSI
                 X3.9-1966 allowed such a line to be the  initial
                 line of a statement.

             (2) Columns 1 through 5 of a continuation line  must
                 contain  blanks.   A published interpretation of



          FORTRAN 77 Full Language                       Page A-1







          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4



                 ANSI X3.9-1966 specified that columns 1-5  of  a
                 continuation line may contain any character from
                 the FORTRAN character set except that  column  1
                 must not contain a C.

             (3) Hollerith constants and Hollerith data  are  not
                 permitted  in  this  standard.   ANSI  X3.9-1966
                 permitted the use of Hollerith constants in DATA
                 and  CALL  statements,  the  use of noncharacter
                 list items in formatted input/output  statements
                 with  A edit descriptors, and the referencing of
                 noncharacter arrays as formats.  Note that the H
                 edit  (field) descriptor is permitted; it is not
                 a Hollerith constant.

             (4) The  value  of  each  comma-separated  subscript
                 expression  in  a  subscript must not exceed its
                 corresponding upper bound declared for the array
                 name in the program unit.  In the example:

                    DIMENSION A(10,5)
                    Y=A(11,1)

                 The reference to A(11,1) is  not  permitted  for
                 the  array  A(10,5).  ANSI X3.9-1966 permitted a
                 subscript expression to exceed its corresponding
                 upper  bound  if the maximum subscript value for
                 the array was not exceeded.

             (5) Only  an  array  that  is  declared  as  a  one-
                 dimensional array in the program unit may have a
                 one-dimensional  subscript  in  an   EQUIVALENCE
                 statement.  In the example:

                    DIMENSION B(2,3,4), C(4,8)
                    EQUIVALENCE (B(23), C(1,1))

                 B(23)  is   not   permitted.    ANSI   X3.9-1966
                 permitted  arrays  that were declared as two- or
                 three-dimensional  arrays  to   appear   in   an
                 EQUIVALENCE  statement  with  a  one-dimensional
                 subscript.

             (6) A  name  must  not  have  its  type   explicitly
                 specified  more  than  once  in  a program unit.
                 ANSI X3.9-1966 did not explicitly  have  such  a
                 prohibition.

             (7) This standard does  not  permit  a  transfer  of
                 control into the range of a DO-loop from outside
                 the range.   The  range  of  a  DO-loop  may  be



          FORTRAN 77 Full Language                       Page A-2







          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4



                 entered only by the execution of a DO statement.
                 ANSI X3.9-1966  permitted  transfer  of  control
                 into  the  range  of  a  DO-loop  under  certain
                 conditions.  This involved the concept  referred
                 to as "extended range of a DO."

             (8) A labeled END statement could conflict with  the
                 initial line of a statement in an ANSI X3.9-1966
                 standard-conforming program.

             (9) A record must not be written  after  an  endfile
                 record in a sequential file.  ANSI X3.9-1966 did
                 not   prohibit    this,    but    provided    no
                 interpretation  for  the  reading  of an endfile
                 record.

            (10) A sequential file may not contain both formatted
                 and    unformatted    records.     A   published
                 interpretation of ANSI X3.9-1966 specified  that
                 this was permitted.

            (11) Negative   values    for    input/output    unit
                 identifiers  are  prohibited  in  this standard.
                 ANSI X3.9-1966 did not explicitly prohibit  them
                 for variable unit identifiers.

            (12) A simple I/O list  enclosed  in  parentheses  is
                 prohibited from appearing in an I/O list.

                 This requires that  parentheses  enclosing  more
                 than  one I/O list item must mark an implied DO-
                 loop.  The restriction was imposed to  eliminate
                 potential  syntactic  ambiguities  introduced by
                 complex constants in list-directed output lists.
                 As   all   the   parentheses   referred  to  are
                 redundant, a program can be made conforming with
                 this  standard by deleting redundant parentheses
                 enclosing more than one  list  item  in  an  I/O
                 list.

            (13) The definition of an entity associated  with  an
                 entity  in an input list occurs at the same time
                 as the definition  of  the  list  entity.   ANSI
                 X3.9-1966  delayed  the  definition  of  such an
                 associated entity until the end of execution  of
                 the input statement.

            (14) Reading into an H edit (field) descriptor  in  a
                 FORMAT statement is prohibited in this standard.





          FORTRAN 77 Full Language                       Page A-3







          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4



            (15) The range of a scale factor  for  E,  D,  and  G
                 output   fields   is  restricted  to  reasonable
                 values.  ANSI X3.9-1966 had no such restriction,
                 but  did  not  provide a clear interpretation of
                 the meaning of the unreasonable values.

            (16) A processor must not produce  a  numeric  output
                 field  containing  a  negative zero.  ANSI X3.9-
                 1966 required this if the internal  value  of  a
                 real or double precision datum was negative.

            (17) On  output,  the  I  edit  descriptor  must  not
                 produce unnecessary leading zeros.

            (18) On  output,  the  F  edit  descriptor  must  not
                 produce  unnecessary  leading  zeros, other than
                 the optional leading zero for a value less  than
                 one.

            (19) Following the E or D in an E or D output  field,
                 a  +  or  - is required immediately prior to the
                 exponent  field.   This  improves  compatibility
                 with   American   National   Standard   for  the
                 Representation of Numeric  Values  in  Character
                 Strings   for   Information   Interchange,  ANSI
                 X3.42-1975.  ANSI X3.9-1966 permitted a blank as
                 a replacement for + in the exponent sign.

            (20) An intrinsic function name that is  used  as  an
                 actual  argument  must  appear  in  an INTRINSIC
                 statement rather  than  an  EXTERNAL  statement.
                 Note  that the intrinsic function class includes
                 the basic external function class of ANSI  X3.9-
                 1966.

            (21) The appearance of an intrinsic function name  in
                 a  type-statement  that  conflicts with the type
                 specified in Table 5 is not sufficient to remove
                 the  name from the intrinsic function class.  In
                 ANSI X3.9-1966, this condition was sufficient to
                 remove  the  name  from  the  intrinsic function
                 class.

            (22) More intrinsic function names  have  been  added
                 and   could   conflict   with   the   names   of
                 subprograms.  These names are ACOS, ANINT, ASIN,
                 CHAR,  COSH,  DACOS,  DASIN,  DCOSH, DDIM, DINT,
                 DNINT, DPROD, DSINH, DTAN, DTANH, ICHAR, IDNINT,
                 INDEX, LEN, LGE, LGT, LLE, LLT, LOG, LOG10, MAX,
                 MIN, NINT, SINH, and TAN.




          FORTRAN 77 Full Language                       Page A-4







          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4



            (23) The units of the arguments and  results  of  the
                 intrinsic    functions   (and   basic   external
                 functions) were not specified in ANSI  X3.9-1966
                 and  are  specified in this standard.  The range
                 of the  arguments  and  results  has  also  been
                 specified.     These   specifications   may   be
                 different from those  used  on  some  processors
                 conforming to ANSI X3.9-1966.

            (24) An executable program must not contain more than
                 one  unnamed  block data subprogram.  ANSI X3.9-
                 1966 did not have this prohibition and could  be
                 interpreted to permit more than one.


          A3.  Standard_Items_That_Inhibit_Portability

          Although the primary purpose of  this  standard  is  to
          promote portability of FORTRAN programs, there are some
          items in it that tend to inhibit portability.

             (1) Procedures  written  in  languages  other   than
                 FORTRAN may not be portable.

             (2) Because the  collating  sequence  has  not  been
                 completely   specified,   character   relational
                 expressions do not  necessarily  have  the  same
                 value on all processors.  However, the intrinsic
                 functions LGE, LGT, LLE, and LLT can be used  to
                 provide  a more portable comparison of character
                 entities.

             (3) Character data, H edit  descriptors,  apostrophe
                 edit  descriptors, and comment lines may include
                 characters that are acceptable to one  processor
                 but unacceptable to another processor.

             (4) No explicit requirements are specified for  file
                 names.   A  file  name that is acceptable to one
                 processor  may  be   unacceptable   to   another
                 processor.

             (5) Input/output unit numbers and unit  capabilities
                 may vary among processors.










          FORTRAN 77 Full Language                       Page A-5







          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4



          A4.  Recommendation_for_Enhancing_Portability

          To  enhance  the  development   of   portable   FORTRAN
          programs,  a  producer  should  provide  some  means of
          identifying  nonstandard  syntax   supported   by   his
          processor.    Alternatives   for   doing  this  include
          appropriate documentation, features of  the  processor,
          and other means.














































          FORTRAN 77 Full Language                       Page A-6











                                 CONTENTS

          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITY..  A
          -1
          A1.     Criteria..................................  A-1
          A2.     Conflicts with ANSI X3.9-1966.............  A-1
          A3.     Standard Items That Inhibit
          Portability.......................................  A-5
          A4.     Recommendation for Enhancing
          Portability.......................................  A-6












































                                   - i -







                                                   ANSI X3J3/90.4



                         APPENDIX_B:_SECTION_NOTES


          B1.  Section_1_Notes

          What this standard calls a "processor" is any mechanism
          that can carry out the actions of a program.  Commonly,
          this may be any of these:

             (1) The combined actions of a  computer  (hardware),
                 its operating system, a compiler, and a loader

             (2) An interpreter

             (3) The mind of a human, perhaps with  the  help  of
                 paper and pencil

          When you read this standard, it is  important  to  keep
          its  point  of  view  in mind.  The standard is written
          from the point  of  view  of  a  programmer  using  the
          language,  and  not  from  the  point  of  view  of the
          implementation of a  processor.   This  point  of  view
          affects the way you should interpret the standard.  For
          example, in 3.3 the assertion is made:

                 "... a statement must contain no more than  1320
                 characters."

          This  means  that  if  a  programmer  writes  a  longer
          statement,  his  program  is  not  standard conforming.
          Therefore, it will get different treatment on different
          processors.   Some  processors will accept the program,
          and some will not.  Some may even seemingly accept  the
          program  but  process  it  incorrectly.   The assertion
          means  that  all  standard-conforming  processors  must
          accept  statements up to 1320 characters long.  That is
          the  only   inference   about   a   standard-conforming
          processor that can be made from the assertion.

          The assertion does not mean that a  standard-conforming
          processor   is   prohibited   from   accepting   longer
          statements.  Accepting longer statements  would  be  an
          extension.

          The assertion does not mean that a  standard-conforming
          processor  must  diagnose  statements  longer than 1320
          characters, although it may do so.

          In general, a standard-conforming processor is one that
          accepts  all standard-conforming programs and processes
          them according to the rules of  this  standard.   Thus,



          FORTRAN 77 Full Language                       Page B-1







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          the  specification  of  a standard-conforming processor
          must be inferred from this document.

          In some places, explicit prohibitions  or  restrictions
          are   stated,   such   as  the  above  statement-length
          restriction.  Such assertions restrict what programmers
          can  write  in standard-conforming programs and have no
          more weight in the standard than  an  omitted  feature.
          For  example,  there  is  no  mention  anywhere  in the
          standard of double precision integers.  Because  it  is
          omitted,  programmers  must  not  use  this  feature in
          standard-conforming  programs.   A  standard-conforming
          processor  may  or  may  not provide it or diagnose its
          use.  Thus, an explicit prohibition (such as statements
          longer  than  1320 characters) and an omission (such as
          double  precision  integers)  are  equivalent  in  this
          standard.


          B2.  Section_2_Notes

          Some of  the  terminology  used  in  this  document  is
          different  from that used to describe other programming
          languages.  The following indicates  terms  from  other
          languages  that  are  approximately  equivalent to some
          FORTRAN terms.

              FORTRAN_______                Other Languages_______________

              Variable               Simple Variable
              Array Element          Subscripted Variable
              Subscript Expression   Subscript
              Subscript              (none)
              Dummy Argument         Formal Argument, Formal
                                       Parameter
              Actual Argument        Actual Parameter

          In  particular,  the  FORTRAN  terms  "subscript"   and
          "subscript  expression"  should be studied carefully by
          readers who are unfamiliar with this standard (5.4).

          The term "symbolic name"  is  frequently  shortened  to
          "name" throughout the standard.


          B3.  Section_3_Notes

          A  partial  collating  sequence   is   specified.    If
          possible,  a processor should use the American National
          Standard Code for Information Interchange,  ANSI  X3.4-
          1977   (ASCII),   sequence  for  the  complete  FORTRAN



          FORTRAN 77 Full Language                       Page B-2







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          character set.

          When a continuation line follows a  comment  line,  the
          continuation  line is part of the current statement; it
          is not a continuation of the comment line.   A  comment
          line is not part of a statement.

          The  standard  does  not   restrict   the   number   of
          consecutive   comment   lines.    The   limit   of   19
          continuation lines permitted for a statement should not
          be  construed  as  being  a limitation on the number of
          consecutive comment lines.

          There are 99999 unique statement labels and a processor
          must  accept  99999  as  a statement label.  However, a
          processor may have an implementation limit on the total
          number  of  unique statement labels in one program unit
          (3.4).

          Blanks  and  leading  zeros  are  not  significant   in
          distinguishing  between statement labels.  For example,
          123, 1 23, and 0123 are all forms of the same statement
          label.


          B4.  Section_4_Notes

          A processor must not consider a  negative  zero  to  be
          different from a positive zero.

          ANSI X3.9-1966 used the  term  "constant"  to  mean  an
          unsigned   constant.    This  standard  uses  the  term
          "constant" to  have  its  more  normal  meaning  of  an
          optionally  signed  constant when describing arithmetic
          constants.   The  term  "unsigned  constant"  is   used
          wherever   a  leading  sign  is  not  permitted  on  an
          arithmetic constant.

          A character constant is a representation of a character
          value.   The  delimiting  apostrophes  are  part of the
          representation  but  not  part  of  the  value;  double
          apostrophes  are  used  to  represent a single embedded
          apostrophe.  For example:











          FORTRAN 77 Full Language                       Page B-3







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



8                       ____________________________

                          Character      Character
                          Constant         Value
8                       ____________________________

                            'CAT'           CAT
                           'ISN''T'        ISN'T
                        '''ISN''''T'''   'ISN''T'
8                       ____________________________
7                      |7|7|7|7|7|7|7|






                                      |7|7|7|7|7|7|7|






                                                  |7|7|7|7|7|7|7|








          Note  that  the  value  of   the   character   constant
          '''ISN''''T''' is a representation of another character
          constant.

          Some programs that used an extension to ANSI  X3.9-1966
          that   permitted  a  Hollerith  constant  delimited  by
          apostrophes instead of the n_H form do  not  conform  to
          this standard.


          B5.  Section_5_Notes

          For the array declarator A(2,3), the use of  the  array
          name   A   in   the  proper  context,  such  as  in  an
          input/output list, specifies the  following  order  for
          the  array  elements:   A(1,1), A(2,1), A(1,2), A(2,2),
          A(1,3), A(2,3).


          B6.  Section_6_Notes

          If V is a variable name, the interpretation  and  value
          of  V,  +V,  and  (V) are the same.  However, the three
          forms may not  always  be  used  interchangeably.   For
          example,  the  forms +V and (V) may not be used as list
          items of a READ statement or as actual arguments  of  a
          procedure   reference  if  the  procedure  defines  the
          corresponding dummy argument.


          B7.  Section_7_Notes

          Although  DIMENSION  statements,  type-statements,  and
          statement   function   statements   are  classified  as
          nonexecutable statements, they may  contain  references
          that are executed.  Expressions containing variables in
          DIMENSION  statements  and   type-statements   may   be
          evaluated  whenever  a reference to the program unit is
          executed.   The  expression  in  a  statement  function
          statement is evaluated whenever a function reference to
          the statement function is executed.
9


          FORTRAN 77 Full Language                       Page B-4







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          B8.  Section_8_Notes

          If a processor allows a one-dimensional subscript for a
          multidimensional array in an EQUIVALENCE statement, the
          interpretation  should  be  as  though  the   subscript
          expression  were  the  leftmost  one  and  the  missing
          subscript expressions each have their respective  lower
          dimension bound value.

          ANSI X3.9-1966  permitted  two-  and  three-dimensional
          arrays  to  have  a  one-dimensional  subscript  in  an
          EQUIVALENCE statement.  The following table can be used
          to   convert   a   one-dimensional   subscript  to  the
          corresponding multidimensional subscript:

8            ___________________________________________________

             n_   Dimension    Subscript   Subscript
                                Value
8            ___________________________________________________

             1      (d918)          s       (s)
8            ___________________________________________________

             2    (d918,d928)         s       (1+MOD(s-1,d918),
                                           1+(s-1)/d91
7            ___________________________________________________

             3   (d918,d928,d938)       s       (1+MOD(s-1,d918),
                                           1+MOD((s-1)/d918,d928),
                                           1+(s-1)/(d918*d928))
8            ___________________________________________________
7           |7|7|7|7|7|7|7|7|7|7|7|7|7|












              |7|7|7|7|7|7|7|7|7|7|7|7|7|












                           |7|7|7|7|7|7|7|7|7|7|7|7|7|












                                       |7|7|7|7|7|7|7|7|7|7|7|7|7|












                                                              |7|7|7|7|7|7|7|7|7|7|7|7|7|














          Each expression in the last  column  of  the  table  is
          evaluated   according   to   the   rules   for  integer
          expressions.

          A processor that allows additional intrinsic  functions
          should  allow  their  names  to  appear in an INTRINSIC
          statement.

          As an extension  to  ANSI  X3.9-1966,  many  processors
          permitted  the  retention  of  certain  values  at  the
          completion of execution of a subprogram, such as  local
          variables  and  arrays, initially defined data that had
          been changed, and named common blocks not specified  in
          the  main  program, whereas other processors prohibited
          the retention of such values.  In ANSI  X3.9-1966  such
          entities  were undefined at the completion of execution
          of the subprogram, and therefore a  standard-conforming
          program  could  not  retain  these  values.   The  SAVE
          statement provides a facility for data retention.

9


          FORTRAN 77 Full Language                       Page B-5







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          B9.  Section_9_Notes

          An  entity  is  "initially  defined"  only  by  a  DATA
          statement.   An  assignment  statement  may  define  or
          redefine an entity but it does not  "initially  define"
          the entity.

          Initially defined entities in a subprogram  may  become
          undefined at the execution of a RETURN or END statement
          if they are assigned any value, including their initial
          value,  during  the execution of the executable program
          (see 8.9 and 15.8.4).


          B10.  Section_10_Notes

          All four types of  implied  arithmetic  conversion  are
          permitted in an arithmetic assignment statement.


          B11.  Section_11_Notes

          A logical IF statement must not contain another logical
          IF  statement  or a block IF statement; however, it may
          contain an arithmetic IF statement.  The  following  is
          allowed:

                    IF (logical expr.) IF (arithmetic expr.) s_918,s_928,s_93
9          A processor is not required to evaluate  the  iteration
          count  in  a  DO-loop  if  the  same effect is achieved
          without evaluation.  However, the processor must  allow
          redefinition  of  variables  and  array  elements  that
          appear after the equals in a DO  statement  during  the
          execution  of  the DO-loop without affecting the number
          of times the DO-loop is executed and without  affecting
          the value by which the DO-variable is incremented.

          If J1 &gt; J2, ANSI X3.9-1966 does not allow execution  of
          the following DO statement:

                               DO 100 J=J1,J2

          Some processors that allowed such a case  executed  the
          range of the DO-loop once, whereas other processors did
          not execute the range of the  DO-loop.   This  standard
          allows  such  a  case  and  requires that the processor
          execute the range  of  the  DO-loop  zero  times.   The
          following  change to the DO statement will require that
          the processor execute the range at least once:




          FORTRAN 77 Full Language                       Page B-6







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



                               DO 100 J=J1,MAX(J1,J2)

          References  to  function  procedures   and   subroutine
          procedures  may appear within the range of a DO-loop or
          within  an  IF-block,  ELSE  IF-block,  or  ELSE-block.
          Execution  of  a function reference or a CALL statement
          is not considered a transfer of control in the  program
          unit  that  contains the reference, except when control
          is returned to a statement identified by  an  alternate
          return  specifier  in a CALL statement.  Execution of a
          RETURN or END statement in a referenced  procedure,  or
          execution  of a transfer of control within a referenced
          procedure, is not considered a transfer of  control  in
          the program unit that contains the reference.

          The CONTINUE statement is an executable statement  that
          has no effect of itself.  It can serve as an executable
          statement on which to place a statement label  when  no
          effect  of  execution  is desired.  For example, it can
          serve as the statement referred to by a GO TO statement
          or  as&amp;  the terminal statement of a DO-loop.  Although
          the CONTINUE statement has  no  effect  of  itself,  it
          causes   execution   to  continue  with  incrementation
          processing when it is the terminal statement of  a  DO-
          loop.

          The standard does not define the term  "accessible"  in
          the  STOP  or  PAUSE statement in order to allow a wide
          latitude in adapting to a processor environment.   Some
          processors  may  use  the n_ the PAUSE or STOP statement
          for documentation only.  Other processors  may  display
          the  n_ to the user or to the operator.  In order not to
          confine  its  use,  the  meaning  of  "accessible"   is
          purposely left vague.


          B12.  Section_12_Notes

          What is called a "record" in FORTRAN is commonly called
          a  "logical record."  There is no concept in FORTRAN of
          a "physical record."

          An  endfile  record  does  not  necessarily  have   any
          physical  embodiment.   The  processor may use a record
          count or other  means to register the position  of  the
          file at the  time an ENDFILE statement is executed,  so
          that it can take appropriate action when that  position
          is  again reached during a read operation.  The endfile
          record, however it is  implemented,  is  considered  to
          exist for the BACKSPACE statement.




          FORTRAN 77 Full Language                       Page B-7







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          An internal file permits data to  be  transferred  with
          conversion  between  internal  storage  areas using the
          READ  and  WRITE   statements.    This   facility   was
          implemented  as  an extension to ANSI X3.9-1966 on many
          processors as ENCODE and DECODE statements.  Specifying
          the  READ  and WRITE statements to perform this process
          avoids such confusion as:  "Is ENCODE like READ  or  is
          it like WRITE?"

          This standard accommodates, but it  does  not  require,
          file  cataloging.   To  do  this,  several concepts are
          introduced.

          In ANSI X3.9-1966 many properties were given to a  unit
          that  in this standard are given to the connection of a
          file  to  a  unit.   Also,  additional  properties  are
          introduced.

          Before any input/output can be performed on a file,  it
          must be connected to a unit.  The unit then serves as a
          designator for that file as long as  it  is  connected.
          To  be  connected does not imply that "buffers" have or
          have not been  allocated,  that  "file-control  tables"
          have  or  have  not  been filled out, or that any other
          method of implementation  has  been  used.   Connection
          means  that  (barring some other fault) a READ or WRITE
          statement can be executed on the  unit,  hence  on  the
          file.   Without a connection, a READ or WRITE statement
          cannot be executed.

          Totally independent of  the  connection  state  is  the
          property of existence, this being a file property.  The
          processor "knows" of a set of files  that  exist  at  a
          given  time  for  a given executable program.  This set
          would include tapes ready to read, files in a  catalog,
          a  keyboard, a printer, etc.  The set may exclude files
          inaccessible  to  the  executable  program  because  of
          security,  because  they  are already in use by another
          executable  program,  etc.   This  standard  does   not
          specify  which  files  exist,  hence  wide  latitude is
          available to a processor to implement security,  locks,
          privilege  techniques,  etc.  Existence is a convenient
          concept  to  designate  all  of  the  files   that   an
          executable program can potentially process.

          All four combinations of connection and  existence  may
          occur:







          FORTRAN 77 Full Language                       Page B-8







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



8              ______________________________________________

               Connect   Exist            Examples
8              ______________________________________________

                 Yes      Yes    A card reader loaded and
                                 ready to be read
8              ______________________________________________

                 Yes      No     A printer before the first
                                 line is written
8              ______________________________________________

                 No       Yes    A file named 'JOE' in
                                 the catalog
8              ______________________________________________

                 No       No     A reel of tape destroyed
                                 in the fire last week
8              ______________________________________________
7             |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|














9                      |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|














9                              |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|














9                                                           |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
















9          Means are provided  to  create,  delete,  connect,  and
          disconnect files.

          A file may have a name.  The form of a file name is not
          specified.   If  a  system  does  not have some form of
          cataloging or tape labeling for at least  some  of  its
          files, all file names will disappear at the termination
          of execution.  This is a valid implementation.  Nowhere
          does  this  standard  require  names to survive for any
          period of time longer than the execution time  span  of
          an  executable  program.  Therefore, this standard does
          not impose cataloging as a  prerequisite.   The  naming
          feature is intended to allow use of a cataloging system
          where one exists.

          A file may become connected to a unit in either of  two
          ways:  preconnection or execution of an OPEN statement.
          Preconnection is performed prior to  the  beginning  of
          execution of an executable program by means external to
          FORTRAN.  For example, it may be done  by  job  control
          action or by processor established defaults.  Execution
          of  an  OPEN  statement  is  not  required  to   access
          preconnected files.

          The OPEN statement provides a means to access  existing
          files that are not preconnected.  An OPEN statement may
          be used in either of two ways: with a file  name  (open
          by  name)  and  without  a file name (open by unit).  A
          unit is given in either case.  Open  by  name  connects
          the specified file to the specified unit.  Open by unit
          connects a processor-determined  default  file  to  the
          specified  unit.  (The default file may or may not have
          a name.)



          FORTRAN 77 Full Language                       Page B-9







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          Therefore, there are  three  ways  a  file  may  become
          connected  and  hence processed: preconnection, open by
          name, and open by unit.   Once  a  file  is  connected,
          there  is no means in standard FORTRAN to determine how
          it became connected.

          In subset FORTRAN, sequential access may  be  performed
          only  on  preconnected files, and direct access only on
          files that are opened by unit.

          An OPEN statement may also be  used  to  create  a  new
          file.   In  fact, any of the foregoing three connection
          methods may be performed on a file that does not exist.
          When  a  unit is preconnected, writing the first record
          creates  the  file.   With  the  other   two   methods,
          execution of the OPEN statement creates the file.

          When a unit becomes connected  to  a  file,  either  by
          execution of an OPEN statement or by preconnection, the
          following connection properties may be established:

             (1) An access method, which is sequential or direct,
                 is established for the connection.

             (2) A form, which is formatted  or  unformatted,  is
                 established  for  a  connection  to  a file that
                 exists or is created by the connection.   For  a
                 connection  that  results  from  execution of an
                 OPEN statement, a default form (which depends on
                 the  access  method, as described in 12.10.1) is
                 established if no  form  is  specified.   For  a
                 preconnected   file   that  exists,  a  form  is
                 established    by    preconnection.     For    a
                 preconnected  file  that  does not exist, a form
                 may be established, or the  establishment  of  a
                 form  may  be  delayed until the file is created
                 (for example, by execution  of  a  formatted  or
                 unformatted WRITE statement).

             (3) A record length  may  be  established.   If  the
                 access   method   is   direct,   the  connection
                 establishes a record length, which specifies the
                 length of each record of the file.  A connection
                 for  sequential  access  does  not   have   this
                 property.

             (4) A blank significance property, which is ZERO  or
                 NULL,  is established for a connection for which
                 the form is formatted.   This  property  has  no
                 effect on output.  For a connection that results
                 from execution of an OPEN statement,  the  blank



          FORTRAN 77 Full Language                      Page B-10







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



                 significance  property  is NULL by default if no
                 blank significance property is specified.  For a
                 preconnected  file,  the property is established
                 by preconnection.

                 The   blank   significance   property   of   the
                 connection is effective at the beginning of each
                 formatted input statement.  During execution  of
                 the  statement,  any  BN  or BZ edit descriptors
                 encountered may temporarily change the effect of
                 embedded and trailing blanks.

          A  processor  has  wide  latitude  in  adapting   these
          concepts  and  actions  to  its  own cataloging and job
          control conventions.  Some processors may  require  job
          control  action  to specify the set of files that exist
          or that will be created by an executable program.  Some
          processors  may  require no job control action prior to
          execution.  This standard enables processors to perform
          a  dynamic  open, close, and file creation, but it does
          not require such capabilities of the processor.

          The meaning of "open" in contexts  other  than  FORTRAN
          may  include  such  things  as mounting a tape, console
          messages, spooling, label checking, security  checking,
          etc.   These  actions may occur upon job control action
          external  to  FORTRAN,  upon  execution  of   an   OPEN
          statement, or upon execution of the first read or write
          of the file.  The OPEN statement  describes  properties
          of  the connection to the file and may or may not cause
          physical activities to take place.  It is a  place  for
          an implementation to define properties of a file beyond
          those required in standard FORTRAN.

          Similarly,  the  actions   of   dismounting   a   tape,
          protection,  etc.   of a "close" may be implicit at the
          end of a run.  The CLOSE statement may or may not cause
          such actions to occur.  This is another place to extend
          file  properties  beyond  those  of  standard  FORTRAN.
          Note,  however, that the execution of a CLOSE statement
          on unit 10 followed by an OPEN statement  on  the  same
          unit  to  the  same  file  or  to a different file is a
          permissible sequence of events.  The processor may  not
          deny  this  sequence  solely because the implementation
          chooses to do the physical act of closing the  file  at
          the termination of execution of the program.

          This standard does not address  problems  of  security,
          protection,  locking,  and many other concepts that may
          be part of the concept  of  "right  of  access."   Such
          concepts  are  considered  to  be in the province of an



          FORTRAN 77 Full Language                      Page B-11







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          operating system.  The OPEN and INQUIRE statements  can
          be extended naturally to consider these things.

          Possible access methods for a file are:  sequential and
          direct.   The  processor  may  implement  two different
          types of files, each with its own  access  method.   It
          may  also implement one type of file with two different
          access methods.

          Direct access to files is  of  a  simple  and  commonly
          available type, that is, fixed-length records.  The key
          is a positive integer.

          Keyword forms of specifiers are used because there  are
          many  specifiers and a positional notation is difficult
          to  remember.   The  keyword  form  sets  a  style  for
          processor  extensions.  The UNIT= and FMT= keywords are
          offered for completeness, but their  use  is  optional.
          Thus, compatibility with ANSI X3.9-1966 is achieved.

          Format specifications may be included in READ and WRITE
          statements, as in:

                    READ ( UNIT=10, FMT='(I3,A4,F10.2)' ) K,ALPH,X

          ANSI X3.9-1966 allowed a standard-conforming program to
          write  an  endfile record but did not allow the reading
          of an endfile  record.   In  this  standard,  the  END=
          specifier allows end-of-file detection and continuation
          of execution of the program.

          List-directed   input/output   allows   data    editing
          according  to the type of the list item instead of by a
          format specifier.  It also  allows  data  to  be  free-
          field, that is, separated by commas or blanks.

          List-directed input/output is  record  oriented  to  or
          from  a  formatted sequential file.  Each read or write
          begins with a new record.  The  form  of  list-directed
          data  on  a  sequential  output file is not necessarily
          suitable for list-directed input.  However,  there  are
          no mandatory errors specified for reading list-directed
          data  previously  written.   The  results  may  not  be
          guaranteed  because of the syntax using apostrophes for
          character data or the r_*c_ form of a repeated  constant.
          All  other  applications should work, and attempting to
          read previously written  list-directed  output  is  not
          prohibited in a standard-conforming program.

          If no list  items  are  specified  in  a  list-directed
          input/output  statement, one input record is skipped or



          FORTRAN 77 Full Language                      Page B-12







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          one empty output record is written.

          An example of a restriction on input/output  statements
          (12.12) is that an input statement may not specify that
          data are to be read from a printer.


          B13.  Section_13_Notes

          The term "edit descriptor" in this standard was  "field
          descriptor" in ANSI X3.9-1966.

          If a character constant is used as a format  identifier
          in  an  input/output statement, care must be taken that
          the value of the character constant is a  valid  format
          specification.     In   particular,   if   the   format
          specification contains an apostrophe  edit  descriptor,
          two   apostrophes   must  be  written  to  delimit  the
          apostrophe edit descriptor and four apostrophes must be
          written  for  each  apostrophe  that  occurs within the
          apostrophe edit descriptor.  For example, the text:

                               2 ISN'T 3

          may  be  written  by  various  combinations  of  output
          statements and format specifications:

                     WRITE(6,100) 2,3
                 100 FORMAT(1X,I1,1X,'ISN''T',1X,I1)

                     WRITE(6,'(1X,I1,1X,''ISN''''T'',1X,I1)'    )
                     2,3

                     WRITE(6,200) 2,3
                 200 FORMAT(1X,I1,1X,5HISN'T,1X,I1)

                     WRITE(6,'(1X,I1,1X,5HISN''T,1X,I1)' ) 2,3

                     WRITE(6,'(A)') ' 2 ISN''T 3'

                     WRITE(6,'(1X,I1,A,I1)') 2, ' ISN''T ', 3

          Note that two consecutive  apostrophes  in  an  H  edit
          descriptor  within  a character constant are counted as
          only one Hollerith character.

          The T edit descriptor  includes  the  carriage  control
          character   in  lines  that  are  to  be  printed.   T1
          specifies  the  carriage  control  character,  and   T2
          specifies the first character that is printed.




          FORTRAN 77 Full Language                      Page B-13







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          The length of a record is not always specified  exactly
          and may be processor dependent.

          The  number  of  records  read  by  a  formatted  input
          statement can be determined from the following rule:  A
          record is read at the  beginning  of  the  format  scan
          (even  if  the input list is empty), at each slash edit
          descriptor encountered in the format, and when a format
          rescan occurs at the end of the format.

          The number of records written  by  a  formatted  output
          statement can be determined from the following rule:  A
          record is written  when  a  slash  edit  descriptor  is
          encountered  in the format, when a format rescan occurs
          at  the  end  of  the  format,  and  at  completion  of
          execution  of  the output statement (even if the output
          list is empty).  Thus, the occurrence of n_  successive
          slashes between two other edit descriptors causes n_ - 1
          blank lines if the records are printed.  The occurrence
          of  n_  slashes  at  the beginning or end of a complete
          format specification  causes  n_  blank  lines  if  the
          records   are  printed.   However,  a  complete  format
          specification containing n_ slashes (n_ &gt; 0) and no other
          edit  descriptors  causes  n_   +  1 blank lines if the
          records are printed.  For example, the statements

                     PRINT 3
                 3   FORMAT(/)

          will write two records that cause two  blank  lines  if
          the records are printed.

          The following examples illustrate list-directed  input.
          A blank character is represented by b_.
          Example 1:

             Program:    J=3
                         READ *,I
                         READ *,J

             Sequential input file:

                 record 1: b_1b_,4bbbbb_____
                 record 2: ,2bbbbbbbb________

             Result: I=1,

          Explanation: The second READ statement reads the second
          record.   The  initial comma in the record designates a
          null value; therefore, J is not redefined.
          Example 2:



          FORTRAN 77 Full Language                      Page B-14







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



             Program:    CHARACTER A*8, B*1
                         READ *, A, B

             Sequential input file:

                 record 1: 'bbbbbbbb________'
                 record 2: 'QXY'b_'Z'

             Result: A='bbbbbbbb________', B='Q'

          Explanation: The end of a record cannot  occur  between
          two  apostrophes representing an embedded apostrophe in
          a character  constant;  therefore,  A  is  set  to  the
          character  constant   ' bbbbbbbb________'.  The end of a record
          acts as  a  blank,  which  in  this  case  is  a  value
          separator because it occurs between two constants.


          B14.  Section_14_Notes

          The name of a main program has no explicit  use  within
          the    FORTRAN   language.    It   is   available   for
          documentation and for possible use  within  a  computer
          environment.


          B15.  Section_15_Notes

          A FUNCTION statement specifies the name of an  external
          function,  and  each  ENTRY  statement  in  a  function
          subprogram specifies an  additional  external  function
          name.   A  SUBROUTINE statement specifies the name of a
          subroutine, and each ENTRY statement  in  a  subroutine
          subprogram specifies an additional subroutine name.

          The intrinsic function names IFIX,  IDINT,  FLOAT,  and
          SNGL  have  been  retained  to  support  programs  that
          conform to ANSI  X3.9-1966.   However,  future  use  of
          these intrinsic function names is not recommended.

          For the specific functions that define the maximum  and
          minimum  values with a function type different from the
          argument type (AMAX0, MAX1, AMIN0,  and  MIN1),  it  is
          recommended  that  an expression containing the generic
          name preceded by a type conversion  function  be  used,
          for  example,  REAL(MAX(a_918, a_928,...))  for  AMAX0(a_918, a
          _928,...), so that these specific function names  may  be
          deleted in a future revision of this standard.

          This  standard  provides  that  a   standard-conforming
          processor may supply intrinsic functions in addition to



          FORTRAN 77 Full Language                      Page B-15







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          those defined in Table 5  (15.10).   Because  of  this,
          care  must be taken when a program is used on more than
          one processor because a function name not  in  Table  5
          may  be  classified as an external function name on one
          processor and as an intrinsic function name on  another
          processor in the absence of a declaration for that name
          in an EXTERNAL or INTRINSIC statement.

          To guard against this possibility, it is suggested that
          any  external  functions referenced in a program should
          appear in an EXTERNAL statement in every  program  unit
          in  which  a  reference to that function appears.  If a
          program unit references a processor-supplied  intrinsic
          function  that  does not appear in Table 5, the name of
          the function should appear in an INTRINSIC statement in
          the program unit.

          The  distinction  between  external   functions   (user
          defined)  and  intrinsic  functions (processor defined)
          may be clarified by the following table:


































          FORTRAN 77 Full Language                      Page B-16







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



8                           _________________________________________

                                Different Processor Definitions
                                      (Table 5 extended)
8                           _________________________________________

                            Processor 1   Processor 2   Processor 3
8          __________________________________________________________


           Different        Intrinsic     Intrinsic
           User             Integer       Complex        (none)
           Specifications   FROG          FROG
8          __________________________________________________________

8          __________________________________________________________

           Y=FROG(A)        Intrinsic     Intrinsic     External
                            Integer       Complex       Real
                            FROG          FROG          FROG
8          __________________________________________________________

           INTRINSIC FROG   Intrinsic     Intrinsic
           Y=FROG(A)        Integer       Complex       Undefined
                            FROG          FROG
8          __________________________________________________________

           INTEGER FROG     Intrinsic                   External
           Y=FROG(A)        Integer       Undefined     Integer
                            FROG                        FROG
8          __________________________________________________________

           INTRINSIC FROG   Intrinsic
           INTEGER FROG     Integer       Undefined     Undefined
           Y-FROG(A)        FROG
8          __________________________________________________________

           EXTERNAL FROG    External      External      External
           Y=FROG(A)        Real          Real          Real
                            FROG          FROG          FROG
8          __________________________________________________________

           EXTERNAL FROG    External      External      External
           INTEGER FROG     Integer       Integer       Integer
           Y=FROG(A)        FROG          FROG          FROG
8          __________________________________________________________
7         |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
































                         |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|






































                                       |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


































9                                                     |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


































9                                                                   |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|








































          If a generic name is the same as the specific  name  of
          an intrinsic function for a specified type of argument,
          a reference to the function with an  argument  of  that
          type  may  be  considered  to  be  either a specific or
          generic function reference.

          The use of the concatenation operator with operands  of
          nonconstant   length   has   been   restricted  to  the
          assignment statement  so  that  a  processor  need  not
          implement dynamic storage allocation.

9
          FORTRAN 77 Full Language                      Page B-17







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          When a character array is an actual argument, the array
          is  considered to be one string of characters and there
          need not be correspondence  between  the  actual  array
          elements  and  the  dummy  array elements.  Only subset
          FORTRAN requires such correspondence.

          The intrinsic functions ICHAR and CHAR provide a  means
          of converting between a character and an integer, based
          on the position  of  the  character  in  the  processor
          collating   sequence.    The  first  character  in  the
          collating sequence corresponds to position  0  and  the
          last  to  position  n_   -  1, where n_ is the number of
          characters in the collating sequence.

          Many processors provide a collating  sequence  that  is
          the same as the ordering of the internal representation
          of the character (where the internal representation may
          be  regarded  as either a representation of a character
          or of some integer).   For  example,  for  a  seven-bit
          character,  the  internal  representation  of the first
          character is '0000000' binary (0 decimal) and the  last
          character  is '1111111' binary (127 decimal).  For such
          a processor, ICHAR returns the  value  of  an  internal
          character  representation,  considered  as  an integer.
          CHAR takes an appropriate small integer and returns the
          character having the same internal representation.


          B16.  Section_16_Notes

          The name of a block data subprogram has no explicit use
          within  the  FORTRAN  language.   It  is  available for
          documentation and for possible use  within  a  computer
          environment.


          B17.  Section_17_Notes

          The size of an array is the number of elements (5.2.3),
          but  the storage sequence of the array also has a size,
          which may be different  from  the  number  of  elements
          (17.1.1).

          The  definition  of  character  entities  occurs  on  a
          character-by-character basis.  The use of substrings or
          partially  associated   entities   permits   individual
          characters  or groups of characters within an entity to
          become defined or undefined.






          FORTRAN 77 Full Language                      Page B-18







          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4



          B18.  Section_18_Notes

          There is no explicit means for declaring an  entity  to
          be  a  variable.  An entity becomes a variable if it is
          used  in  a  manner  that  does  not  cause  it  to  be
          exclusively  something  else.   Note that the name of a
          variable may also be the name of a common block, except
          when  the  name  of  the variable is also the name of a
          function.













































          FORTRAN 77 Full Language                      Page B-19











                                 CONTENTS

          APPENDIX B: SECTION NOTES........................   B-1
          B1.     Section 1 Notes..........................   B-1
          B2.     Section 2 Notes..........................   B-2
          B3.     Section 3 Notes..........................   B-2
          B4.     Section 4 Notes..........................   B-3
          B5.     Section 5 Notes..........................   B-4
          B6.     Section 6 Notes..........................   B-4
          B7.     Section 7 Notes..........................   B-4
          B8.     Section 8 Notes..........................   B-5
          B9.     Section 9 Notes..........................   B-6
          B10.     Section 10 Notes........................   B-6
          B11.     Section 11 Notes........................   B-6
          B12.     Section 12 Notes........................   B-7
          B13.     Section 13 Notes........................  B-13
          B14.     Section 14 Notes........................  B-15
          B15.     Section 15 Notes........................  B-15
          B16.     Section 16 Notes........................  B-18
          B17.     Section 17 Notes........................  B-18
          B18.     Section 18 Notes........................  B-19

































                                   - i -







                                                   ANSI X3J3/90.4



                           APPENDIX_C:_HOLLERITH

          The  character  data  type  was  added  to  provide   a
          character  data  processing capability that is superior
          to the Hollerith data capability that existed  in  ANSI
          X3.9-1966.

          The  Hollerith  data  type  has  been   deleted.    For
          processors   that   extend  the  standard  by  allowing
          Hollerith data, the following rules  for  programs  are
          recommended:


          C1.  Hollerith_Data_Type

          Hollerith is a data type; however, a symbolic name must
          not  be  of type Hollerith.  Hollerith data, other than
          constants, are identified under the guise of a name  of
          type  integer,  real,  or  logical.   They  must not be
          identified under  the  guise  of  type  character.   No
          recommendation  is  made  regarding Hollerith under the
          guise of double precision or complex.

          A Hollerith datum  is  a  string  of  characters.   The
          string   may  consist  of  any  characters  capable  of
          representation in the processor.  The  blank  character
          is  significant  in  a Hollerith datum.  Hollerith data
          may have an internal representation that  is  different
          from that of other data types.

          An entity of type integer,  real,  or  logical  may  be
          defined  with  a  Hollerith  value  by  means of a DATA
          statement (C4) or READ statement (C6).  When an  entity
          is   defined   with  a  Hollerith  value,  its  totally
          associated  entities  are  also   defined   with   that
          Hollerith value.  When an entity of type integer, real,
          or logical is  defined  with  a  Hollerith  value,  the
          entity  and  its associates become undefined for use as
          an integer, real, or logical datum.


          C2.  Hollerith_Constant

          The  form  of  a  Hollerith  constant  is  a   nonzero,
          unsigned,  integer constant n_ followed by the letter H,
          followed  by  a  string  of  exactly   n _   contiguous
          characters.   The  string may consist of any characters
          capable of representation in the processor.  The string
          of n_ characters is the Hollerith datum.





          FORTRAN 77 Full Language                       Page C-1







          APPENDIX C: HOLLERITH                    ANSI X3J3/90.4



          In a Hollerith constant, blanks are significant only in
          the n_ characters following the letter H.


          C3.  Restrictions_on_Hollerith_Constants

          A  Hollerith  constant  may  appear  only  in  a   DATA
          statement and in the argument list of a CALL statement.


          C4.  Hollerith_Constantin

          An integer, real, or logical entity  may  be  initially
          defined with a Hollerith datum by a DATA statement.

          A Hollerith constant may appear in the list clist_____,  and
          the  corresponding  entity  in the list nlist_____ may be of
          type integer, real, or logical.

          For an entity of type integer, real,  or  logical,  the
          number  of  characters n_ in the corresponding Hollerith
          constant must be less than or equal to g_, where  g_  is
          the  maximum number of characters that can be stored in
          a single numeric storage unit at one time.   If  n_  is
          less than g_, the entity is initially defined with the n_
          Hollerith characters extended on the right with g_ -  n_
          blank characters.

          Note that each  Hollerith  constant  initially  defines
          exactly one variable or array element.  Also note that g
          _ is processor dependent.


          C5.  Hollerith_Format_Specification

          A format specification may be an  array  name  of  type
          integer, real, or logical.

          The leftmost characters of the  specified  entity  must
          contain   Hollerith   data  that  constitute  a  format
          specification when the statement is executed.

          The format specification must be of the form  described
          in  13.2.   It  must  begin with a left parenthesis and
          must end with a right parenthesis.  Data may follow the
          right  parenthesis  that  ends the format specification
          and have no effect.  Blank characters may  precede  the
          format specification.

          A Hollerith format specification must  not  contain  an
          apostrophe edit descriptor or an H edit descriptor.



          FORTRAN 77 Full Language                       Page C-2







          APPENDIX C: HOLLERITH                    ANSI X3J3/90.4



          C6.  A_Editing_of_Hollerith_Data

          The Aw_ edit descriptor may be used with Hollerith  data
          when  the  input/output  list  item is of type integer,
          real, or logical.  On input, the input list  item  will
          become  defined  with  Hollerith  data.  On output, the
          list item must be defined with Hollerith data.

          Editing is as described for Aw_  editing  of  character
          data  except  that  len_ _ _  is  the  maximum  number of
          characters that can  be  stored  in  a  single  numeric
          storage unit.


          C7.  Hollerith_Constant_in_a_Subroutine_Reference

          An actual argument in a subroutine reference may  be  a
          Hollerith  constant.   The corresponding dummy argument
          must be of type integer, real, or logical.   Note  that
          this is an exception to the rule that requires that the
          type of the actual and dummy argument must agree.

































          FORTRAN 77 Full Language                       Page C-3











                                 CONTENTS

          APPENDIX C: HOLLERITH.............................  C-1
          C1.     Hollerith Data Type.......................  C-1
          C2.     Hollerith Constant........................  C-1
          C3.     Restrictions on Hollerith Constants.......  C-2
          C4.     Hollerith Constant........................  C-2
          C5.     Hollerith Format Specification............  C-2
          C6.     A Editing of Hollerith Data...............  C-3
          C7.     Hollerith Constant in a Subroutine
          Reference.........................................  C-3











































                                   - i -







                                                   ANSI X3J3/90.4



                        APPENDIX_D:_SUBSET_OVERVIEW

          This Appendix provides an overview of the two levels of
          FORTRAN  specified  in  this  standard,  including  the
          general criteria used  for  including  or  excluding  a
          feature  at  a  given  level,  and a section-by-section
          summary of the principal differences between  the  full
          language and the subset.


          D1.  Background

          The full FORTRAN language described in this document is
          a  superset  of  the FORTRAN language described in ANSI
          X3.9-1966, with the exceptions  previously  noted.   In
          formulating a subset philosophy, the following existing
          FORTRAN standards were considered:

             (1) American National Standard FORTRAN,  ANSI  X3.9-
                 1966

             (2) American National Standard Basic  FORTRAN,  ANSI
                 X3.10-1966

             (3) International  Standard   Programming   Language
                 FORTRAN, ISO R1539

          The ISO R1539 document describes three  levels:  basic,
          intermediate,  and  full.   The  ISO  R1539 basic level
          corresponds closely with ANSI X3.10-1966; the ISO R1539
          full level corresponds closely with ANSI X3.9-1966; and
          the ISO R1539 intermediate level is in between.

          It was thought that the ISO R1539 basic level  and  the
          ANSI X3.10-1966 had not been sufficiently used, even on
          small   computer   systems,   to   warrant   a   subset
          corresponding to that level.

          The ISO R1539 intermediate level has been  sufficiently
          used to warrant a subset of similar capability.

          However,  it  was  also  thought  that  some   of   the
          capabilities  in  the full language described here, but
          not part of any current standard or recommendation, are
          so  important  for the general use of the language that
          they should be present in the subset, at least to  some
          degree.

          Furthermore, it was thought that the  specification  of
          ANSI  X3.10-1966  in  such  a  manner  that it is not a
          subset of ANSI  X3.9-1966  was  inconsistent  with  the



          FORTRAN 77 Full Language                       Page D-1







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



          primary   goal   of   promoting   program  interchange.
          Consequently,  careful  attention  has  been  given  to
          ensuring  that a program that conforms to the subset of
          this standard will also conform to the full language.


          D2.  Criteria

          The criteria in D2.1 and D2.2 were adopted for the  two
          levels of FORTRAN within this standard.

          D2.1  Full_Language.

          The most notable new elements of the full language that
          have  been  included at both levels are: character data
          type, mixed-type arithmetic, INTRINSIC statement,  SAVE
          statement, and direct access I/O statements.

          D2.2  Subset_Language.

             (1) The subset must be a proper subset of  the  full
                 language.

             (2) The  subset  must  be   based   on   ISO   R1539
                 intermediate level FORTRAN.

             (3) The subset must include, at a fundamental level,
                 those   features   of  the  full  language  that
                 significantly  increase   the   scope   of   the
                 language.

             (4) The elements of the subset must make  a  minimum
                 demand  on  storage  requirements,  particularly
                 during execution.

             (5) The subset must require a minimum of effort  for
                 the  development  and  maintenance  of  a viable
                 FORTRAN processor.


          D3.  Summary_of_Subset_Differences

          This section summarizes  the  differences  between  the
          full  language  and the subset in this standard.  It is
          organized  primarily  on  the  basis  of  the  standard
          itself.    The  differences  are  discussed  under  the
          section  where  each  language  element  is   primarily
          presented.   Of course, a difference in one section may
          cause changes in other sections.  Such changes are  not
          noted here.




          FORTRAN 77 Full Language                       Page D-2







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



          An exception to the above practice is the subsetting of
          the  character data type.  The description of character
          data type and its usage is  so  distributed  throughout
          the standard that a more meaningful summary is produced
          by  collecting  the  relevant  items  into   a   single
          presentation.

          D3.1  Section_1:_Introduction.

          The subset is the same as the full language  (see  also
          D4).

          D3.2  Section_2:_FORTRAN_Terms_and_Concepts.

          The subset is the same as the full language.

          D3.3  Section 3: Characters, Lines, and Execution
                Sequence.

          The subset is the same  as  the  full  language  except
          that:

             (1) The character set does not include the  currency
                 symbol ($) or the colon (:).

             (2) Statements may  have  up  to  nine  continuation
                 lines.

             (3) DATA statements must  follow  all  specification
                 statements  and  precede  all statement function
                 statements and executable statements.

             (4) A comment line must not precede  a  continuation
                 line.

          D3.4  Section_4:_Data_Types_and_Constants.

          The subset is the same as the full language except that
          double   precision  and  complex  data  types  are  not
          included.  Note that each entity of type character must
          have a constant length.

          D3.5  Section_5:_Arrays_and_Substrings.

          The subset is the same  as  the  full  language  except
          that:

             (1) An array declarator must not  have  an  explicit
                 lower bound.





          FORTRAN 77 Full Language                       Page D-3







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



             (2) A dimension declarator must be either an integer
                 constant or an integer variable.  (This excludes
                 integer expressions, but allows  a  variable  in
                 common.)

             (3) An array may have up to three dimensions.

             (4) A subscript  expression  may  be  an  expression
                 containing only integer variables and constants.
                 (This  excludes  function  and   array   element
                 references.)

          D3.6  Section_6:_Expressions.

          The subset is the same as the full language except that
          a  constant  expression is allowed only where a general
          expression is allowed, the logical operators .EQV.  and
          .NEQV.  are not included, and there are restrictions on
          character expressions as described in D3.19.

          D3.7  Section 7: Executable and Nonexecutable Statement
                Classification.

          The classification of a statement in the subset is  the
          same as in the full language.  However, the subset does
          not include PRINT, CLOSE, INQUIRE, ENTRY,  BLOCK  DATA,
          PARAMETER, DOUBLE PRECISION, and COMPLEX statements.

          D3.8  Section_8:_Specification_Statements.

          The subset is the same  as  the  full  language  except
          that:

             (1) The PARAMETER statement is not included.

             (2) Only the names of  common  blocks  (enclosed  in
                 slashes)  may  appear  in  the  list  of  a SAVE
                 statement.   The  form  of  the  SAVE  statement
                 without a list is not included.

          D3.9  Section_9:_DATA_Statement.

          The subset is the same  as  the  full  language  except
          that:

             (1) Only  names  of  variables,  arrays,  and  array
                 elements  are  allowed  in  the  list  nlist_ _ ___.
                 Implied-DO lists are not included.

             (2) Values in the list clist_____ must agree in type with
                 the  corresponding item in the list nlist_____.  Type



          FORTRAN 77 Full Language                       Page D-4







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



                 conversion is not included.

          Note that DATA statements must follow all specification
          statements   and   precede   all   statement   function
          statements and executable statements.

          D3.10  Section_10:_Assignment_Statements.

          The subset is the same as the full language except  for
          restrictions on character type presented in D3.19.

          D3.11  Section_11:_Control_Statements.

          The subset is the same  as  the  full  language  except
          that:

             (1) A DO-variable must be an integer variable and DO
                 parameters  must be integer constants or integer
                 variables.

             (2) In  a  computed  GOTO   statement,   the   index
                 expression must be an integer variable.

          D3.12  Section_12:_Input/Output_Statements.

          The subset is the same  as  the  full  language  except
          that:

             (1) The CLOSE statement is not included.

             (2) The INQUIRE statement is not included.

             (3) List-directed READ and WRITE statements are  not
                 included.

             (4) An internal file identifier must be a  character
                 variable or character array element.

             (5) Formatted direct access files and statements are
                 not included.

             (6) External unit identifiers  must  be  an  integer
                 constant or integer variable.

             (7) A format identifier  must  be  the  label  of  a
                 FORMAT  statement,  an integer variable that has
                 been assigned the label of a  FORMAT  statement,
                 or a character constant.

             (8) The UNIT= and FMT=  forms  of  unit  and  format
                 specifiers are not included.



          FORTRAN 77 Full Language                       Page D-5







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



             (9) The ERR= specifier is not included.

            (10) The forms READ f [,iolist______] and PRINT f [,iolist______]
                 are not included.

            (11) In input/output lists, the implied-DO parameters
                 must   be   integer   constants  and  variables.
                 Implied-DO-variables must be of type integer.

            (12) Variable names, array element names,  and  array
                 names  may  appear  as  input/output list items;
                 constants, character substring  references,  and
                 general expressions are not included.

            (13) A limited form of  OPEN  statement  is  included
                 with  the  following  olist_____ specifiers required,
                 and no others are allowed:

                (a) An integer constant unit identifier

                (b) The keyword specifier ACCESS= 'DIRECT'

                (c) The record length specifier RECL= rl__, where rl_
                    _ is an integer constant

                 The OPEN statement is  included  in  the  subset
                 only to the extent needed to connect a unit to a
                 direct access unformatted file.  Once a unit has
                 been  connected  to a direct access file, it may
                 not be reconnected to any other file.

            (14) Named files are not included.

          D3.13  Section_13:_Format_Specification.

          The subset is the same  as  the  full  language  except
          that:

             (1) The following edit descriptors are not included:

                                Iw_.m_     Tc_    S
                                Dw_.d_     TLc_   SP
                                Gw_.d_     TRc_   SS
                                Gw_.d_Ee_

             (2) At  most  three  levels   of   parentheses   are
                 permitted.

             (3) The  format  scan  terminator  (colon)  is   not
                 included.




          FORTRAN 77 Full Language                       Page D-6







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



          D3.14  Section_14:_Main_Program.

          The subset is the same as the full language.

          D3.15  Section_15:_Functions_and_Subroutines.

          The subset is the same as the full language except that
          the following are not included:

             (1) The ENTRY statement

             (2) Alternate return specifier

             (3) Generic function references

             (4) Intrinsic  functions  involving   arguments   or
                 results of type double precision or complex

          Other exclusions are presented in D3.19,  most  notably
          an   asterisk  character  length  specifier,  character
          functions,  the  intrinsic  functions  LEN,  CHAR,  and
          INDEX, and partial association.

          D3.16  Section_16:_Block_Data_Subprogram.

          Block data subprograms are not included in the subset.

          D3.17  Section_17:_Association_and_Definition.

          The subset is the same as the full language except that
          the  concept  of  partial association does not apply to
          the subset.

          D3.18  Section_18:_Scope_and_Classes_of_Symbolic_Names.

          The subset is the same as the full language.

          D3.19  Section_1_to_18:_Character_Type.

          The primary intent of the the subset character facility
          is  to  provide  a minimal character capability that is
          functionally comparable to what is possible  with  most
          extensions of Hollerith data.

          D3.19.1  Character_Features_in_the_Subset.  The  subset
          includes the following character data type features:

             (1) Character constants, variables, and arrays,  but
                 not character functions





          FORTRAN 77 Full Language                       Page D-7







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



             (2) CHARACTER and IMPLICIT statements for  declaring
                 character  entities  and their lengths; a length
                 specification must be an integer  constant  (not
                 an asterisk)

             (3) Character assignment  statements  in  which  the
                 right-hand side is a variable, array element, or
                 constant

             (4) Character relational expressions  in  which  the
                 operands   are  variables,  array  elements,  or
                 constants

             (5) Initialization of character  variables,  arrays,
                 and array elements in a DATA statement

             (6) Character variables, arrays, and array  elements
                 in output lists

             (7) Character variables, arrays, array elements, and
                 constants as arguments in subprogram references

             (8) Character constants (but not variables or  array
                 elements) as a format specification

             (9) Total, but not partial, association of character
                 entities  (that  is,  association  of  character
                 entities only of the same  length  by  means  of
                 COMMON and EQUIVALENCE statements or by argument
                 association)

            (10) Input/output of character data,  both  formatted
                 (using    character    edit   descriptors)   and
                 unformatted

          D3.19.2  Character_Features_Not_in_the_Subset.      The
          subset  does  not  include the following character data
          type features:

             (1) Substring reference and definition

             (2) Concatenation operator

             (3) Use of character variables or array elements  as
                 format specifications

             (4) Partial association of character entities

             (5) Character functions





          FORTRAN 77 Full Language                       Page D-8







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



             (6) The intrinsic functions LEN, CHAR, and INDEX

             (7) Character length specification consisting of  an
                 asterisk or any expression other than a constant


          D4.  Subset_Conformance.

          Conformance  at  the  subset  level  of  this  standard
          involves  requirements that relate to the full language
          for both processors and programs.

          D4.1  Subset_Processor_Conformance.

          A standard-conforming subset processor may  include  an
          extension   to   the   subset   language  that  has  an
          interpretation  in  the  full  language  only  if   the
          processor provides the interpretation described for the
          full language.  That is, a  standard-conforming  subset
          processor  may  not provide an extension that conflicts
          with the full language.  Extensions that  do  not  have
          forms  and interpretations in the full language are not
          precluded by this requirement.

          As an example, a standard-conforming  subset  processor
          may  provide a double precision data type provided that
          the requirements for double precision are fulfilled.

          D4.2  Subset_Program_Performance.

          A program that conforms to the  subset  level  of  this
          standard  must have the same interpretation at both the
          subset  level  and  the  full  language   level.    The
          principal  implication of this requirement concerns the
          use of function names that are identified  as  specific
          or   generic  intrinsic  function  names  at  the  full
          language level but  which  are  not  available  at  the
          subset  level.   Examples  of such names are DSIN, MIN,
          and CABS.

          A subset-conforming program may not use such  names  as
          intrinsic functions because these names are not defined
          as  intrinsic  functions  in   the   subset   language.
          Moreover,  a subset-conforming program may not use such
          names as external function names unless such names  are
          identified  as  external function names by appearing in
          an  EXTERNAL  statement.   If  such   names   are   not
          explicitly  declared  as  external,  the names would be
          classified as external by a  subset  processor  and  as
          intrinsic  by a full language processor.  Note that the
          burden of avoiding this situation rests on the program.



          FORTRAN 77 Full Language                       Page D-9







          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4



          A   subset-conforming  processor  is  not  required  to
          recognize that a full language intrinsic name is  being
          used  without  being  declared as external.  In effect,
          the full set of names  described  in  Table  5  may  be
          considered  as reserved intrinsic function names in the
          subset even though only a  subset  of  those  names  is
          available for use.















































          FORTRAN 77 Full Language                      Page D-10











                                 CONTENTS

          APPENDIX D: SUBSET OVERVIEW.......................  D-1
          D1.     Background................................  D-1
          D2.     Criteria..................................  D-2
          D2.1    Full Language.............................  D-2
          D2.2    Subset Language...........................  D-2
          D3.     Summary of Subset Differences.............  D-2
          D3.1    Section 1: Introduction...................  D-3
          D3.2    Section 2: FORTRAN Terms and Concepts.....  D
          -3
          D3.3    Section 3: Characters, Lines, and
          Execution Sequence................................  D-3
          D3.4    Section 4: Data Types and Constants.......  D-3
          D3.5    Section 5: Arrays and Substrings..........  D-3
          D3.6    Section 6: Expressions....................  D-4
          D3.7    Section 7: Executable and Nonexecutable
          Statement Classification..........................  D-4
          D3.8    Section 8: Specification Statements.......  D-4
          D3.9    Section 9: DATA Statement.................  D-4
          D3.10    Section 10: Assignment Statements........  D-5
          D3.11    Section 11: Control Statements...........  D-5
          D3.12    Section 12: Input/Output Statements......  D-
          5
          D3.13    Section 13: Format Specification.........  D-6
          D3.14    Section 14: Main Program.................  D-7
          D3.15    Section 15: Functions and
          Subroutines.......................................  D-7
          D3.16    Section 16: Block Data Subprogram........  D-7
          D3.17    Section 17: Association and
          Definition........................................  D-7
          D3.18    Section 18: Scope and Classes of
          Symbolic Names....................................  D-7
          D3.19    Section 1 to 18: Character Type..........  D-7
          D4.     Subset Conformance........................  D-9
          D4.1    Subset Processor Conformance..............  D-9
          D4.2    Subset Program Performance................  D-9

















                                   - i -







                                                   ANSI X3J3/90.4



                      APPENDIX_E:_FORTRAN_STATEMENTS



          Form____                                      Descriptive Heading___________________

          ASSIGN s TO i                             Statement Label
                                                    Assignment Statement

          BACKSPACE u                               File Positioning
          BACKSPACE (alist)                         Statements

          BLOCK DATA [sub]                          BLOCK DATA Statement

          CALL sub [([a [,a]...])]                  Subroutine Reference:
                                                    CALL Statement

          CHARACTER [*len[,]] nam [,nam]...         Character Type-
                                                    Statement

          CLOSE (cllist)                            CLOSE Statement

          COMMON [/[cb]/]nlist[[,]/[cb]/nlist]...   COMMON Statement

          COMPLEX v [,v]...                         Complex Type-
                                                    Statement

          CONTINUE                                  CONTINUE Statement

          DATA nlist/clist/ [[,]nlist/clist/]...    DATA Statement

          DIMENSION a(d) [,a(d)]...                 DIMENSION Statement

          DO s [,] i=e918,e928[,e938]                     DO Statement

          DOUBLE PRECISION v [,v]...                Double Precision
                                                    Type-Statement

          ELSE                                      ELSE Statement

          ELSE IF (e) THEN                          ELSE IF Statement

          END                                       END Statement

          END IF                                    END IF Statement

          ENDFILE u                                 File Positioning
          ENDFILE (alist)                           Statements






          FORTRAN 77 Full Language                       Page E-1







          APPENDIX E: FORTRAN STATEMENTS           ANSI X3J3/90.4




          ENTRY en [([d [,d]...])]                  ENTRY Statement

          EQUIVALENCE (nlist) [,(nlist)]...         EQUIVALENCE Statement

          EXTERNAL proc [,proc]...                  EXTERNAL Statement
















































          FORTRAN 77 Full Language                       Page E-2







          APPENDIX E: FORTRAN STATEMENTS           ANSI X3J3/90.4



          Form____                               Descriptive Heading___________________

          FORMAT fs                          FORMAT Statement
          fun ([d [,d]...]) = e              Statement Function
                                             Statement

          [typ] FUNCTION fun ([d [,d]...])   FUNCTION Statement

          GO TO i [[,](s [,s]...)]           Assigned GO TO
                                             Statement

          GO TO s                            Unconditional GO TO
                                             Statement

          GO TO (s [,s]...)[,] i             Computed GO TO
                                             Statement

          IF (e) st                          Logical IF Statement

          IF (e) s918, s928, s938                  Arithmetic IF
                                             Statement

          IF (e) THEN                        Block IF Statement

          IMPLICIT typ (a [,s]...)           IMPLICIT Statement
            [,typ (a [,a]...)]...

          INQUIRE (iflist)                   INQUIRE by File
                                             Statement

          INQUIRE (iulist)                   INQUIRE by Unit
                                             Statement

          INTEGER v [,v]...                  Integer Type-
                                             Statement

          INTRINSIC fun [,fun]...            INTRINSIC Statement

          LOGICAL v [,v]...                  Logical Type-
                                             Statement

          OPEN (olist)                       OPEN Statement

          PARAMETER (p=e [,p=e]...)          PARAMETER Statement

          PAUSE [n]                          PAUSE Statement

          PRINT f [,iolist]                  Data Transfer Output






          FORTRAN 77 Full Language                       Page E-3







          APPENDIX E: FORTRAN STATEMENTS           ANSI X3J3/90.4



                                             Statement

          PROGRAM pgm                        PROGRAM Statement



















































          FORTRAN 77 Full Language                       Page E-4







          APPENDIX E: FORTRAN STATEMENTS           ANSI X3J3/90.4



          Form____                              Descriptive Heading___________________

          READ (cilist) [iolist]            Data Transfer Input
                                            Statement

          READ f [,iolist]                  Data Transfer Input
                                            Statement
          REAL v [,v]...                    Real Type-Statement

          RETURN [e]                        RETURN Statement

          REWIND u                          File Positioning
          REWIND (alist)                    Statements

          SAVE [a [,a]...]                  SAVE Statement

          STOP [n]                          STOP Statement

          SUBROUTINE sub [([d [,d]...])]    Subroutine Subprogram
                                            and SUBROUTINE
                                            Statement

          v = e                             Arithmetic Assignment
                                            Statement

          v = e                             Logical Assignment
                                            Statement

          v = e                             Character Assignment
                                            Statement

          WRITE (cilist) [iolist]           Data Transfer Output
                                            Statement





















          FORTRAN 77 Full Language                       Page E-5











                                 CONTENTS

          APPENDIX E: FORTRAN STATEMENTS....................  E-1



















































                                   - i -







                                                   ANSI X3J3/90.4



                         APPENDIX_F:_SYNTAX_CHARTS



                  Appendix F is temporarily unavailable.

















































          FORTRAN 77 Full Language                       Page F-1











                                 CONTENTS

          APPENDIX F: SYNTAX CHARTS.........................  F-1



















































                                   - i -
</pre>
</body>
</html>
<html>

<!--
     FILE ARCHIVED ON 20:34:01 Mar 26, 2006 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 22:52:09 Apr 15, 2023.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 86.673
  exclusion.robots: 0.085
  exclusion.robots.policy: 0.076
  RedisCDXSource: 1.177
  esindex: 0.006
  LoadShardBlock: 69.918 (3)
  PetaboxLoader3.datanode: 197.236 (4)
  load_resource: 190.739
  PetaboxLoader3.resolve: 35.079
-->