<html><head><script type="text/javascript" src="/_static/js/bundle-playback.js?v=TPXmWR5s" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=txqj7nKC" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.fortran.com/F77_std/rjcnf-6.html","20060326202707","https://web.archive.org/","web","/_static/",
	      "1143404827");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=S1zqJCYt" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->
<title>6 EXPRESSIONS</title></head><body>

<h1><a name="sh-6">6 EXPRESSIONS</a></h1>

This section describes the formation, interpretation, and evaluation rules for arithmetic, character, relational, and logical expressions.  An expression is formed from operands, operators, and parentheses.

<h2><a name="sh-6.1">6.1 Arithmetic Expressions</a></h2>

An arithmetic expression is used to express a numeric computation. Evaluation of an arithmetic expression produces a numeric value.
<p>
The simplest form of an arithmetic expression is an unsigned arithmetic constant, symbolic name of an arithmetic constant, arithmetic variable reference, arithmetic array element reference, or arithmetic function reference. More complicated arithmetic expressions may be formed by using one or more arithmetic operands together with arithmetic operators and parentheses.  Arithmetic operands must identify values of type integer, real, double precision, or complex.

<h3><a name="sh-6.1.1">6.1.1 Arithmetic Operators.</a></h3>

The five arithmetic operators are:
<p><pre>
                      ______________________________________
                      |          |                         |
                      | Operator | Representing            |
                      |__________|_________________________|
                      |          |                         |
                      |    **    | Exponentiation          |
                      |    /     | Division                |
                      |    *     | Multiplication          |
                      |    -     | Subtraction or Negation |
                      |    +     | Addition or Identity    |
                      |__________|_________________________|
</pre><p>
Each of the operators **, /, and * operates on a pair of operands and is written between the two operands.  Each of the operators + and - either:
<p><ol>
<li>operates on a pair of operands and is written between the two operands, or
<li>operates on a single operand and is written preceding that operand.
</ol>
<h3><a name="sh-6.1.2">6.1.2 Form and Interpretation of Arithmetic Expressions.</a></h3>

The interpretation of the expression formed with each of the arithmetic operators in each form of use is as follows:
<p><pre>











              _____________________________________________________
              |                 |                                 |
              | Use of Operator | Interpretation                  |
              |_________________|_________________________________|
              |                 |                                 |
              |     x  ** x     | Exponentiate x  to the power x  |
              |      1     2    |               1               2 |
              |     x  / x      | Divide x  by x                  |
              |      1    2     |         1     2                 |
              |     x  * x      | Multiply x  and x               |
              |      1    2     |           1      2              |
              |     x  - x      | Subtract x  from x              |
              |      1    2     |           2       1             |
              |        - x      | Negate x                        |
              |           2     |         2                       |
              |     x  + x      | Add x  and x                    |
              |      1    2     |      1      2                   |
              |        + x      | Same as x                       |
              |           2     |          2                      |
              |_________________|_________________________________|
</pre>
where:<ul>
<li>x<sub>1</sub> denotes the operand to the left of the operator
<li>x<sub>2</sub> denotes the operand to the right of the operator
</ul><p>
The interpretation of a division may depend on the data types of the operands (<a href="#sh-6.1.5">6.1.5</a>).
<p>
A set of formation rules is used to establish the interpretation of an arithmetic expression that contains two or more operators.  There is a precedence among the arithmetic operators, which determines the order in which the operands are to be combined unless the order is changed by the use of parentheses.  The precedence of the arithmetic operators is as follows:
<p><pre>
                           ___________________________
                           |          |              |
                           | Operator | Precedence   |
                           |__________|______________|
                           |          |              |
                           |   **     | Highest      |
                           | * and /  | Intermediate |
                           | + and -  | Lowest       |
                           |__________|______________|
</pre><p>
For example, in the expression
<p><pre>
      - A ** 2
</pre><p>
the exponentiation operator (**) has precedence over the negation operator (-); therefore, the operands of the exponentiation operator are combined to form an expression that is used as the operand of the negation operator.  The interpretation of the above expression is the same as the interpretation of the expression
<p><pre>
      - (A ** 2)
</pre><p>
The <i>arithmetic operands</i> are:
<p><ol>
<li>Primary
<li>Factor
<li>Term
<li>Arithmetic expression
</ol><p>
The formation rules to be applied in establishing the interpretation of arithmetic expressions are in <a href="#sh-6.1.2.1">6.1.2.1</a> through 6.1.2.4.

<h4><a name="sh-6.1.2.1">6.1.2.1 Primaries.</a></h4>

The <i>primaries</i> are:
<p><ol>
<li>Unsigned arithmetic constant (<a href="rjcnf-4.html#sh-4.2.3">4.2.3</a>)
<li>Symbolic name of an arithmetic constant (<a href="rjcnf-8.html#sh-8.6">8.6</a>)
<li>Arithmetic variable reference (<a href="rjcnf-2.html#sh-2.5">2.5</a>)
<li>Arithmetic array element reference (<a href="rjcnf-5.html#sh-5.3">5.3</a>)
<li>Arithmetic function reference (<a href="rjcnf-15.html#sh-15.2">15.2</a>)
<li>Arithmetic expression enclosed in parentheses (<a href="#sh-6.1.2.4">6.1.2.4</a>)
</ol>
<h4><a name="sh-6.1.2.2">6.1.2.2 Factor.</a></h4>

The forms of a <i>factor</i> are:
<p><ol>
<li>Primary
<li>Primary ** factor
</ol><p>
Thus, a factor is formed from a sequence of one or more primaries separated by the exponentiation operator.  Form (2) indicates that in interpreting a factor containing two or more exponentiation operators, the primaries are combined from right to left.  For example, the factor
<p><pre>
      2**3**2
</pre><p>
has the same interpretation as the factor
<p><pre>
      2**(3**2)
</pre><p>
<h4><a name="sh-6.1.2.3">6.1.2.3 Term.</a></h4>

The forms of a <i>term</i> are:
<p><ol>
<li>Factor
<li>Term / factor
<li>Term * factor
</ol><p>
Thus, a term is formed from a sequence of one or more factors separated by either the multiplication operator or the division operator.  Forms (2) and (3) indicate that in interpreting a term containing two or more multiplication or division operators, the factors are combined from left to right.

<h4><a name="sh-6.1.2.4">6.1.2.4 Arithmetic Expression.</a></h4>

The forms of an <i>arithmetic expression</i> are:
<p><ol>
<li>Term
<li>+ term
<li>- term
<li>Arithmetic expression + term
<li>Arithmetic expression - term
</ol><p>
Thus, an arithmetic expression is formed from a sequence of one or more terms separated by either the addition operator or the subtraction operator.  The first term in an arithmetic expression may be preceded by the identity or the negation operator.  Forms (4) and (5) indicate that in interpreting an arithmetic expression containing two or more addition or subtraction operators, the terms are combined from left to right.
<p>
Note that these formation rules do not permit expressions containing two consecutive arithmetic operators, such as A**-B or A+-B.  However, expressions such as A**(-B) and A+(-B) are permitted.

<h3><a name="sh-6.1.3">6.1.3 Arithmetic Constant Expression.</a></h3>

An <i>arithmetic constant expression</i> is an arithmetic expression in which each primary is an arithmetic constant, the symbolic name of an arithmetic constant, or an arithmetic constant expression enclosed in parentheses.  The exponentiation operator is not permitted unless the exponent is of type integer.  Note that variable, array element, and function references are not allowed.

<h4><a name="sh-6.1.3.1">6.1.3.1 Integer Constant Expression.</a></h4>

An <i>integer constant expression</i> is an arithmetic constant expression in which each constant or symbolic name of a constant is of type integer.  Note that variable, array element, and function references are not allowed.
<p>
The following are examples of integer constant expressions:
<p><pre>
      3
      -3
      -3+4
</pre>
<h3><a name="sh-6.1.4">6.1.4 Type and Interpretation of Arithmetic Expressions.</a></h3>

The data type of a constant
is determined by the form of the constant (<a href="rjcnf-4.html#sh-4.2.1">4.2.1</a>).  The data type of an arithmetic variable reference, symbolic name of an arithmetic constant, arithmetic array element reference, or arithmetic function reference is determined by the name of the datum or function (<a href="rjcnf-4.html#sh-4.1.2">4.1.2</a>).  The data type of an arithmetic expression containing one or more arithmetic operators is determined from the data types of the operands.
<p>
<i>Integer expressions, real expressions, double precision expressions,</i> and <i>complex expressions</i> are arithmetic expressions whose values are of type integer, real, double precision, and complex, respectively.
<p>
When the operator + or - operates on a single operand, the data type of the resulting expression is the same as the data type of the operand.
<p>
When an arithmetic operator operates on a pair of operands, the data type of the resulting expression is given in Tables 2 and 3.  In these tables, each letter I, R, D, or C represents an operand or result of type integer, real,
double precision, or complex, respectively.
<p>
The type of the result is indicated by the I, R, D, or C that precedes the equals, and the interpretation is indicated by the expression to the right of the equals.  REAL, DBLE, and CMPLX are the type-conversion functions described in <a href="rjcnf-15.html#sh-15.10">15.10</a>.

<h4 align="center">Table 2 Type and Interpretation of Result for x<sub>1</sub> + x<sub>2</sub></h4>
<pre>
          ____________________________________________________________
          |   x  |                          |                        |
          | x  2 |            I             |           R            |
          |  1   |             2            |            2           |
          |______|__________________________|________________________|
          |      |                          |                        |
          |  I   |  I = I  + I              |  R = REAL(I ) + R      |
          |   1  |       1    2             |            1     2     |
          |  R   |  R = R  + REAL(I )       |  R = R  + R            |
          |   1  |       1         2        |       1    2           |
          |  D   |  D = D  + DBLE(I )       |  D = D  + DBLE(R )     |
          |   1  |       1         2        |       1         2      |
          |  C   |  C=C +CMPLX(REAL(I ),0.) |  C = C  + CMPLX(R ,0.) |
          |   1  |     1             2      |       1          2     |
          |______|__________________________|________________________|

          ____________________________________________________________
          |    x  |                      |                           |
          | x   2 |          D           |            C              |
          |  1    |           2          |             2             |
          |_______|______________________|___________________________|
          |       |                      |                           |
          |  I    |  D = DBLE(I ) + D    |  C=CMPLX(REAL(I ),0.)+C   |
          |   1   |            2     2   |                2       2  |
          |  R    |  D = DBLE(R ) + D    |  C = CMPLX(R ,0.) + C     |
          |   1   |            1     2   |             1        2    |
          |  D    |  D = D  + D          |        Prohibited         |
          |   1   |       1    2         |                           |
          |  C    |      Prohibited      |  C = C  + C               |
          |   1   |                      |       1    2              |
          |_______|______________________|___________________________|
</pre><p>
Tables giving the type and interpretation of expressions involving -, *, and / may be obtained by replacing all occurrences of + in Table 2 by -, *, or /, respectively.

<h4 align="center">Table 3 Type and Interpretation of Result for x<sub>1</sub>**x<sub>2</sub></h4>
<pre>
          ____________________________________________________________
          |      x   |                   |                           |
          |  x    2  |        I          |            R              |
          |   1      |         2         |             2             |
          |__________|___________________|___________________________|
          |          |                   |                           |
          |    I     |    I = I **I      |    R = REAL(I )**R        |
          |     1    |         1   2     |              1    2       |
          |    R     |    R = R **I      |    R = R **R              |
          |     1    |         1   2     |         1   2             |
          |    D     |    D = D **I      |    D = D **DBLE(R )       |
          |     1    |         1   2     |         1        2        |
          |    C     |    C = C **I      |    C = C **CMPLX(R ,0.)   |
          |     1    |         1   2     |         1         2       |
          |__________|___________________|___________________________|






          ____________________________________________________________
          |    x  |                     |                            |
          | x   2 |         D           |             C              |
          |  1    |          2          |              2             |
          |_______|_____________________|____________________________|
          |       |                     |                            |
          |  I    |  D = DBLE(I )**D    |  C=CMPLX(REAL(I ),0.)**C   |
          |   2   |            2    2   |                2        2  |
          |  R    |  D = DBLE(R )**D    |  C = CMPLX(R ,0.)**C       |
          |   1   |            1    2   |             1       2      |
          |  D    |  D = D **D          |         Prohibited         |
          |   1   |       1   2         |                            |
          |  C    |     Prohibited      |  C = C **C                 |
          |   1   |                     |       1   2                |
          |_______|_____________________|____________________________|
</pre><p>
Four entries in Table 3 specify an interpretation to be a complex value raised to a complex power.  In these cases, the value of the expression is the "principal value" determined by x<sub>1</sub>**x<sub>2</sub> = EXP(x<sub>2</sub>*LOG(x<sub>1</sub>)), where EXP and LOG are functions described in <a href="rjcnf-15.html#sh-15.10">15.10</a>.
<p>
Except for a value raised to an integer power, Tables 2 and 3 specify that if two operands are of different type, the operand that differs in type from the result of the operation is converted to the type of the result and then the operator operates on a pair of operands of the same type.  When a primary of type real, double precision, or complex is raised to an integer power, the integer operand need not be converted.  If the value of I<sub>2</sub> is negative, the interpretation of I<sub>1</sub>**I<sub>2</sub> is the same as the interpretation of 1/(I<sub>1</sub>**ABS(I<sub>2</sub>)), which is subject to the rules for integer division (<a href="#sh-6.1.5">6.1.5</a>).  For example, 2**(-3) has the value of 1/(2**3), which is zero.
<p>
The type and interpretation of an expression that consists of an operator operating on either a single operand or a pair of operands are independent of the context in which the expression appears.  In particular, the type and interpretation of such an expression are independent of the type of any other operand of any larger expression in which it appears.  For example, if X is of type real, J is of type integer, and INT is the real-to-integer conversion function, the expression INT(X+J) is an integer expression and X+J is a real expression.

<h3><a name="sh-6.1.5">6.1.5 Integer Division.</a></h3>

One operand of type integer may be divided by another operand of type integer.  Although the mathematical quotient of two integers is not necessarily an integer, Table 2 specifies that an expression involving the division operator with two operands of type integer is interpreted as an expression of type integer.  The result of such a division is called an <i>integer quotient</i> and is obtained as follows: If the magnitude of the mathematical quotient is less than one, the integer quotient is zero.  Otherwise, the integer quotient is the integer whose magnitude is the largest integer that does not exceed the magnitude of the mathematical quotient and whose sign is the same as the sign of the mathematical quotient.  For example, the value of the expression (-8)/3 is (-2).

<h2><a name="sh-6.2">6.2 Character Expressions</a></h2>

A character expression is used to express a character string.  Evaluation of a character expression produces a result of type character.
<p>
The simplest form of a character expression is a character constant, symbolic name of a character constant, character variable reference, character array element reference, character substring reference, or character function reference. More complicated character expressions may be formed by using one or more character operands together with character operators and parentheses.

<h3><a name="sh-6.2.1">6.2.1 Character Operator.</a></h3>

The character operator is:
<p><pre>
                          ____________________________
                          |          |               |
                          | Operator | Representing  |
                          |__________|_______________|
                          |          |               |
                          |    //    | Concatenation |
                          |__________|_______________|
</pre><p>
The interpretation of the expression formed with the character operator is:
<p><pre>
                  ____________________________________________
                  |                 |                        |
                  | Use of Operator | Interpretation         |
                  |_________________|________________________|
                  |                 |                        |
                  |    x  // x      | Concatenate x  with x  |
                  |     1     2     |              1       2 |
                  |_________________|________________________|
</pre>
where:<ul>
<li>x<sub>1</sub> denotes the operand to the left of the operator
<li>x<sub>2</sub> denotes the operand to the right of the operator
</ul><p>
The result of a concatenation operation is a character string whose value is the value of x<sub>1</sub> concatenated on the right with the value of x<sub>2</sub> and whose length is the sum of the lengths of x<sub>1</sub> and x<sub>2</sub>.  For example, the value of 'AB' // 'CDE' is the string ABCDE.

<h3><a name="sh-6.2.2">6.2.2 Form and Interpretation of Character Expressions.</a></h3>

A character expression and the operands of a character expression must identify values of type character.  Except in a character assignment statement (<a href="rjcnf-10.html#sh-10.4">10.4</a>), a character expression must not involve concatenation of an operand whose length specification is an asterisk in parentheses (<a href="rjcnf-8.html#sh-8.4.2">8.4.2</a>) unless the operand is the symbolic name of a constant.

<h4><a name="sh-6.2.2.1">6.2.2.1 Character Primaries.</a></h4>

The <i>character primaries</i> are:
<p><ol>
<li>Character constant (<a href="rjcnf-4.html#sh-4.8.1">4.8.1</a>)
<li>Symbolic name of a character constant (<a href="rjcnf-8.html#sh-8.6">8.6</a>)
<li>Character variable reference (<a href="rjcnf-2.html#sh-2.5">2.5</a>)
<li>Character array element reference (<a href="rjcnf-5.html#sh-5.3">5.3</a>)
<li>Character substring reference (<a href="rjcnf-5.html#sh-5.7">5.7</a>)
<li>Character function reference (<a href="rjcnf-15.html#sh-15.2">15.2</a>)
<li>Character expression enclosed in parentheses (<a href="#sh-6.2.2.2">6.2.2.2</a>)
</ol>
<h4><a name="sh-6.2.2.2">6.2.2.2 Character Expression.</a></h4>

The forms of a <i>character expression</i> are:
<p><ol>
<li>Character primary
<li>Character expression // character primary
</ol><p>
Thus, a character expression is a sequence of one or more character primaries separated by the concatenation operator. Form (2) indicates that in a character expression containing two or more concatenation operators, the primaries are combined from left to right to establish the interpretation of the expression.  For example, the formation rules specify that the interpretation of the character expression
<p><pre>
      'AB' // 'CD' // 'EF'
</pre><p>
is the same as the interpretation of the character expression
<p><pre>
      ('AB' // 'CD') // 'EF'
</pre><p>
The value of the character expression in this example is the same as that of the constant 'ABCDEF'.  Note that parentheses have no effect on the value of a character expression.

<h3><a name="sh-6.2.3">6.2.3 Character Constant Expression.</a></h3>

A <i>character constant expression</i> is a character expression in which each primary is a character constant, the symbolic name of a character constant, or a character constant expression enclosed in parentheses.  Note that variable, array element, substring, and function references are not
allowed.

<h2><a name="sh-6.3">6.3 Relational Expressions</a></h2>

A relational expression is used to compare the values of two arithmetic expressions or two character expressions.  A relational expression may not be used to compare the value of an arithmetic expression with the value of a
character expression.
<p>
Relational expressions may appear only within logical expressions.  Evaluation of a relational expression produces a result of type logical, with a value of true or false.

<h3><a name="sh-6.3.1">6.3.1 Relational Operators.</a></h3>

The relational operators are:
<p><pre>
                     _______________________________________
                     |          |                          |
                     | Operator | Representing             |
                     |__________|__________________________|
                     |          |                          |
                     |   .LT.   | Less than                |
                     |   .LE.   | Less than or equal to    |
                     |   .EQ.   | Equal to                 |
                     |   .NE.   | Not equal to             |
                     |   .GT.   | Greater than             |
                     |   .GE.   | Greater than or equal to |
                     |__________|__________________________|
</pre>
<h3><a name="sh-6.3.2">6.3.2 Arithmetic Relational Expression.</a></h3>

The form of an <i>arithmetic relational expression</i> is:
<p><pre>
      <i>e</i><sub>1</sub> <i>relop</i> <i>e</i><sub>2</sub>
</pre><p>
where:<ul>
<li><i>e</i><sub>1</sub> and <i>e</i><sub>2</sub> are each an integer, real, double precision, or complex expression
<li><i>relop</i> is a relational operator
</ul><p>
A complex operand is permitted only when the relational operator is .EQ. or .NE.

<h3><a name="sh-6.3.3">6.3.3 Interpretation of Arithmetic Relational Expressions.</a></h3>

An arithmetic relational expression is interpreted as having the logical value true if the values of the operands satisfy the relation specified by the operator.  An arithmetic relational expression is interpreted as having the logical value false if the values of the operands do not satisfy the relation specified by the operator.
<p>
If the two arithmetic expressions are of different types, the value of the relational expression
<p><pre>
      <i>e</i><sub>1</sub> <i>relop</i> <i>e</i><sub>2</sub>
</pre><p>
is the value of the expression
<p><pre>
      ((<i>e</i><sub>1</sub>) - (<i>e</i><sub>2</sub>)) <i>relop</i> 0
</pre><p>
where 0 (zero) is of the same type as the expression ((<i>e</i><sub>1</sub>) (<i>e</i> ))<sub>2</sub>, and <i>relop</i> is the same relational operator in both expressions.  Note that the comparison of a double precision value and a complex value is not permitted.

<h3><a name="sh-6.3.4">6.3.4 Character Relational Expression.</a></h3>

The form of a <i>character relational expression</i> is:
<p><pre>
      <i>e</i><sub>1</sub> <i>relop</i> <i>e</i><sub>2</sub>
</pre><p>
where:<ul>
<li><i>e</i><sub>1</sub> and <i>e</i><sub>2</sub> are character expressions
<li><i>relop</i> is a relational operator
</ul>
<h3><a name="sh-6.3.5">6.3.5 Interpretation of Character Relational Expressions.</a></h3>

A character relational expression is interpreted as the logical value true if the values of the operands satisfy the relation specified by the operator.  A character relational expression is interpreted as the logical value false if the values of the operands do not satisfy the relation specified by the operator.
<p>
The character expression <i>e</i><sub>1</sub> is considered to be less than <i>e</i><sub>2</sub> if the value of <i>e</i><sub>1</sub> precedes the value of <i>e</i><sub>2</sub> in the collating sequence; <i>e</i><sub>1</sub> is greater than <i>e</i><sub>2</sub> if the value of <i>e</i><sub>1</sub> follows the value of <i>e</i><sub>2</sub> in the collating sequence (<a href="rjcnf-3.html#sh-3.1.5">3.1.5</a>).  Note that the collating sequence depends partially on the processor; however, the result of the use of the operators .EQ. and .NE. does not depend on the collating sequence.  If the operands are of unequal length, the shorter operand is considered as if it were extended on the right with blanks to the length of the longer operand.

<h2><a name="sh-6.4">6.4 Logical Expressions</a></h2>

A logical expression is used to express a logical computation.  Evaluation of a logical expression produces a result of type logical, with a value of true or false.
<p>
The simplest form of a logical expression is a logical constant, symbolic name of a logical constant, logical variable reference, logical array element reference, logical function reference, or relational expression.  More complicated logical expressions may be formed by using one or more logical operands together with logical operators and parentheses.

<h3><a name="sh-6.4.1">6.4.1 Logical Operators.</a></h3>

The <i>logical operators</i> are:
<p><pre>
                  ____________________________________________
                  |          |                               |
                  | Operator | Representing                  |
                  |__________|_______________________________|
                  |          |                               |
                  |  .NOT.   | Logical Negation              |
                  |  .AND.   | Logical Conjunction           |
                  |  .OR.    | Logical Inclusive Disjunction |
                  |  .EQV.   | Logical Equivalence           |
                  |  .NEQV.  | Logical Nonequivalence        |
                  |__________|_______________________________|
</pre>
<h3><a name="sh-6.4.2">6.4.2 Form and Interpretation of Logical Expressions.</a></h3>

A set of formation rules is used to establish the interpretation of a logical expression that contains two or more logical operators.  There is a precedence among the logical operators, which determines the order in which the operands are to be combined unless the order is changed by the use of parentheses.  The precedence of the logical operators is as follows:
<p><pre>
                        ________________________________
                        |                 |            |
                        |    Operator     | Precedence |
                        |_________________|____________|
                        |                 |            |
                        |      .NOT.      | Highest    |
                        |      .AND.      |            |
                        |      .OR.       |            |
                        | .EQV. or .NEQV. | Lowest     |
                        |_________________|____________|
</pre><p>
For example, in the expression
<p><pre>
      A .OR. B .AND. C
</pre><p>
the .AND. operator has higher precedence than the .OR. operator; therefore, the interpretation of the above expression is the same as the interpretation of the expression
<p><pre>
      A .OR. (B .AND. C)
</pre><p>
The <i>logical operands</i> are:
<p><ol>
<li>Logical primary
<li>Logical factor
<li>Logical term
<li>Logical disjunct
<li>Logical expression
</ol><p>
The formation rules to be applied in establishing the interpretation of a logical expression are in <a href="#sh-6.4.2.1">6.4.2.1</a> through 6.4.2.5.

<h4><a name="sh-6.4.2.1">6.4.2.1 Logical Primaries.</a></h4>

The <i>logical primaries</i> are:
<p><ol>
<li>Logical constant (<a href="rjcnf-4.html#sh-4.7.1">4.7.1</a>)
<li>Symbolic name of a logical constant (<a href="rjcnf-8.html#sh-8.6">8.6</a>)
<li>Logical variable reference (<a href="rjcnf-2.html#sh-2.5">2.5</a>)
<li>Logical array element reference (<a href="rjcnf-5.html#sh-5.3">5.3</a>)
<li>Logical function reference (<a href="rjcnf-15.html#sh-15.2">15.2</a>)
<li>Relational expression (<a href="#sh-6.3">6.3</a>)
<li>Logical expression enclosed in parentheses (<a href="#sh-6.4.2.5">6.4.2.5</a>)
</ol>
<h4><a name="sh-6.4.2.2">6.4.2.2 Logical Factor.</a></h4>

The forms of a <i>logical factor</i> are:
<p><ol>
<li>Logical primary
<li>logical primary
</ol>
<h4><a name="sh-6.4.2.3">6.4.2.3 Logical Term.</a></h4>

The forms of a <i>logical term</i> are:
<p><ol>
<li>Logical factor
<li>Logical term .AND. logical factor
</ol><p>
Thus, a logical term is a sequence of logical factors separated by the .AND. operator.  Form (2) indicates that in interpreting a logical term containing two or more .AND. operators, the logical factors are combined from left to right.

<h4><a name="sh-6.4.2.4">6.4.2.4 Logical Disjunct.</a></h4>

The forms of a <i>logical disjunct</i> are:
<p><ol>
<li>Logical term
<li>Logical disjunct .OR. logical term
</ol><p>
Thus, a logical disjunct is a sequence of logical terms separated by the .OR. operator.  Form (2) indicates that in interpreting a logical disjunct containing two or more .OR. operators, the logical terms are combined from left to right.

<h4><a name="sh-6.4.2.5">6.4.2.5 Logical Expression.</a></h4>

The forms of a <i>logical expression</i> are:
<p><ol>
<li>Logical disjunct
<li>Logical expression .EQV. logical disjunct
<li>Logical expression .NEQV. logical disjunct
</ol><p>
Thus, a logical expression is a sequence of logical disjuncts separated by either the .EQV. operator or the .NEQV. operator.  Forms (2) and (3) indicate that in interpreting a logical expression containing two or more .EQV. or .NEQV. operators, the logical disjuncts are combined from left to right.

<h3><a name="sh-6.4.3">6.4.3 Value of Logical Factors, Terms, Disjuncts, and Expressions.</a></h3>

The value of a logical factor involving .NOT. is shown below:
<p><pre>
                              ____________________
                              |       |          |
                              |  x    | .NOT. x  |
                              |   2   |        2 |
                              |_______|__________|
                              |       |          |
                              | true  |  false   |
                              | false |  true    |
                              |_______|__________|
</pre><p>
The value of a logical term involving .AND. is shown below:
<p><pre>
                         _______________________________
                         |       |       |             |
                         |  x    |  x    | x  .AND. x  |
                         |   1   |   2   |  1        2 |
                         |_______|_______|_____________|
                         |       |       |             |
                         | true  | true  |    true     |
                         | true  | false |    false    |
                         | false | true  |    false    |
                         | false | false |    false    |
                         |_______|_______|_____________|
</pre><p>
The value of a logical disjunct involving .OR. is shown below:
<p><pre>
                         ______________________________
                         |       |       |            |
                         |  x    |  x    | x  .OR. x  |
                         |   1   |   2   |  1       2 |
                         |_______|_______|____________|
                         |       |       |            |
                         | true  | true  |   true     |
                         | true  | false |   true     |
                         | false | true  |   true     |
                         | false | false |   false    |
                         |_______|_______|____________|
</pre><p>
The value of a logical expression involving .EQV. is shown below:
<p><pre>
                         _______________________________
                         |       |       |             |
                         |  x    |  x    | x  .EQV. x  |
                         |   1   |   2   |  1        2 |
                         |_______|_______|_____________|
                         |       |       |             |
                         | true  | true  |    true     |
                         | true  | false |    false    |
                         | false | true  |    false    |
                         | false | false |    true     |
                         |_______|_______|_____________|
</pre><p>
The value of a logical expression involving .NEQV. is shown below:
<p><pre>
                         ________________________________
                         |       |       |              |
                         |  x    |  x    | x  .NEQV. x  |
                         |   1   |   2   |  1         2 |
                         |_______|_______|______________|
                         |       |       |              |
                         | true  | true  |    false     |
                         | true  | false |    true      |
                         | false | true  |    true      |
                         | false | false |    false     |
                         |_______|_______|______________|
</pre>
<h3><a name="sh-6.4.4">6.4.4 Logical Constant Expression.</a></h3>

A <i>logical constant expression</i> is a logical expression in which each primary is a logical constant, the symbolic name of a logical constant, a relational expression in which each primary is a constant expression, or a logical constant expression enclosed in parentheses.  Note that variable, array element, and function references are not allowed.

<h2><a name="sh-6.5">6.5 Precedence of Operators</a></h2>

In <a href="#sh-6.1.2">6.1.2</a> and <a href="#sh-6.4.2">6.4.2</a> precedences have been established among the arithmetic operators and the logical operators, respectively.  There is only one character operator.  No precedence has been established among the relational operators. The precedences among the various operators are:
<p><pre>
                          ___________________________
                          |            |            |
                          | Operator   | Precedence |
                          |____________|____________|
                          |            |            |
                          | Arithmetic | Highest    |
                          | Character  |            |
                          | Relational |            |
                          | Logical    | Lowest     |
                          |____________|____________|
</pre><p>
An expression may contain more than one kind of operator.  For example, the logical expression
<p><pre>
      L .OR. A + B .GE. C
</pre><p>
where A, B, and C are of type real, and L is of type logical, contains an arithmetic operator, a relational operator, and a logical operator.  This expression would be interpreted the same as the expression
<p><pre>
      L .OR. ((A + B) .GE. C)
</pre>
<h3><a name="sh-6.5.1">6.5.1 Summary of Interpretation Rules.</a></h3>

The order in which primaries are combined using operators is determined by the following:
<p><ol>
<li>Use of parentheses
<li>Precedence of the operators
<li>Right-to-left interpretation of exponentiations in a factor
<li>Left-to-right interpretation of multiplications and divisions in a term
<li>Left-to-right interpretation of additions and subtractions in an arithmetic expression
<li>Left-to-right interpretation of concatenations in a character expression
<li>Left-to-right interpretation of conjunctions in a logical term
<li>Left-to-right interpretation of disjunctions in a logical disjunct
<li>Left-to-right interpretation of logical equivalences in a logical expression
</ol>
<h2><a name="sh-6.6">6.6 Evaluation of Expressions</a></h2>

This section applies to arithmetic, character, relational, and logical expressions.
<p>
Any variable, array element, function, or character substring referenced as an operand in an expression must be defined at the time the reference is executed.  An integer operand must be defined with an integer value rather than a statement label value.  Note that if a character string or substring is referenced, all of the referenced characters must be defined at the time the reference is executed.
<p>
Any arithmetic operation whose result is not mathematically defined is prohibited in the execution of an executable program.  Examples are dividing by zero and raising a zero- valued primary to a zero-valued or negative-valued power.  Raising a negative-valued primary to a real or double precision power is also prohibited.
<p>
The execution of a function reference in a statement may not alter the value of any other entity within the statement in which the function reference appears.  The execution of a function reference in a statement may not alter the value of any entity in common (<a href="rjcnf-8.html#sh-8.3">8.3</a>) that affects the value of any other function reference in that statement.  However, execution of a function reference in the expression <i>e</i> of a logical IF statement (<a href="rjcnf-11.html#sh-11.5">11.5</a>) is permitted to affect entities in the statement <i>st</i> that is executed when the value of the expression <i>e</i> is true.  If a function reference causes definition of an actual argument of the function, that argument or any associated entities must not appear elsewhere in the same statement. For example, the statements
<p><pre>
      A(I) = F(I)

      Y = G(X) + X
</pre><p>
are prohibited if the reference to F defines I or the reference to G defines X.
<p>
The data type of an expression in which a function reference appears does not affect the evaluation of the actual arguments of the function.  The data type of an expression in which a function reference appears is not affected by the evaluation of the actual arguments of the function, except that the result of a generic function reference assumes a data type that depends on the data type of its arguments as specified in <a href="rjcnf-15.html#sh-15.10">15.10</a>.
<p>
Any execution of an array element reference requires the evaluation of its subscript.  The data type of an expression in which a subscript appears does not affect, nor is it affected by, the evaluation of the subscript.
<p>
Any execution of a substring reference requires the evaluation of its substring expressions.  The data type of an expression in which a substring name appears does not affect, nor is it affected by, the evaluation of the substring expressions.

<h3><a name="sh-6.6.1">6.6.1 Evaluation of Operands.</a></h3>

It is not necessary for a processor to evaluate all of the operands of an expression if the value of the expression can be determined otherwise.  This principle is most often applicable to logical express(ions, but it applies to all expressions.  For example, in evaluating the logical expression
<p><pre>
      X .GT. Y .OR. L(Z)
</pre><p>
where X, Y, and Z are real, and L is a logical function, the function reference L(Z) need not be evaluated if X is greater than Y.  If a statement contains a function reference in a part of an expression that need not be evaluated, all entities that would have become defined in the execution of that reference become undefined at the completion of evaluation of the expression containing the function reference.  In the example above, evaluation of the expression causes Z to become undefined if L defines
its argument.

<h3><a name="sh-6.6.2">6.6.2 Order of Evaluation of Functions.</a></h3>

If a statement contains more than one function reference, a processor may evaluate the functions in any order, except for a logical IF statement and a function argument list containing function references.  For example, the statement
<p><pre>
      Y = F(G(X))
</pre><p>
where F and G are functions, requires G to be evaluated before F is evaluated.
<p>
In a statement that contains more than one function reference, the value provided by each function reference must be independent of the order chosen by the processor for evaluation of the function references.

<h3><a name="sh-6.6.3">6.6.3 Integrity of Parentheses.</a></h3>

The sections that follow state certain conditions under which a processor may evaluate an expression different from the one obtained by applying the interpretation rules given in <a href="#sh-6.1">6.1</a> through 6.5.  However, any expression contained in parentheses must be treated as an entity.  For example, in evaluating the expression A*(B*C), the product of B and C must be evaluated and then multiplied by A; the processor must not evaluate the mathematically equivalent expression (A*B)*C.

<h3><a name="sh-6.6.4">6.6.4 Evaluation of Arithmetic Expressions.</a></h3>

The rules given in <a href="#sh-6.1.2">6.1.2</a> specify the interpretation of an arithmetic expression.  Once the interpretation has been established in accordance with those rules, the processor may evaluate any mathematically equivalent expression, provided that the integrity of parentheses is not violated.
<p>
Two arithmetic expressions are mathematically equivalent if, for all possible values of their primaries, their mathematical values are equal.  However, mathematically equivalent arithmetic expressions may produce different computational results.
<p>
The mathematical definition of integer division is given in <a href="#sh-6.1.5">6.1.5</a>.  The difference between the value of the expression 5/2 and 5./2. is a mathematical difference, not a computational difference.
<p>
The following are examples of expressions, along with allowable alternative forms that may be used by the processor in the evaluation of those expressions.  A, B, and C represent arbitrary real, double precision, or complex operands; I and J represent arbitrary integer operands; and X, Y, and Z represent arbitrary arithmetic operands.  (Note that Table 2 prohibits combinations of double precision and complex data types.)
<p><pre>
                   ___________________________________________
                   |            |                            |
                   | Expression | Allowable Alternative Form |
                   |____________|____________________________|
                   |            |                            |
                   | X+Y        | Y+X                        |
                   | X*Y        | Y*X                        |
                   | -X+Y       | Y-X                        |
                   | X+Y+Z      | X+(Y+Z)                    |
                   | X-Y+Z      | X-(Y-Z)                    |
                   | X*B/Z      | X*(B/Z)                    |
                   | X*Y-X*Z    | X*(Y-Z)                    |
                   | A/B/C      | A/(B*C)                    |
                   | A/5.0      | 0.2*A                      |
                   |____________|____________________________|
</pre><p>
The following are examples of expressions along with forbidden forms that must not be used by the processor in the evaluation of those expressions.
<p><pre>
                   __________________________________________
                   |             |                          |
                   | Expression  | Nonallowable Alternative |
                   |             |           Form           |
                   |_____________|__________________________|
                   |             |                          |
                   | I/2         | 0.5*I                    |
                   | X*I/J       | X*(I/J)                  |
                   | I/J/A       | I/(J*A)                  |
                   | (X*Y)-(X*Z) | X*(Y-Z)                  |
                   | X*(Y-Z)     | X*Y-X*Z                  |
                   |_____________|__________________________|
</pre><p>
In addition to the parentheses required to establish the desired interpretation, parentheses may be included to restrict the alternative forms that may be used by the processor in the actual evaluation of the expression.  This is useful for controlling the magnitude and accuracy of intermediate values developed during the evaluation of an expression.  For example, in the expression
<p><pre>
      A+(B-C)
</pre><p>
the term (B-C) must be evaluated and then added to A.  Note that the inclusion of parentheses may change the mathematical value of an expression.  For example, the two expressions:
<p><pre>
      A*I/J

      A*(I/J)
</pre><p>
may have different mathematical values if I and J are factors of integer data type.
<p>
Each operand of an arithmetic operator has a data type that may depend on the order of evaluation used by the processor.  For example, in the evaluation of the expression
<p><pre>
      D+R+I
</pre><p>
where D, R, and I represent terms of double precision, real, and integer data type, respectively, the data type of the operand that is added to I may be either double precision or real, depending on which pair of operands (D
and R, R and I, or D and I) is added first.

<h3><a name="sh-6.6.5">6.6.5 Evaluation of Character Expressions.</a></h3>

The rules given in <a href="#sh-6.2.2">6.2.2</a> specify the interpretation of a character expression as a string of characters.  A processor needs to evaluate only as much of the character expression as is required by the context in which the expression appears.  For example, the statements
<p><pre>
      CHARACTER*2 C1,C2,C3,CF
      C1 = C2 // CF(C3)
</pre><p>
do not require the function CF to be evaluated, because only the value of C2 is needed to determine the value of C1.

<h3><a name="sh-6.6.6">6.6.6 Evaluation of Relational Expressions.</a></h3>

The rules given in <a href="#sh-6.3.3">6.3.3</a> and <a href="#sh-6.3.5">6.3.5</a> specify the interpretation of relational expressions.  Once the interpretation of an expression has been established in accordance with those rules, the processor may evaluate any other expression that is relationally equivalent.  For example, the processor may choose to evaluate the relational expression
<p><pre>
      I .GT. J
</pre><p>
where I and J are integer variables, as
<p><pre>
      J - I .LT. 0
</pre><p>
Two relational expressions are relationally equivalent if their logical values are equal for all possible values of their primaries.

<h3><a name="sh-6.6.7">6.6.7 Evaluation of Logical Expressions.</a></h3>

The rules given in <a href="#sh-6.4.2">6.4.2</a> specify the interpretation of a logical expression.  Once the interpretation of an expression has been established in accordance with those rules, the processor may evaluate any other expression that is logically equivalent, provided that the integrity of parentheses is not violated.  For example, the processor may choose to evaluate the logical expression
<p><pre>
      L1 .AND. L2 .AND. L3
</pre><p>
where L1, L2, and L3 are logical variables, as
<p><pre>
      L1 .AND. (L2 .AND. L3)
</pre><p>
Two logical expressions are logically equivalent if their values are equal for all possible values of their primaries.

<h2><a name="sh-6.7">6.7 Constant Expressions</a></h2>

A <i>constant expression</i> is an arithmetic constant expression (<a href="#sh-6.1.3">6.1.3</a>), a character constant expression (<a href="#sh-6.2.3">6.2.3</a>), or a logical constant expression (<a href="#sh-6.4.4">6.4.4</a>).
<p>
<hr>
<i>This document was translated by troff2html v0.21 on August 16, 1995.</i>
</body></html>
<!--
     FILE ARCHIVED ON 20:27:07 Mar 26, 2006 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 22:52:57 Apr 15, 2023.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 81.037
  exclusion.robots: 0.061
  exclusion.robots.policy: 0.053
  cdx.remote: 0.049
  esindex: 0.008
  LoadShardBlock: 43.998 (3)
  PetaboxLoader3.datanode: 54.931 (4)
  load_resource: 55.863
  PetaboxLoader3.resolve: 28.284
-->